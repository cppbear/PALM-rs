{"dependencies":{"<&'a T as input::Input>::as_bytes":[],"<&'a T as input::Input>::at":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"<&'a T as input::Input>::is_empty_match":["input::Char","input::InputAt","prog::EmptyLook","prog::InstEmptyLook","std::marker::Sized","std::option::Option"],"<&'a T as input::Input>::len":[],"<&'a T as input::Input>::next_char":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"<&'a T as input::Input>::prefix_at":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'a T as input::Input>::previous_char":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"<&'a [u8] as re_bytes::Replacer>::no_expansion":["std::marker::Sized","std::option::Option"],"<&'a [u8] as re_bytes::Replacer>::replace_append":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<&'a prog::Program as std::iter::IntoIterator>::into_iter":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter":["re_set::bytes::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter":["re_set::unicode::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"<&'a std::string::String as re_unicode::Replacer>::no_expansion":["std::marker::Sized","std::option::Option","std::string::String"],"<&'a std::string::String as re_unicode::Replacer>::replace_append":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"<&'a std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<&'a std::vec::Vec<u8> as re_bytes::Replacer>::replace_append":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<&'a str as re_unicode::Replacer>::no_expansion":["std::marker::Sized","std::option::Option"],"<&'a str as re_unicode::Replacer>::replace_append":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"<F as re_bytes::Replacer>::replace_append":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<F as re_unicode::Replacer>::replace_append":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"<backtrack::Bounded<'a, 'm, 'r, 's, I> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"<backtrack::Cache as std::clone::Clone>::clone":["backtrack::Cache","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<backtrack::Cache as std::fmt::Debug>::fmt":["backtrack::Cache","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<backtrack::Job as std::clone::Clone>::clone":["backtrack::Job","input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"<backtrack::Job as std::fmt::Debug>::fmt":["backtrack::Job","input::Char","input::InputAt","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<compile::ByteClassSet as std::fmt::Debug>::fmt":["compile::ByteClassSet","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<compile::Hole as std::fmt::Debug>::fmt":["compile::Hole","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<compile::InstHole as std::clone::Clone>::clone":["compile::InstHole","prog::EmptyLook","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<compile::InstHole as std::fmt::Debug>::fmt":["compile::InstHole","prog::EmptyLook","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<compile::MaybeInst as std::clone::Clone>::clone":["compile::InstHole","compile::MaybeInst","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<compile::MaybeInst as std::fmt::Debug>::fmt":["compile::InstHole","compile::MaybeInst","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<compile::Patch as std::fmt::Debug>::fmt":["compile::Hole","compile::Patch","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<compile::SuffixCache as std::fmt::Debug>::fmt":["compile::SuffixCache","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<compile::SuffixCacheEntry as std::clone::Clone>::clone":["compile::SuffixCacheEntry","compile::SuffixCacheKey"],"<compile::SuffixCacheEntry as std::cmp::Eq>::assert_receiver_is_total_eq":["compile::SuffixCacheEntry","compile::SuffixCacheKey"],"<compile::SuffixCacheEntry as std::cmp::PartialEq>::eq":["compile::SuffixCacheEntry","compile::SuffixCacheKey"],"<compile::SuffixCacheEntry as std::default::Default>::default":["compile::SuffixCacheEntry","compile::SuffixCacheKey"],"<compile::SuffixCacheEntry as std::fmt::Debug>::fmt":["compile::SuffixCacheEntry","compile::SuffixCacheKey","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<compile::SuffixCacheEntry as std::hash::Hash>::hash":["compile::SuffixCacheEntry","compile::SuffixCacheKey","std::hash::Hasher","std::marker::Sized"],"<compile::SuffixCacheKey as std::clone::Clone>::clone":["compile::SuffixCacheKey"],"<compile::SuffixCacheKey as std::cmp::Eq>::assert_receiver_is_total_eq":["compile::SuffixCacheKey"],"<compile::SuffixCacheKey as std::cmp::PartialEq>::eq":["compile::SuffixCacheKey"],"<compile::SuffixCacheKey as std::default::Default>::default":["compile::SuffixCacheKey"],"<compile::SuffixCacheKey as std::fmt::Debug>::fmt":["compile::SuffixCacheKey","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<compile::SuffixCacheKey as std::hash::Hash>::hash":["compile::SuffixCacheKey","std::hash::Hasher","std::marker::Sized"],"<dfa::Byte as std::clone::Clone>::clone":["dfa::Byte"],"<dfa::Byte as std::fmt::Debug>::fmt":["dfa::Byte","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dfa::Cache as std::fmt::Debug>::fmt":["dfa::Cache","dfa::CacheInner","dfa::StateMap","dfa::Transitions","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<dfa::CacheInner as std::fmt::Debug>::fmt":["dfa::CacheInner","dfa::StateMap","dfa::Transitions","std::alloc::Allocator","std::collections::HashMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<dfa::EmptyFlags as std::clone::Clone>::clone":["dfa::EmptyFlags"],"<dfa::EmptyFlags as std::cmp::Eq>::assert_receiver_is_total_eq":["dfa::EmptyFlags"],"<dfa::EmptyFlags as std::cmp::PartialEq>::eq":["dfa::EmptyFlags"],"<dfa::EmptyFlags as std::default::Default>::default":["dfa::EmptyFlags"],"<dfa::EmptyFlags as std::fmt::Debug>::fmt":["dfa::EmptyFlags","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dfa::EmptyFlags as std::hash::Hash>::hash":["dfa::EmptyFlags","std::hash::Hasher","std::marker::Sized"],"<dfa::Fsm<'a> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"<dfa::InstPtrs<'a> as std::iter::Iterator>::next":["dfa::InstPtrs","std::marker::Sized","std::option::Option"],"<dfa::Result<T> as std::clone::Clone>::clone":["dfa::Result","std::marker::Sized"],"<dfa::Result<T> as std::fmt::Debug>::fmt":["dfa::Result","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dfa::State as std::clone::Clone>::clone":["dfa::State","std::alloc::Allocator","std::marker::Sized","std::sync::Arc"],"<dfa::State as std::cmp::Eq>::assert_receiver_is_total_eq":["dfa::State","std::alloc::Allocator","std::marker::Sized","std::sync::Arc"],"<dfa::State as std::cmp::PartialEq>::eq":["dfa::State","std::alloc::Allocator","std::marker::Sized","std::sync::Arc"],"<dfa::State as std::fmt::Debug>::fmt":["dfa::State","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<dfa::State as std::hash::Hash>::hash":["dfa::State","std::alloc::Allocator","std::hash::Hasher","std::marker::Sized","std::sync::Arc"],"<dfa::StateFlags as std::clone::Clone>::clone":["dfa::StateFlags"],"<dfa::StateFlags as std::cmp::Eq>::assert_receiver_is_total_eq":["dfa::StateFlags"],"<dfa::StateFlags as std::cmp::PartialEq>::eq":["dfa::StateFlags"],"<dfa::StateFlags as std::default::Default>::default":["dfa::StateFlags"],"<dfa::StateFlags as std::fmt::Debug>::fmt":["dfa::StateFlags","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<dfa::StateFlags as std::hash::Hash>::hash":["dfa::StateFlags","std::hash::Hasher","std::marker::Sized"],"<dfa::StateMap as std::fmt::Debug>::fmt":["dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<dfa::Transitions as std::clone::Clone>::clone":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<dfa::Transitions as std::fmt::Debug>::fmt":["dfa::Transitions","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt":["dfa::TransitionsRow","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<error::Error as std::clone::Clone>::clone":["error::Error","std::string::String"],"<error::Error as std::cmp::PartialEq>::eq":["error::Error","std::string::String"],"<error::Error as std::error::Error>::description":["error::Error","std::string::String"],"<error::Error as std::fmt::Debug>::fmt":["error::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<error::Error as std::fmt::Display>::fmt":["error::Error","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::string::String"],"<exec::Exec as std::clone::Clone>::clone":["exec::Exec","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<exec::Exec as std::fmt::Debug>::fmt":["exec::Exec","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","re_trait::Locations","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSync<'c> as std::fmt::Debug>::fmt":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","re_trait::Locations","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecNoSyncStr<'c> as std::fmt::Debug>::fmt":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<exec::ExecReadOnly as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"<exec::MatchLiteralType as std::clone::Clone>::clone":["exec::MatchLiteralType"],"<exec::MatchLiteralType as std::fmt::Debug>::fmt":["exec::MatchLiteralType","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<exec::MatchNfaType as std::clone::Clone>::clone":["exec::MatchNfaType"],"<exec::MatchNfaType as std::cmp::Eq>::assert_receiver_is_total_eq":["exec::MatchNfaType"],"<exec::MatchNfaType as std::cmp::PartialEq>::eq":["exec::MatchNfaType"],"<exec::MatchNfaType as std::fmt::Debug>::fmt":["exec::MatchNfaType","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<exec::MatchType as std::clone::Clone>::clone":["exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType"],"<exec::MatchType as std::fmt::Debug>::fmt":["exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<exec::ProgramCacheInner as std::fmt::Debug>::fmt":["backtrack::Cache","dfa::Cache","dfa::CacheInner","dfa::StateMap","dfa::Transitions","exec::ProgramCacheInner","pikevm::Cache","pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<expand::CaptureRef<'a> as std::clone::Clone>::clone":["expand::CaptureRef","expand::Ref"],"<expand::CaptureRef<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["expand::CaptureRef","expand::Ref"],"<expand::CaptureRef<'a> as std::cmp::PartialEq>::eq":["expand::CaptureRef","expand::Ref"],"<expand::CaptureRef<'a> as std::fmt::Debug>::fmt":["expand::CaptureRef","expand::Ref","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<expand::Ref<'a> as std::clone::Clone>::clone":["expand::Ref"],"<expand::Ref<'a> as std::cmp::Eq>::assert_receiver_is_total_eq":["expand::Ref"],"<expand::Ref<'a> as std::cmp::PartialEq>::eq":["expand::Ref"],"<expand::Ref<'a> as std::convert::From<&'a str>>::from":["expand::Ref"],"<expand::Ref<'a> as std::fmt::Debug>::fmt":["expand::Ref","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<expand::Ref<'static> as std::convert::From<usize>>::from":["expand::Ref"],"<input::ByteInput<'t> as input::Input>::as_bytes":["input::ByteInput"],"<input::ByteInput<'t> as input::Input>::at":["input::ByteInput","input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"<input::ByteInput<'t> as input::Input>::is_empty_match":["input::ByteInput","input::Char","input::InputAt","prog::EmptyLook","prog::InstEmptyLook","std::marker::Sized","std::option::Option"],"<input::ByteInput<'t> as input::Input>::len":["input::ByteInput"],"<input::ByteInput<'t> as input::Input>::next_char":["input::ByteInput","input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"<input::ByteInput<'t> as input::Input>::prefix_at":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","input::ByteInput","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<input::ByteInput<'t> as input::Input>::previous_char":["input::ByteInput","input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"<input::ByteInput<'t> as std::clone::Clone>::clone":["input::ByteInput"],"<input::ByteInput<'t> as std::fmt::Debug>::fmt":["input::ByteInput","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<input::ByteInput<'t> as std::ops::Deref>::deref":["input::ByteInput"],"<input::Char as std::clone::Clone>::clone":["input::Char"],"<input::Char as std::cmp::Eq>::assert_receiver_is_total_eq":["input::Char"],"<input::Char as std::cmp::Ord>::cmp":["input::Char","std::cmp::Ordering"],"<input::Char as std::cmp::PartialEq<char>>::eq":["input::Char"],"<input::Char as std::cmp::PartialEq>::eq":["input::Char"],"<input::Char as std::cmp::PartialOrd<char>>::partial_cmp":["input::Char","std::marker::Sized","std::option::Option"],"<input::Char as std::cmp::PartialOrd>::partial_cmp":["input::Char","std::marker::Sized","std::option::Option"],"<input::Char as std::convert::From<char>>::from":["input::Char"],"<input::Char as std::convert::From<std::option::Option<char>>>::from":["input::Char","std::marker::Sized","std::option::Option"],"<input::Char as std::fmt::Debug>::fmt":["input::Char","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<input::Char as std::hash::Hash>::hash":["input::Char","std::hash::Hasher","std::marker::Sized"],"<input::CharInput<'t> as input::Input>::as_bytes":["input::CharInput"],"<input::CharInput<'t> as input::Input>::at":["input::Char","input::CharInput","input::InputAt","std::marker::Sized","std::option::Option"],"<input::CharInput<'t> as input::Input>::is_empty_match":["input::Char","input::CharInput","input::InputAt","prog::EmptyLook","prog::InstEmptyLook","std::marker::Sized","std::option::Option"],"<input::CharInput<'t> as input::Input>::len":["input::CharInput"],"<input::CharInput<'t> as input::Input>::next_char":["input::Char","input::CharInput","input::InputAt","std::marker::Sized","std::option::Option"],"<input::CharInput<'t> as input::Input>::prefix_at":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","input::Char","input::CharInput","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<input::CharInput<'t> as input::Input>::previous_char":["input::Char","input::CharInput","input::InputAt","std::marker::Sized","std::option::Option"],"<input::CharInput<'t> as std::clone::Clone>::clone":["input::CharInput"],"<input::CharInput<'t> as std::fmt::Debug>::fmt":["input::CharInput","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<input::CharInput<'t> as std::ops::Deref>::deref":["input::CharInput"],"<input::InputAt as std::clone::Clone>::clone":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"<input::InputAt as std::fmt::Debug>::fmt":["input::Char","input::InputAt","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<literal::imp::LiteralIter<'a> as std::fmt::Debug>::fmt":["literal::imp::LiteralIter","regex_syntax::hir::literal::Literal","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<literal::imp::LiteralIter<'a> as std::iter::Iterator>::next":["literal::imp::LiteralIter","regex_syntax::hir::literal::Literal","std::marker::Sized","std::option::Option"],"<literal::imp::LiteralSearcher as std::clone::Clone>::clone":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<literal::imp::LiteralSearcher as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<literal::imp::Matcher as std::clone::Clone>::clone":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<literal::imp::Matcher as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<literal::imp::Memmem as std::clone::Clone>::clone":["literal::imp::Memmem","memchr::memmem::Finder"],"<literal::imp::Memmem as std::fmt::Debug>::fmt":["literal::imp::Memmem","memchr::memmem::Finder","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<literal::imp::SingleByteSet as std::clone::Clone>::clone":["literal::imp::SingleByteSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<literal::imp::SingleByteSet as std::fmt::Debug>::fmt":["literal::imp::SingleByteSet","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<pikevm::Cache as std::clone::Clone>::clone":["pikevm::Cache","pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<pikevm::Cache as std::fmt::Debug>::fmt":["pikevm::Cache","pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<pikevm::FollowEpsilon as std::clone::Clone>::clone":["pikevm::FollowEpsilon","std::marker::Sized","std::option::Option"],"<pikevm::FollowEpsilon as std::fmt::Debug>::fmt":["pikevm::FollowEpsilon","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result"],"<pikevm::Fsm<'r, I> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pikevm::Fsm","prog::Program","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"<pikevm::Threads as std::clone::Clone>::clone":["pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<pikevm::Threads as std::fmt::Debug>::fmt":["pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<pool::Pool<T> as std::fmt::Debug>::fmt":["pool::Pool","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<pool::PoolGuard<'a, T> as std::fmt::Debug>::fmt":["pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<pool::PoolGuard<'a, T> as std::ops::Drop>::drop":["pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"<prog::EmptyLook as std::clone::Clone>::clone":["prog::EmptyLook"],"<prog::EmptyLook as std::cmp::Eq>::assert_receiver_is_total_eq":["prog::EmptyLook"],"<prog::EmptyLook as std::cmp::PartialEq>::eq":["prog::EmptyLook"],"<prog::EmptyLook as std::fmt::Debug>::fmt":["prog::EmptyLook","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<prog::Inst as std::clone::Clone>::clone":["prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<prog::Inst as std::fmt::Debug>::fmt":["prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<prog::InstBytes as std::clone::Clone>::clone":["prog::InstBytes"],"<prog::InstBytes as std::fmt::Debug>::fmt":["prog::InstBytes","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<prog::InstChar as std::clone::Clone>::clone":["prog::InstChar"],"<prog::InstChar as std::fmt::Debug>::fmt":["prog::InstChar","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<prog::InstEmptyLook as std::clone::Clone>::clone":["prog::EmptyLook","prog::InstEmptyLook"],"<prog::InstEmptyLook as std::fmt::Debug>::fmt":["prog::EmptyLook","prog::InstEmptyLook","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<prog::InstRanges as std::clone::Clone>::clone":["prog::InstRanges","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"<prog::InstRanges as std::fmt::Debug>::fmt":["prog::InstRanges","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<prog::InstSave as std::clone::Clone>::clone":["prog::InstSave"],"<prog::InstSave as std::fmt::Debug>::fmt":["prog::InstSave","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<prog::InstSplit as std::clone::Clone>::clone":["prog::InstSplit"],"<prog::InstSplit as std::fmt::Debug>::fmt":["prog::InstSplit","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<prog::Program as std::clone::Clone>::clone":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<prog::Program as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"<prog::Program as std::fmt::Debug>::fmt::visible_byte":["std::string::String"],"<prog::Program as std::fmt::Debug>::fmt::with_goto":["std::string::String"],"<prog::Program as std::ops::Deref>::deref":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<re_builder::RegexOptions as std::clone::Clone>::clone":["re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_builder::RegexOptions as std::default::Default>::default":["re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_builder::RegexOptions as std::fmt::Debug>::fmt":["re_builder::RegexOptions","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_builder::bytes::RegexBuilder as std::fmt::Debug>::fmt":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_builder::set_bytes::RegexSetBuilder as std::fmt::Debug>::fmt":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_builder::set_unicode::RegexSetBuilder as std::fmt::Debug>::fmt":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_builder::unicode::RegexBuilder as std::fmt::Debug>::fmt":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_bytes::CaptureLocations as std::clone::Clone>::clone":["re_bytes::CaptureLocations","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_bytes::CaptureLocations as std::fmt::Debug>::fmt":["re_bytes::CaptureLocations","re_trait::Locations","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_bytes::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::CaptureMatches","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::CaptureMatches","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::CaptureNames<'r> as std::clone::Clone>::clone":["re_bytes::CaptureNames","std::marker::Sized","std::slice::Iter"],"<re_bytes::CaptureNames<'r> as std::fmt::Debug>::fmt":["re_bytes::CaptureNames","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::slice::Iter"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::count":["re_bytes::CaptureNames","std::marker::Sized","std::slice::Iter"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::next":["re_bytes::CaptureNames","std::marker::Sized","std::option::Option","std::slice::Iter"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint":["re_bytes::CaptureNames","std::marker::Sized","std::option::Option","std::slice::Iter"],"<re_bytes::Captures<'t> as std::fmt::Debug>::fmt":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec"],"<re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_bytes::Captures<'t> as std::ops::Index<usize>>::index":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt":["re_bytes::Captures","re_bytes::CapturesDebug","re_trait::Locations","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec"],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte":["std::string::String"],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes":["std::string::String"],"<re_bytes::Match<'t> as std::clone::Clone>::clone":["re_bytes::Match"],"<re_bytes::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq":["re_bytes::Match"],"<re_bytes::Match<'t> as std::cmp::PartialEq>::eq":["re_bytes::Match"],"<re_bytes::Match<'t> as std::fmt::Debug>::fmt":["re_bytes::Match","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<re_bytes::Matches<'r, 't> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::Matches<'r, 't> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion":["re_bytes::NoExpand","std::marker::Sized","std::option::Option"],"<re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append":["re_bytes::Captures","re_bytes::NoExpand","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_bytes::NoExpand<'t> as std::clone::Clone>::clone":["re_bytes::NoExpand"],"<re_bytes::NoExpand<'t> as std::fmt::Debug>::fmt":["re_bytes::NoExpand","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<re_bytes::Regex as std::clone::Clone>::clone":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_bytes::Regex as std::convert::From<exec::Exec>>::from":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_bytes::Regex as std::fmt::Debug>::fmt":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<re_bytes::Regex as std::fmt::Display>::fmt":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<re_bytes::Regex as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion":["re_bytes::ReplacerRef","std::marker::Sized","std::option::Option"],"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append":["re_bytes::Captures","re_bytes::ReplacerRef","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_bytes::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":["re_bytes::ReplacerRef","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<re_bytes::Split<'r, 't> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Split","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::Split<'r, 't> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Split","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::SplitN<'r, 't> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Split","re_bytes::SplitN","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Split","re_bytes::SplitN","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Split","re_bytes::SplitN","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_bytes::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone":["re_bytes::Captures","re_bytes::SubCaptureMatches","re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_bytes::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt":["re_bytes::Captures","re_bytes::SubCaptureMatches","re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec"],"<re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next":["re_bytes::Captures","re_bytes::SubCaptureMatches","re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<re_set::bytes::RegexSet as std::clone::Clone>::clone":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_set::bytes::RegexSet as std::default::Default>::default":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_set::bytes::RegexSet as std::fmt::Debug>::fmt":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<re_set::bytes::SetMatches as std::clone::Clone>::clone":["re_set::bytes::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_set::bytes::SetMatches as std::fmt::Debug>::fmt":["re_set::bytes::SetMatches","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter":["re_set::bytes::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_set::bytes::SetMatchesIntoIter as std::fmt::Debug>::fmt":["re_set::bytes::SetMatchesIntoIter","std::fmt::Formatter","std::iter::Enumerate","std::marker::Sized","std::result::Result"],"<re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back":["re_set::bytes::SetMatchesIntoIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next":["re_set::bytes::SetMatchesIntoIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint":["re_set::bytes::SetMatchesIntoIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::bytes::SetMatchesIter<'a> as std::clone::Clone>::clone":["re_set::bytes::SetMatchesIter","std::iter::Enumerate","std::marker::Sized"],"<re_set::bytes::SetMatchesIter<'a> as std::fmt::Debug>::fmt":["re_set::bytes::SetMatchesIter","std::fmt::Formatter","std::iter::Enumerate","std::marker::Sized","std::result::Result"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back":["re_set::bytes::SetMatchesIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next":["re_set::bytes::SetMatchesIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint":["re_set::bytes::SetMatchesIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::unicode::RegexSet as std::clone::Clone>::clone":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_set::unicode::RegexSet as std::default::Default>::default":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_set::unicode::RegexSet as std::fmt::Debug>::fmt":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<re_set::unicode::SetMatches as std::clone::Clone>::clone":["re_set::unicode::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_set::unicode::SetMatches as std::fmt::Debug>::fmt":["re_set::unicode::SetMatches","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter":["re_set::unicode::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_set::unicode::SetMatchesIntoIter as std::fmt::Debug>::fmt":["re_set::unicode::SetMatchesIntoIter","std::fmt::Formatter","std::iter::Enumerate","std::marker::Sized","std::result::Result"],"<re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back":["re_set::unicode::SetMatchesIntoIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next":["re_set::unicode::SetMatchesIntoIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint":["re_set::unicode::SetMatchesIntoIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::unicode::SetMatchesIter<'a> as std::clone::Clone>::clone":["re_set::unicode::SetMatchesIter","std::iter::Enumerate","std::marker::Sized"],"<re_set::unicode::SetMatchesIter<'a> as std::fmt::Debug>::fmt":["re_set::unicode::SetMatchesIter","std::fmt::Formatter","std::iter::Enumerate","std::marker::Sized","std::result::Result"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back":["re_set::unicode::SetMatchesIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next":["re_set::unicode::SetMatchesIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint":["re_set::unicode::SetMatchesIter","std::iter::Enumerate","std::marker::Sized","std::option::Option"],"<re_trait::CaptureMatches<'t, R> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_trait::Locations as std::clone::Clone>::clone":["re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_trait::Locations as std::fmt::Debug>::fmt":["re_trait::Locations","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_trait::Matches<'t, R> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_trait::Matches<'t, R> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_trait::SubCapturesPosIter<'c> as std::clone::Clone>::clone":["re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_trait::SubCapturesPosIter<'c> as std::fmt::Debug>::fmt":["re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::count":["re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next":["re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::size_hint":["re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<re_unicode::CaptureLocations as std::clone::Clone>::clone":["re_trait::Locations","re_unicode::CaptureLocations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"<re_unicode::CaptureLocations as std::fmt::Debug>::fmt":["re_trait::Locations","re_unicode::CaptureLocations","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<re_unicode::CaptureMatches<'r, 't> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","re_unicode::CaptureMatches","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","re_unicode::CaptureMatches","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::CaptureNames<'r> as std::clone::Clone>::clone":["re_unicode::CaptureNames","std::marker::Sized","std::slice::Iter"],"<re_unicode::CaptureNames<'r> as std::fmt::Debug>::fmt":["re_unicode::CaptureNames","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::slice::Iter"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::count":["re_unicode::CaptureNames","std::marker::Sized","std::slice::Iter"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::next":["re_unicode::CaptureNames","std::marker::Sized","std::option::Option","std::slice::Iter"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint":["re_unicode::CaptureNames","std::marker::Sized","std::option::Option","std::slice::Iter"],"<re_unicode::Captures<'t> as std::fmt::Debug>::fmt":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec"],"<re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_unicode::Captures<'t> as std::ops::Index<usize>>::index":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt":["re_trait::Locations","re_unicode::Captures","re_unicode::CapturesDebug","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec"],"<re_unicode::Match<'t> as std::clone::Clone>::clone":["re_unicode::Match"],"<re_unicode::Match<'t> as std::cmp::Eq>::assert_receiver_is_total_eq":["re_unicode::Match"],"<re_unicode::Match<'t> as std::cmp::PartialEq>::eq":["re_unicode::Match"],"<re_unicode::Match<'t> as std::fmt::Debug>::fmt":["re_unicode::Match","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<re_unicode::Matches<'r, 't> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::Matches<'r, 't> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion":["re_unicode::NoExpand","std::marker::Sized","std::option::Option"],"<re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append":["re_trait::Locations","re_unicode::Captures","re_unicode::NoExpand","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"<re_unicode::NoExpand<'t> as std::clone::Clone>::clone":["re_unicode::NoExpand"],"<re_unicode::NoExpand<'t> as std::fmt::Debug>::fmt":["re_unicode::NoExpand","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<re_unicode::Regex as std::clone::Clone>::clone":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_unicode::Regex as std::convert::From<exec::Exec>>::from":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"<re_unicode::Regex as std::fmt::Debug>::fmt":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<re_unicode::Regex as std::fmt::Display>::fmt":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc"],"<re_unicode::Regex as std::str::FromStr>::from_str":["std::marker::Sized","std::result::Result"],"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion":["re_unicode::ReplacerRef","std::marker::Sized","std::option::Option"],"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append":["re_trait::Locations","re_unicode::Captures","re_unicode::ReplacerRef","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"<re_unicode::ReplacerRef<'a, R> as std::fmt::Debug>::fmt":["re_unicode::ReplacerRef","std::fmt::Formatter","std::marker::Sized","std::result::Result"],"<re_unicode::Split<'r, 't> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Split","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::Split<'r, 't> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Split","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::SplitN<'r, 't> as std::fmt::Debug>::fmt":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Split","re_unicode::SplitN","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::fmt::Formatter","std::marker::Send","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Split","re_unicode::SplitN","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Split","re_unicode::SplitN","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"<re_unicode::SubCaptureMatches<'c, 't> as std::clone::Clone>::clone":["re_trait::Locations","re_trait::SubCapturesPosIter","re_unicode::Captures","re_unicode::SubCaptureMatches","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_unicode::SubCaptureMatches<'c, 't> as std::fmt::Debug>::fmt":["re_trait::Locations","re_trait::SubCapturesPosIter","re_unicode::Captures","re_unicode::SubCaptureMatches","std::alloc::Allocator","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::sync::Arc","std::vec::Vec"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::count":["re_trait::Locations","re_trait::SubCapturesPosIter","re_unicode::Captures","re_unicode::SubCaptureMatches","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next":["re_trait::Locations","re_trait::SubCapturesPosIter","re_unicode::Captures","re_unicode::SubCaptureMatches","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::size_hint":["re_trait::Locations","re_trait::SubCapturesPosIter","re_unicode::Captures","re_unicode::SubCaptureMatches","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"<sparse::SparseSet as std::clone::Clone>::clone":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<sparse::SparseSet as std::fmt::Debug>::fmt":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::fmt::Formatter","std::marker::Sized","std::result::Result","std::vec::Vec"],"<sparse::SparseSet as std::ops::Deref>::deref":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"<std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion":["std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::option::Option"],"<std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"<std::string::String as re_unicode::Replacer>::no_expansion":["std::marker::Sized","std::option::Option","std::string::String"],"<std::string::String as re_unicode::Replacer>::replace_append":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"<std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion":["std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"<std::vec::Vec<u8> as re_bytes::Replacer>::replace_append":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"backtrack::Bounded":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::panic::AssertUnwindSafe","std::sync::Arc","std::vec::Vec"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::step":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"backtrack::Cache":["backtrack::Cache","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"backtrack::Cache::new":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Cache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"backtrack::Job":["backtrack::Job","input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"backtrack::should_exec":[],"backtrack::usize_to_u32":[],"compile::ByteClassSet":["compile::ByteClassSet"],"compile::ByteClassSet::byte_classes":["compile::ByteClassSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"compile::ByteClassSet::new":["compile::ByteClassSet"],"compile::ByteClassSet::set_range":["compile::ByteClassSet"],"compile::ByteClassSet::set_word_boundary":["compile::ByteClassSet"],"compile::CompileClass":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::CompileClass","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::ClassUnicodeRange","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::CompileClass::<'a, 'b>::c_utf8_seq":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::CompileClass","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::ClassUnicodeRange","regex_syntax::utf8::Utf8Sequence","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::CompileClass::<'a, 'b>::c_utf8_seq_":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::CompileClass","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","re_set::bytes::SetMatches","regex_syntax::hir::ClassUnicodeRange","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::CompileClass::<'a, 'b>::compile":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::CompileClass","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::ClassUnicodeRange","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::bytes":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_alternate":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_byte":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_capture":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_char":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_class":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::ClassUnicodeRange","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_class_bytes":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::ClassBytesRange","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_concat":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","re_set::bytes::SetMatches","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_dotstar":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_empty":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_empty_look":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::EmptyLook","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_literal":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_repeat":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Repetition","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_repeat_one_or_more":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_repeat_range":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_repeat_range_min_or_more":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_repeat_zero_or_more":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::c_repeat_zero_or_one":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::check_size":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::compile":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::compile_finish":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::compile_many":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::compile_one":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","regex_syntax::hir::Hir","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::dfa":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::fill":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::Hole","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::fill_split":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::Hole","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::fill_to_next":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::Hole","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::new":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::next_inst":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::Hole","compile::Patch","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::only_utf8":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::pop_split_hole":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::result::Result","std::sync::Arc","std::vec::Vec"],"compile::Compiler::push_compiled":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::push_hole":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::Hole","compile::InstHole","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::EmptyLook","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::push_split_hole":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::Hole","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::reverse":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Compiler::size_limit":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","compile::ByteClassSet","compile::Compiler","compile::SuffixCache","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"compile::Hole":["compile::Hole","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"compile::Hole::dup_one":["compile::Hole","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"compile::InstHole":["compile::InstHole","prog::EmptyLook","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"compile::InstHole::fill":["compile::InstHole","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::MaybeInst":["compile::InstHole","compile::MaybeInst","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::MaybeInst::fill":["compile::InstHole","compile::MaybeInst","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::MaybeInst::fill_split":["compile::InstHole","compile::MaybeInst","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::MaybeInst::half_fill_split_goto1":["compile::InstHole","compile::MaybeInst","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::MaybeInst::half_fill_split_goto2":["compile::InstHole","compile::MaybeInst","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::MaybeInst::unwrap":["compile::InstHole","compile::MaybeInst","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::Patch":["compile::Hole","compile::Patch","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"compile::SuffixCache":["compile::SuffixCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::SuffixCache::clear":["compile::SuffixCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::SuffixCache::get":["compile::SuffixCache","compile::SuffixCacheKey","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::vec::Vec"],"compile::SuffixCache::hash":["compile::SuffixCache","compile::SuffixCacheKey","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::SuffixCache::new":["compile::SuffixCache","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"compile::SuffixCacheEntry":["compile::SuffixCacheEntry","compile::SuffixCacheKey"],"compile::SuffixCacheKey":["compile::SuffixCacheKey"],"compile::u32_to_usize":[],"dfa::Byte":["dfa::Byte"],"dfa::Byte::as_byte":["dfa::Byte","std::marker::Sized","std::option::Option"],"dfa::Byte::byte":["dfa::Byte"],"dfa::Byte::eof":["dfa::Byte"],"dfa::Byte::is_ascii_word":["dfa::Byte"],"dfa::Byte::is_eof":["dfa::Byte"],"dfa::Cache":["dfa::Cache","dfa::CacheInner","dfa::StateMap","dfa::Transitions","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"dfa::Cache::new":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::Cache","dfa::CacheInner","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::CacheInner":["dfa::CacheInner","dfa::StateMap","dfa::Transitions","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"dfa::CacheInner::reset_size":["dfa::CacheInner","dfa::StateMap","dfa::Transitions","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"dfa::EmptyFlags":["dfa::EmptyFlags"],"dfa::Fsm":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::add_state":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::State","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::approximate_size":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::byte_class":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::Byte","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::cached_state":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateFlags","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::cached_state_key":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateFlags","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::clear_cache":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::clear_cache_and_save":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::continue_past_first_match":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::exec_at":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::Result","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::exec_at_reverse":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::Result","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::exec_byte":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::Byte","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::follow_epsilons":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::EmptyFlags","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::forward":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::Result","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::panic::AssertUnwindSafe","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::forward_many":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::Result","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::panic::AssertUnwindSafe","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::has_prefix":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::next_si":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::next_state":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::Byte","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::num_byte_classes":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::prefix_at":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::restore_state":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::State","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::reverse":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::Result","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::panic::AssertUnwindSafe","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::start_flags":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::EmptyFlags","dfa::Fsm","dfa::StateFlags","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::start_flags_reverse":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::EmptyFlags","dfa::Fsm","dfa::StateFlags","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::start_ptr":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::start_state":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::EmptyFlags","dfa::Fsm","dfa::StateFlags","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::state":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::State","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::Fsm::<'a>::u8_class":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","dfa::CacheInner","dfa::Fsm","dfa::StateMap","dfa::Transitions","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::InstPtrs":["dfa::InstPtrs"],"dfa::Result":["dfa::Result","std::marker::Sized"],"dfa::Result::<T>::is_match":["dfa::Result","std::marker::Sized"],"dfa::Result::<T>::map":["dfa::Result","std::marker::Sized","std::ops::FnMut"],"dfa::Result::<T>::set_non_match":["dfa::Result","std::marker::Sized"],"dfa::State":["dfa::State","std::alloc::Allocator","std::marker::Sized","std::sync::Arc"],"dfa::State::flags":["dfa::State","dfa::StateFlags","std::alloc::Allocator","std::marker::Sized","std::sync::Arc"],"dfa::State::inst_ptrs":["dfa::InstPtrs","dfa::State","std::alloc::Allocator","std::marker::Sized","std::sync::Arc"],"dfa::StateFlags":["dfa::StateFlags"],"dfa::StateFlags::has_empty":["dfa::StateFlags"],"dfa::StateFlags::is_match":["dfa::StateFlags"],"dfa::StateFlags::is_word":["dfa::StateFlags"],"dfa::StateFlags::set_empty":["dfa::StateFlags"],"dfa::StateFlags::set_match":["dfa::StateFlags"],"dfa::StateFlags::set_word":["dfa::StateFlags"],"dfa::StateMap":["dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"dfa::StateMap::clear":["dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"dfa::StateMap::get_ptr":["dfa::State","dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::StateMap::get_state":["dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::option::Option","std::vec::Vec"],"dfa::StateMap::insert":["dfa::State","dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"dfa::StateMap::is_empty":["dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"dfa::StateMap::len":["dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"dfa::StateMap::new":["dfa::StateMap","std::alloc::Allocator","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"dfa::Transitions":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::Transitions::add":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"dfa::Transitions::clear":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::Transitions::new":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::Transitions::next":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::Transitions::next_unchecked":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::Transitions::num_states":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::Transitions::set_next":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::Transitions::state_heap_size":["dfa::Transitions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::TransitionsRow":["dfa::TransitionsRow"],"dfa::can_exec":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"dfa::push_inst_ptr":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::read_vari32":[],"dfa::read_varu32":[],"dfa::show_state_ptr":["std::string::String"],"dfa::usize_to_u32":[],"dfa::vb":["std::string::String"],"dfa::write_vari32":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"dfa::write_varu32":["std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"error::Error":["error::Error","std::string::String"],"exec::Exec":["exec::Exec","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"exec::Exec::capture_name_idx":["exec::Exec","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"exec::Exec::capture_names":["exec::Exec","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"exec::Exec::into_byte_regex":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"exec::Exec::into_byte_regex_set":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"exec::Exec::into_regex":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"exec::Exec::into_regex_set":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"exec::Exec::regex_strings":["exec::Exec","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::string::String","std::sync::Arc"],"exec::Exec::searcher":["exec::Exec","exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::Exec::searcher_str":["exec::Exec","exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::Exec::static_captures_len":["exec::Exec","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"exec::ExecBuilder":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::automatic":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::bounded_backtracking":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::build":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"exec::ExecBuilder::build_aho_corasick":["exec::ExecBuilder","exec::Parsed","re_builder::RegexOptions","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::bytes":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::new":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::new_many":["exec::ExecBuilder","re_builder::RegexOptions","re_set::bytes::SetMatches","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::new_options":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::nfa":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::only_utf8":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecBuilder::parse":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::result::Result","std::vec::Vec"],"exec::ExecBuilder::unicode":["exec::ExecBuilder","re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"exec::ExecNoSync":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::capture_name_idx":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::captures_nfa":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::captures_nfa_type":["exec::ExecNoSync","exec::MatchNfaType","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::exec_backtrack":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::exec_nfa":["exec::ExecNoSync","exec::MatchNfaType","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::exec_pikevm":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::find_dfa_anchored_reverse":["dfa::Result","exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::find_dfa_forward":["dfa::Result","exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::find_dfa_reverse_suffix":["dfa::Result","exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::find_literals":["exec::ExecNoSync","exec::MatchLiteralType","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::find_nfa":["exec::ExecNoSync","exec::MatchNfaType","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::is_anchor_end_match":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::is_anchor_end_match::imp":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::ExecNoSync::<'c>::many_matches_at":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::match_nfa":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::match_nfa_type":["exec::ExecNoSync","exec::MatchNfaType","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::shortest_dfa":["dfa::Result","exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix":["dfa::Result","exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::shortest_nfa":["exec::ExecNoSync","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSync::<'c>::shortest_nfa_type":["exec::ExecNoSync","exec::MatchNfaType","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSyncStr":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecNoSyncStr::<'c>::capture_name_idx":["exec::ExecNoSync","exec::ExecNoSyncStr","pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"exec::ExecReadOnly":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::ExecReadOnly::choose_dfa_match_type":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::ExecReadOnly::choose_dfa_match_type::imp":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::ExecReadOnly::choose_literal_match_type":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::ExecReadOnly::choose_literal_match_type::imp":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::ExecReadOnly::choose_match_type":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::ExecReadOnly::new_pool":["std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"exec::ExecReadOnly::should_suffix_scan":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::MatchLiteralType":["exec::MatchLiteralType"],"exec::MatchNfaType":["exec::MatchNfaType"],"exec::MatchType":["exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType"],"exec::Parsed":["exec::Parsed","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"exec::ProgramCacheInner":["backtrack::Cache","dfa::Cache","dfa::CacheInner","dfa::StateMap","dfa::Transitions","exec::ProgramCacheInner","pikevm::Cache","pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::vec::Vec"],"exec::ProgramCacheInner::new":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Cache","dfa::Cache","dfa::CacheInner","dfa::StateMap","dfa::Transitions","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","exec::ProgramCacheInner","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pikevm::Cache","pikevm::Threads","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::collections::HashMap","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"exec::alternation_literals":["regex_syntax::hir::Hir","std::marker::Sized","std::option::Option"],"exec::literal_analysis":["regex_syntax::hir::Hir","regex_syntax::hir::literal::Seq"],"expand::CaptureRef":["expand::CaptureRef","expand::Ref"],"expand::Ref":["expand::Ref"],"expand::expand_bytes":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"expand::expand_str":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"expand::find_cap_ref":["std::marker::Sized","std::option::Option"],"expand::find_cap_ref_braced":["std::marker::Sized","std::option::Option"],"expand::is_valid_cap_letter":[],"find_byte::find_byte":["std::marker::Sized","std::option::Option"],"find_byte::find_byte::imp":["std::marker::Sized","std::option::Option"],"input::<impl std::cmp::PartialEq<input::Char> for char>::eq":["input::Char"],"input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp":["input::Char","std::marker::Sized","std::option::Option"],"input::ByteInput":["input::ByteInput"],"input::ByteInput::<'t>::new":["input::ByteInput"],"input::Char":["input::Char"],"input::Char::is_none":["input::Char"],"input::Char::is_word_byte":["input::Char"],"input::Char::is_word_char":["input::Char"],"input::Char::len_utf8":["input::Char"],"input::CharInput":["input::CharInput"],"input::CharInput::<'t>::new":["input::CharInput"],"input::Input::as_bytes":[],"input::Input::at":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::Input::is_empty":[],"input::Input::is_empty_match":["input::Char","input::InputAt","prog::EmptyLook","prog::InstEmptyLook","std::marker::Sized","std::option::Option"],"input::Input::len":[],"input::Input::next_char":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::Input::prefix_at":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"input::Input::previous_char":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt::byte":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt::char":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt::is_empty":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt::is_end":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt::is_start":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt::len":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt::next_pos":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"input::InputAt::pos":["input::Char","input::InputAt","std::marker::Sized","std::option::Option"],"literal::imp::LiteralIter":["literal::imp::LiteralIter","regex_syntax::hir::literal::Literal"],"literal::imp::LiteralSearcher":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::approximate_size":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::complete":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::empty":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::find":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"literal::imp::LiteralSearcher::find_end":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"literal::imp::LiteralSearcher::find_start":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"literal::imp::LiteralSearcher::is_empty":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::iter":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralIter","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","regex_syntax::hir::literal::Literal","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::lcp":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::lcs":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::len":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::new":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::prefixes":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::LiteralSearcher::suffixes":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::Matcher":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::Matcher::new":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::Matcher::prefixes":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::Matcher::suffixes":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::Memmem":["literal::imp::Memmem","memchr::memmem::Finder"],"literal::imp::Memmem::approximate_size":["literal::imp::Memmem","memchr::memmem::Finder"],"literal::imp::Memmem::char_len":["literal::imp::Memmem","memchr::memmem::Finder"],"literal::imp::Memmem::find":["literal::imp::Memmem","memchr::memmem::Finder","std::marker::Sized","std::option::Option"],"literal::imp::Memmem::is_suffix":["literal::imp::Memmem","memchr::memmem::Finder"],"literal::imp::Memmem::len":["literal::imp::Memmem","memchr::memmem::Finder"],"literal::imp::Memmem::new":["literal::imp::Memmem","memchr::memmem::Finder"],"literal::imp::SingleByteSet":["literal::imp::SingleByteSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::SingleByteSet::_find":["literal::imp::SingleByteSet","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"literal::imp::SingleByteSet::approximate_size":["literal::imp::SingleByteSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::SingleByteSet::find":["literal::imp::SingleByteSet","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"literal::imp::SingleByteSet::new":["literal::imp::SingleByteSet","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::SingleByteSet::prefixes":["literal::imp::SingleByteSet","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::SingleByteSet::suffixes":["literal::imp::SingleByteSet","regex_syntax::hir::literal::Seq","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"literal::imp::char_len_lossy":[],"pikevm::Cache":["pikevm::Cache","pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"pikevm::Cache::new":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pikevm::Cache","pikevm::Threads","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"pikevm::FollowEpsilon":["pikevm::FollowEpsilon","std::marker::Sized","std::option::Option"],"pikevm::Fsm":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pikevm::Fsm","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"pikevm::Fsm::<'r, I>::add":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pikevm::Fsm","pikevm::Threads","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"pikevm::Fsm::<'r, I>::add_step":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pikevm::Fsm","pikevm::Threads","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"pikevm::Fsm::<'r, I>::exec":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::panic::AssertUnwindSafe","std::sync::Arc","std::vec::Vec"],"pikevm::Fsm::<'r, I>::exec_":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pikevm::Fsm","pikevm::Threads","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"pikevm::Fsm::<'r, I>::step":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","input::Char","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pikevm::Fsm","pikevm::Threads","prog::Program","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"pikevm::Threads":["pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"pikevm::Threads::caps":["pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::vec::Vec"],"pikevm::Threads::new":["pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"pikevm::Threads::resize":["pikevm::Threads","sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"pool::Pool":["pool::Pool","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::Pool::<T>::get":["pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::Pool::<T>::get_slow":["pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::Pool::<T>::guard_owned":["pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::Pool::<T>::guard_stack":["pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::Pool::<T>::new":["pool::Pool","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::Pool::<T>::put":["pool::Pool","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::PoolGuard":["pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::PoolGuard::<'a, T>::value":["pool::Pool","pool::PoolGuard","std::alloc::Allocator","std::boxed::Box","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Mutex","std::sync::atomic::AtomicUsize"],"pool::THREAD_ID::__init":[],"prog::EmptyLook":["prog::EmptyLook"],"prog::Inst":["prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"prog::Inst::is_match":["prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"prog::InstBytes":["prog::InstBytes"],"prog::InstBytes::matches":["prog::InstBytes"],"prog::InstChar":["prog::InstChar"],"prog::InstEmptyLook":["prog::EmptyLook","prog::InstEmptyLook"],"prog::InstRanges":["prog::InstRanges","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"prog::InstRanges::matches":["input::Char","prog::InstRanges","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"prog::InstRanges::num_chars":["prog::InstRanges","std::alloc::Allocator","std::boxed::Box","std::marker::Sized"],"prog::InstSave":["prog::InstSave"],"prog::InstSplit":["prog::InstSplit"],"prog::Program":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"prog::Program::approximate_size":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"prog::Program::leads_to_match":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"prog::Program::needs_dotstar":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"prog::Program::new":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"prog::Program::only_utf8":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"prog::Program::skip":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"prog::Program::uses_bytes":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","prog::Program","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_builder::RegexOptions":["re_builder::RegexOptions","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::build":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"re_builder::bytes::RegexBuilder::case_insensitive":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::dfa_size_limit":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::dot_matches_new_line":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::ignore_whitespace":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::multi_line":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::nest_limit":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::new":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::octal":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::size_limit":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::swap_greed":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::bytes::RegexBuilder::unicode":["re_builder::RegexOptions","re_builder::bytes::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::build":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::case_insensitive":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::dfa_size_limit":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::ignore_whitespace":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::multi_line":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::nest_limit":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::new":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","re_set::bytes::SetMatches","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::octal":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::size_limit":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::swap_greed":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_bytes::RegexSetBuilder::unicode":["re_builder::RegexOptions","re_builder::set_bytes::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::build":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::case_insensitive":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::dfa_size_limit":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::ignore_whitespace":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::multi_line":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::nest_limit":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::new":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","re_set::bytes::SetMatches","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::octal":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::size_limit":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::swap_greed":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::set_unicode::RegexSetBuilder::unicode":["re_builder::RegexOptions","re_builder::set_unicode::RegexSetBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::build":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::result::Result","std::vec::Vec"],"re_builder::unicode::RegexBuilder::case_insensitive":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::dfa_size_limit":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::dot_matches_new_line":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::ignore_whitespace":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::multi_line":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::nest_limit":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::new":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::octal":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::size_limit":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::swap_greed":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_builder::unicode::RegexBuilder::unicode":["re_builder::RegexOptions","re_builder::unicode::RegexBuilder","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from":["re_bytes::Match","std::marker::Sized","std::ops::Range"],"re_bytes::CaptureLocations":["re_bytes::CaptureLocations","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_bytes::CaptureLocations::get":["re_bytes::CaptureLocations","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"re_bytes::CaptureLocations::len":["re_bytes::CaptureLocations","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_bytes::CaptureLocations::pos":["re_bytes::CaptureLocations","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"re_bytes::CaptureMatches":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::CaptureMatches","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_bytes::CaptureNames":["re_bytes::CaptureNames","std::marker::Sized","std::slice::Iter"],"re_bytes::Captures":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::Captures::<'t>::expand":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::Captures::<'t>::get":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_bytes::Captures::<'t>::iter":["re_bytes::Captures","re_bytes::SubCaptureMatches","re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::Captures::<'t>::len":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::Captures::<'t>::name":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_bytes::CapturesDebug":["re_bytes::Captures","re_bytes::CapturesDebug","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::Match":["re_bytes::Match"],"re_bytes::Match::<'t>::as_bytes":["re_bytes::Match"],"re_bytes::Match::<'t>::end":["re_bytes::Match"],"re_bytes::Match::<'t>::is_empty":["re_bytes::Match"],"re_bytes::Match::<'t>::len":["re_bytes::Match"],"re_bytes::Match::<'t>::new":["re_bytes::Match"],"re_bytes::Match::<'t>::range":["re_bytes::Match","std::marker::Sized","std::ops::Range"],"re_bytes::Match::<'t>::start":["re_bytes::Match"],"re_bytes::Matches":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_bytes::NoExpand":["re_bytes::NoExpand"],"re_bytes::Regex":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_bytes::Regex::as_str":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_bytes::Regex::capture_locations":["exec::Exec","re_bytes::CaptureLocations","re_bytes::Regex","re_trait::Locations","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::Regex::capture_names":["exec::Exec","re_bytes::CaptureNames","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::slice::Iter","std::sync::Arc"],"re_bytes::Regex::captures":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_bytes::Regex::captures_at":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_bytes::Regex::captures_iter":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::Exec","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::CaptureMatches","re_bytes::Regex","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_bytes::Regex::captures_len":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_bytes::Regex::captures_read":["exec::Exec","re_bytes::CaptureLocations","re_bytes::Regex","re_trait::Locations","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_bytes::Regex::captures_read_at":["exec::Exec","re_bytes::CaptureLocations","re_bytes::Regex","re_trait::Locations","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_bytes::Regex::find":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_bytes::Regex::find_at":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_bytes::Regex::find_iter":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::Exec","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Regex","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_bytes::Regex::is_match":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_bytes::Regex::is_match_at":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_bytes::Regex::locations":["exec::Exec","re_bytes::CaptureLocations","re_bytes::Regex","re_trait::Locations","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::Regex::new":["std::marker::Sized","std::result::Result"],"re_bytes::Regex::read_captures_at":["exec::Exec","re_bytes::CaptureLocations","re_bytes::Regex","re_trait::Locations","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_bytes::Regex::replace":["<F as re_bytes::Replacer>::F","exec::Exec","re_bytes::Regex","re_bytes::Replacer","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_bytes::Regex::replace_all":["<F as re_bytes::Replacer>::F","exec::Exec","re_bytes::Regex","re_bytes::Replacer","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_bytes::Regex::replacen":["<F as re_bytes::Replacer>::F","exec::Exec","re_bytes::Regex","re_bytes::Replacer","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_bytes::Regex::shortest_match":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_bytes::Regex::shortest_match_at":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_bytes::Regex::split":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::Exec","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Regex","re_bytes::Split","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_bytes::Regex::splitn":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::Exec","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Regex","re_bytes::Split","re_bytes::SplitN","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_bytes::Regex::static_captures_len":["exec::Exec","re_bytes::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_bytes::Replacer::by_ref":["re_bytes::ReplacerRef"],"re_bytes::Replacer::no_expansion":["std::marker::Sized","std::option::Option"],"re_bytes::Replacer::replace_append":["re_bytes::Captures","re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::ReplacerRef":["re_bytes::ReplacerRef"],"re_bytes::Split":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Split","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_bytes::SplitN":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_bytes::Matches","re_bytes::Split","re_bytes::SplitN","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_bytes::SubCaptureMatches":["re_bytes::Captures","re_bytes::SubCaptureMatches","re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_bytes::no_expansion":["std::convert::AsRef","std::marker::Sized","std::option::Option"],"re_set::bytes::RegexSet":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::bytes::RegexSet::empty":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::bytes::RegexSet::is_empty":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::bytes::RegexSet::is_match":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::bytes::RegexSet::is_match_at":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::bytes::RegexSet::len":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::bytes::RegexSet::matches":["exec::Exec","re_set::bytes::RegexSet","re_set::bytes::SetMatches","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_set::bytes::RegexSet::new":["re_set::bytes::SetMatches","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::result::Result","std::vec::Vec"],"re_set::bytes::RegexSet::patterns":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::string::String","std::sync::Arc"],"re_set::bytes::RegexSet::read_matches_at":["exec::Exec","re_set::bytes::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::bytes::SetMatches":["re_set::bytes::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_set::bytes::SetMatches::iter":["re_set::bytes::SetMatches","re_set::bytes::SetMatchesIter","std::alloc::Allocator","std::iter::Enumerate","std::marker::Sized","std::vec::Vec"],"re_set::bytes::SetMatches::len":["re_set::bytes::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_set::bytes::SetMatches::matched":["re_set::bytes::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_set::bytes::SetMatches::matched_any":["re_set::bytes::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_set::bytes::SetMatchesIntoIter":["re_set::bytes::SetMatchesIntoIter","std::iter::Enumerate","std::marker::Sized"],"re_set::bytes::SetMatchesIter":["re_set::bytes::SetMatchesIter","std::iter::Enumerate","std::marker::Sized"],"re_set::bytes::as_bytes_bytes":[],"re_set::bytes::as_bytes_str":[],"re_set::unicode::RegexSet":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::unicode::RegexSet::empty":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::unicode::RegexSet::is_empty":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::unicode::RegexSet::is_match":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::unicode::RegexSet::is_match_at":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::unicode::RegexSet::len":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::unicode::RegexSet::matches":["exec::Exec","re_set::unicode::RegexSet","re_set::unicode::SetMatches","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_set::unicode::RegexSet::new":["re_set::bytes::SetMatches","std::alloc::Allocator","std::convert::AsRef","std::iter::IntoIterator","std::marker::Sized","std::result::Result","std::vec::Vec"],"re_set::unicode::RegexSet::patterns":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::string::String","std::sync::Arc"],"re_set::unicode::RegexSet::read_matches_at":["exec::Exec","re_set::unicode::RegexSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_set::unicode::SetMatches":["re_set::unicode::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_set::unicode::SetMatches::iter":["re_set::unicode::SetMatches","re_set::unicode::SetMatchesIter","std::alloc::Allocator","std::iter::Enumerate","std::marker::Sized","std::vec::Vec"],"re_set::unicode::SetMatches::len":["re_set::unicode::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_set::unicode::SetMatches::matched":["re_set::unicode::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_set::unicode::SetMatches::matched_any":["re_set::unicode::SetMatches","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_set::unicode::SetMatchesIntoIter":["re_set::unicode::SetMatchesIntoIter","std::iter::Enumerate","std::marker::Sized"],"re_set::unicode::SetMatchesIter":["re_set::unicode::SetMatchesIter","std::iter::Enumerate","std::marker::Sized"],"re_set::unicode::as_bytes_bytes":[],"re_set::unicode::as_bytes_str":[],"re_trait::CaptureMatches":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_trait::CaptureMatches::<'t, R>::regex":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_trait::CaptureMatches::<'t, R>::text":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_trait::Locations":["re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_trait::Locations::as_slots":["re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"re_trait::Locations::iter":["re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_trait::Locations::len":["re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_trait::Locations::pos":["re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"re_trait::Matches":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_trait::Matches::<'t, R>::regex":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_trait::Matches::<'t, R>::text":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_trait::RegularExpression::captures_iter":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_trait::RegularExpression::captures_read_at":["re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"re_trait::RegularExpression::find_at":["std::marker::Sized","std::option::Option"],"re_trait::RegularExpression::find_iter":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_trait::RegularExpression::is_match_at":[],"re_trait::RegularExpression::locations":["re_trait::Locations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_trait::RegularExpression::next_after_empty":[],"re_trait::RegularExpression::shortest_match_at":["std::marker::Sized","std::option::Option"],"re_trait::RegularExpression::slots_len":[],"re_trait::SubCapturesPosIter":["re_trait::Locations","re_trait::SubCapturesPosIter","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from":["re_unicode::Match"],"re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from":["re_unicode::Match","std::marker::Sized","std::ops::Range"],"re_unicode::CaptureLocations":["re_trait::Locations","re_unicode::CaptureLocations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_unicode::CaptureLocations::get":["re_trait::Locations","re_unicode::CaptureLocations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"re_unicode::CaptureLocations::len":["re_trait::Locations","re_unicode::CaptureLocations","std::alloc::Allocator","std::marker::Sized","std::vec::Vec"],"re_unicode::CaptureLocations::pos":["re_trait::Locations","re_unicode::CaptureLocations","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::vec::Vec"],"re_unicode::CaptureMatches":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","re_unicode::CaptureMatches","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_unicode::CaptureNames":["re_unicode::CaptureNames","std::marker::Sized","std::slice::Iter"],"re_unicode::Captures":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_unicode::Captures::<'t>::expand":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"re_unicode::Captures::<'t>::get":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_unicode::Captures::<'t>::iter":["re_trait::Locations","re_trait::SubCapturesPosIter","re_unicode::Captures","re_unicode::SubCaptureMatches","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_unicode::Captures::<'t>::len":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_unicode::Captures::<'t>::name":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_unicode::CapturesDebug":["re_trait::Locations","re_unicode::Captures","re_unicode::CapturesDebug","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_unicode::Match":["re_unicode::Match"],"re_unicode::Match::<'t>::as_str":["re_unicode::Match"],"re_unicode::Match::<'t>::end":["re_unicode::Match"],"re_unicode::Match::<'t>::is_empty":["re_unicode::Match"],"re_unicode::Match::<'t>::len":["re_unicode::Match"],"re_unicode::Match::<'t>::new":["re_unicode::Match"],"re_unicode::Match::<'t>::range":["re_unicode::Match","std::marker::Sized","std::ops::Range"],"re_unicode::Match::<'t>::start":["re_unicode::Match"],"re_unicode::Matches":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_unicode::NoExpand":["re_unicode::NoExpand"],"re_unicode::Regex":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_unicode::Regex::as_str":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_unicode::Regex::capture_locations":["exec::Exec","re_trait::Locations","re_unicode::CaptureLocations","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_unicode::Regex::capture_names":["exec::Exec","re_unicode::CaptureNames","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::slice::Iter","std::sync::Arc"],"re_unicode::Regex::captures":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_unicode::Regex::captures_at":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_unicode::Regex::captures_iter":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::Exec","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::CaptureMatches","re_trait::Matches","re_trait::RegularExpression","re_unicode::CaptureMatches","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_unicode::Regex::captures_len":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_unicode::Regex::captures_read":["exec::Exec","re_trait::Locations","re_unicode::CaptureLocations","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_unicode::Regex::captures_read_at":["exec::Exec","re_trait::Locations","re_unicode::CaptureLocations","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_unicode::Regex::find":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_unicode::Regex::find_at":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_unicode::Regex::find_iter":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::Exec","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_unicode::Regex::is_match":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_unicode::Regex::is_match_at":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_unicode::Regex::locations":["exec::Exec","re_trait::Locations","re_unicode::CaptureLocations","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_unicode::Regex::new":["std::marker::Sized","std::result::Result"],"re_unicode::Regex::read_captures_at":["exec::Exec","re_trait::Locations","re_unicode::CaptureLocations","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc","std::vec::Vec"],"re_unicode::Regex::replace":["<F as re_unicode::Replacer>::F","exec::Exec","re_unicode::Regex","re_unicode::Replacer","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_unicode::Regex::replace_all":["<F as re_unicode::Replacer>::F","exec::Exec","re_unicode::Regex","re_unicode::Replacer","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_unicode::Regex::replacen":["<F as re_unicode::Replacer>::F","exec::Exec","re_unicode::Regex","re_unicode::Replacer","std::alloc::Allocator","std::borrow::Cow","std::borrow::ToOwned","std::boxed::Box","std::marker::Sized","std::sync::Arc"],"re_unicode::Regex::shortest_match":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_unicode::Regex::shortest_match_at":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_unicode::Regex::split":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::Exec","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Regex","re_unicode::Split","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_unicode::Regex::splitn":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::Exec","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Regex","re_unicode::Split","re_unicode::SplitN","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_unicode::Regex::static_captures_len":["exec::Exec","re_unicode::Regex","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::option::Option","std::sync::Arc"],"re_unicode::Replacer::by_ref":["re_unicode::ReplacerRef"],"re_unicode::Replacer::no_expansion":["std::marker::Sized","std::option::Option"],"re_unicode::Replacer::replace_append":["re_trait::Locations","re_unicode::Captures","std::alloc::Allocator","std::marker::Sized","std::string::String","std::sync::Arc","std::vec::Vec"],"re_unicode::ReplacerRef":["re_unicode::ReplacerRef"],"re_unicode::Split":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Split","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_unicode::SplitN":["aho_corasick::AhoCorasick","aho_corasick::packed::Searcher","backtrack::Bounded","backtrack::Cache","exec::ExecNoSync","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","memchr::memmem::Finder","pool::Pool","pool::PoolGuard","prog::Program","re_trait::Matches","re_trait::RegularExpression","re_unicode::Matches","re_unicode::Split","re_unicode::SplitN","std::alloc::Allocator","std::boxed::Box","std::fmt::Debug","std::marker::Send","std::marker::Sized","std::option::Option","std::sync::Arc","std::sync::Mutex","std::sync::atomic::AtomicUsize","std::vec::Vec"],"re_unicode::SubCaptureMatches":["re_trait::Locations","re_trait::SubCapturesPosIter","re_unicode::Captures","re_unicode::SubCaptureMatches","std::alloc::Allocator","std::marker::Sized","std::sync::Arc","std::vec::Vec"],"re_unicode::escape":["std::string::String"],"re_unicode::no_expansion":["std::convert::AsRef","std::marker::Sized","std::option::Option"],"sparse::SparseSet":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"sparse::SparseSet::capacity":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"sparse::SparseSet::clear":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"sparse::SparseSet::contains":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"sparse::SparseSet::insert":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"sparse::SparseSet::is_empty":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"sparse::SparseSet::len":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"sparse::SparseSet::new":["sparse::SparseSet","std::alloc::Allocator","std::boxed::Box","std::marker::Sized","std::vec::Vec"],"utf8::decode_last_utf8":["std::marker::Sized","std::option::Option"],"utf8::decode_utf8":["std::marker::Sized","std::option::Option"],"utf8::is_start_byte":[],"utf8::next_utf8":[]},"glob_path_import":{"literal::imp":"literal::","re_builder::bytes":"bytes::","re_builder::set_bytes":"bytes::","re_builder::set_unicode":"","re_builder::unicode":"","re_bytes":"bytes::","re_set::bytes":"bytes::","re_set::unicode":""},"self_to_fn":{"<F as re_bytes::Replacer>::F":["impl<F, T> Replacer for F\nwhere\n    F: FnMut(&Captures<'_>) -> T,\n    T: AsRef<[u8]>,\n{\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {\n        dst.extend_from_slice((*self)(caps).as_ref());\n    }\n}"],"<F as re_unicode::Replacer>::F":["impl<F, T> Replacer for F\nwhere\n    F: FnMut(&Captures<'_>) -> T,\n    T: AsRef<str>,\n{\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {\n        dst.push_str((*self)(caps).as_ref());\n    }\n}"],"backtrack::Bounded":["Debug","impl<'a, 'm, 'r, 's, I: Input> Bounded<'a, 'm, 'r, 's, I> {\n    /// Execute the backtracking matching engine.\n    ///\n    /// If there's a match, `exec` returns `true` and populates the given\n    /// captures accordingly.\n    pub fn exec(\n        prog: &'r Program,\n        cache: &ProgramCache,\n        matches: &'m mut [bool],\n        slots: &'s mut [Slot],\n        input: I,\n        start: usize,\n        end: usize,\n    ) -> bool {\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.backtrack;\n        let start = input.at(start);\n        let mut b = Bounded { prog, input, matches, slots, m: cache };\n        b.exec_(start, end)\n    }\n\n    /// Clears the cache such that the backtracking engine can be executed\n    /// on some input of fixed length.\n    fn clear(&mut self) {\n        // Reset the job memory so that we start fresh.\n        self.m.jobs.clear();\n\n        // Now we need to clear the bit state set.\n        // We do this by figuring out how much space we need to keep track\n        // of the states we've visited.\n        // Then we reset all existing allocated space to 0.\n        // Finally, we request more space if we need it.\n        //\n        // This is all a little circuitous, but doing this using unchecked\n        // operations doesn't seem to have a measurable impact on performance.\n        // (Probably because backtracking is limited to such small\n        // inputs/regexes in the first place.)\n        let visited_len =\n            (self.prog.len() * (self.input.len() + 1) + BIT_SIZE - 1)\n                / BIT_SIZE;\n        self.m.visited.truncate(visited_len);\n        for v in &mut self.m.visited {\n            *v = 0;\n        }\n        if visited_len > self.m.visited.len() {\n            let len = self.m.visited.len();\n            self.m.visited.reserve_exact(visited_len - len);\n            for _ in 0..(visited_len - len) {\n                self.m.visited.push(0);\n            }\n        }\n    }\n\n    /// Start backtracking at the given position in the input, but also look\n    /// for literal prefixes.\n    fn exec_(&mut self, mut at: InputAt, end: usize) -> bool {\n        self.clear();\n        // If this is an anchored regex at the beginning of the input, then\n        // we're either already done or we only need to try backtracking once.\n        if self.prog.is_anchored_start {\n            return if !at.is_start() { false } else { self.backtrack(at) };\n        }\n        let mut matched = false;\n        loop {\n            if !self.prog.prefixes.is_empty() {\n                at = match self.input.prefix_at(&self.prog.prefixes, at) {\n                    None => break,\n                    Some(at) => at,\n                };\n            }\n            matched = self.backtrack(at) || matched;\n            if matched && self.prog.matches.len() == 1 {\n                return true;\n            }\n            if at.pos() >= end {\n                break;\n            }\n            at = self.input.at(at.next_pos());\n        }\n        matched\n    }\n\n    /// The main backtracking loop starting at the given input position.\n    fn backtrack(&mut self, start: InputAt) -> bool {\n        // N.B. We use an explicit stack to avoid recursion.\n        // To avoid excessive pushing and popping, most transitions are handled\n        // in the `step` helper function, which only pushes to the stack when\n        // there's a capture or a branch.\n        let mut matched = false;\n        self.m.jobs.push(Job::Inst { ip: 0, at: start });\n        while let Some(job) = self.m.jobs.pop() {\n            match job {\n                Job::Inst { ip, at } => {\n                    if self.step(ip, at) {\n                        // Only quit if we're matching one regex.\n                        // If we're matching a regex set, then mush on and\n                        // try to find other matches (if we want them).\n                        if self.prog.matches.len() == 1 {\n                            return true;\n                        }\n                        matched = true;\n                    }\n                }\n                Job::SaveRestore { slot, old_pos } => {\n                    if slot < self.slots.len() {\n                        self.slots[slot] = old_pos;\n                    }\n                }\n            }\n        }\n        matched\n    }\n\n    fn step(&mut self, mut ip: InstPtr, mut at: InputAt) -> bool {\n        use crate::prog::Inst::*;\n        loop {\n            // This loop is an optimization to avoid constantly pushing/popping\n            // from the stack. Namely, if we're pushing a job only to run it\n            // next, avoid the push and just mutate `ip` (and possibly `at`)\n            // in place.\n            if self.has_visited(ip, at) {\n                return false;\n            }\n            match self.prog[ip] {\n                Match(slot) => {\n                    if slot < self.matches.len() {\n                        self.matches[slot] = true;\n                    }\n                    return true;\n                }\n                Save(ref inst) => {\n                    if let Some(&old_pos) = self.slots.get(inst.slot) {\n                        // If this path doesn't work out, then we save the old\n                        // capture index (if one exists) in an alternate\n                        // job. If the next path fails, then the alternate\n                        // job is popped and the old capture index is restored.\n                        self.m.jobs.push(Job::SaveRestore {\n                            slot: inst.slot,\n                            old_pos,\n                        });\n                        self.slots[inst.slot] = Some(at.pos());\n                    }\n                    ip = inst.goto;\n                }\n                Split(ref inst) => {\n                    self.m.jobs.push(Job::Inst { ip: inst.goto2, at });\n                    ip = inst.goto1;\n                }\n                EmptyLook(ref inst) => {\n                    if self.input.is_empty_match(at, inst) {\n                        ip = inst.goto;\n                    } else {\n                        return false;\n                    }\n                }\n                Char(ref inst) => {\n                    if inst.c == at.char() {\n                        ip = inst.goto;\n                        at = self.input.at(at.next_pos());\n                    } else {\n                        return false;\n                    }\n                }\n                Ranges(ref inst) => {\n                    if inst.matches(at.char()) {\n                        ip = inst.goto;\n                        at = self.input.at(at.next_pos());\n                    } else {\n                        return false;\n                    }\n                }\n                Bytes(ref inst) => {\n                    if let Some(b) = at.byte() {\n                        if inst.matches(b) {\n                            ip = inst.goto;\n                            at = self.input.at(at.next_pos());\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n    }\n\n    fn has_visited(&mut self, ip: InstPtr, at: InputAt) -> bool {\n        let k = ip * (self.input.len() + 1) + at.pos();\n        let k1 = k / BIT_SIZE;\n        let k2 = usize_to_u32(1 << (k & (BIT_SIZE - 1)));\n        if self.m.visited[k1] & k2 == 0 {\n            self.m.visited[k1] |= k2;\n            false\n        } else {\n            true\n        }\n    }\n}"],"backtrack::Cache":["Clone","Debug","impl Cache {\n    /// Create new empty cache for the backtracking engine.\n    pub fn new(_prog: &Program) -> Self {\n        Cache { jobs: vec![], visited: vec![] }\n    }\n}"],"backtrack::Job":["Clone","Copy","Debug"],"compile::ByteClassSet":["impl ByteClassSet {\n    fn new() -> Self {\n        ByteClassSet([false; 256])\n    }\n\n    fn set_range(&mut self, start: u8, end: u8) {\n        debug_assert!(start <= end);\n        if start > 0 {\n            self.0[start as usize - 1] = true;\n        }\n        self.0[end as usize] = true;\n    }\n\n    fn set_word_boundary(&mut self) {\n        // We need to mark all ranges of bytes whose pairs result in\n        // evaluating \\b differently.\n        let iswb = is_word_byte;\n        let mut b1: u16 = 0;\n        let mut b2: u16;\n        while b1 <= 255 {\n            b2 = b1 + 1;\n            while b2 <= 255 && iswb(b1 as u8) == iswb(b2 as u8) {\n                b2 += 1;\n            }\n            self.set_range(b1 as u8, (b2 - 1) as u8);\n            b1 = b2;\n        }\n    }\n\n    fn byte_classes(&self) -> Vec<u8> {\n        // N.B. If you're debugging the DFA, it's useful to simply return\n        // `(0..256).collect()`, which effectively removes the byte classes\n        // and makes the transitions easier to read.\n        // (0usize..256).map(|x| x as u8).collect()\n        let mut byte_classes = vec![0; 256];\n        let mut class = 0u8;\n        let mut i = 0;\n        loop {\n            byte_classes[i] = class as u8;\n            if i >= 255 {\n                break;\n            }\n            if self.0[i] {\n                class = class.checked_add(1).unwrap();\n            }\n            i += 1;\n        }\n        byte_classes\n    }\n}","impl fmt::Debug for ByteClassSet {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"ByteClassSet\").field(&&self.0[..]).finish()\n    }\n}"],"compile::CompileClass":["impl<'a, 'b> CompileClass<'a, 'b> {\n    fn compile(mut self) -> Result {\n        let mut holes = vec![];\n        let mut initial_entry = None;\n        let mut last_split = Hole::None;\n        let mut utf8_seqs = self.c.utf8_seqs.take().unwrap();\n        self.c.suffix_cache.clear();\n\n        for (i, range) in self.ranges.iter().enumerate() {\n            let is_last_range = i + 1 == self.ranges.len();\n            utf8_seqs.reset(range.start(), range.end());\n            let mut it = (&mut utf8_seqs).peekable();\n            loop {\n                let utf8_seq = match it.next() {\n                    None => break,\n                    Some(utf8_seq) => utf8_seq,\n                };\n                if is_last_range && it.peek().is_none() {\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    self.c.fill(last_split, entry);\n                    last_split = Hole::None;\n                    if initial_entry.is_none() {\n                        initial_entry = Some(entry);\n                    }\n                } else {\n                    if initial_entry.is_none() {\n                        initial_entry = Some(self.c.insts.len());\n                    }\n                    self.c.fill_to_next(last_split);\n                    last_split = self.c.push_split_hole();\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    last_split =\n                        self.c.fill_split(last_split, Some(entry), None);\n                }\n            }\n        }\n        self.c.utf8_seqs = Some(utf8_seqs);\n        Ok(Patch { hole: Hole::Many(holes), entry: initial_entry.unwrap() })\n    }\n\n    fn c_utf8_seq(&mut self, seq: &Utf8Sequence) -> Result {\n        if self.c.compiled.is_reverse {\n            self.c_utf8_seq_(seq)\n        } else {\n            self.c_utf8_seq_(seq.into_iter().rev())\n        }\n    }\n\n    fn c_utf8_seq_<'r, I>(&mut self, seq: I) -> Result\n    where\n        I: IntoIterator<Item = &'r Utf8Range>,\n    {\n        // The initial instruction for each UTF-8 sequence should be the same.\n        let mut from_inst = ::std::usize::MAX;\n        let mut last_hole = Hole::None;\n        for byte_range in seq {\n            let key = SuffixCacheKey {\n                from_inst,\n                start: byte_range.start,\n                end: byte_range.end,\n            };\n            {\n                let pc = self.c.insts.len();\n                if let Some(cached_pc) = self.c.suffix_cache.get(key, pc) {\n                    from_inst = cached_pc;\n                    continue;\n                }\n            }\n            self.c.byte_classes.set_range(byte_range.start, byte_range.end);\n            if from_inst == ::std::usize::MAX {\n                last_hole = self.c.push_hole(InstHole::Bytes {\n                    start: byte_range.start,\n                    end: byte_range.end,\n                });\n            } else {\n                self.c.push_compiled(Inst::Bytes(InstBytes {\n                    goto: from_inst,\n                    start: byte_range.start,\n                    end: byte_range.end,\n                }));\n            }\n            from_inst = self.c.insts.len().checked_sub(1).unwrap();\n            debug_assert!(from_inst < ::std::usize::MAX);\n        }\n        debug_assert!(from_inst < ::std::usize::MAX);\n        Ok(Patch { hole: last_hole, entry: from_inst })\n    }\n}"],"compile::Compiler":["impl Compiler {\n    /// Create a new regular expression compiler.\n    ///\n    /// Various options can be set before calling `compile` on an expression.\n    pub fn new() -> Self {\n        Compiler {\n            insts: vec![],\n            compiled: Program::new(),\n            capture_name_idx: HashMap::new(),\n            num_exprs: 0,\n            size_limit: 10 * (1 << 20),\n            suffix_cache: SuffixCache::new(1000),\n            utf8_seqs: Some(Utf8Sequences::new('\\x00', '\\x00')),\n            byte_classes: ByteClassSet::new(),\n            extra_inst_bytes: 0,\n        }\n    }\n\n    /// The size of the resulting program is limited by size_limit. If\n    /// the program approximately exceeds the given size (in bytes), then\n    /// compilation will stop and return an error.\n    pub fn size_limit(mut self, size_limit: usize) -> Self {\n        self.size_limit = size_limit;\n        self\n    }\n\n    /// If bytes is true, then the program is compiled as a byte based\n    /// automaton, which incorporates UTF-8 decoding into the machine. If it's\n    /// false, then the automaton is Unicode scalar value based, e.g., an\n    /// engine utilizing such an automaton is responsible for UTF-8 decoding.\n    ///\n    /// The specific invariant is that when returning a byte based machine,\n    /// the neither the `Char` nor `Ranges` instructions are produced.\n    /// Conversely, when producing a Unicode scalar value machine, the `Bytes`\n    /// instruction is never produced.\n    ///\n    /// Note that `dfa(true)` implies `bytes(true)`.\n    pub fn bytes(mut self, yes: bool) -> Self {\n        self.compiled.is_bytes = yes;\n        self\n    }\n\n    /// When disabled, the program compiled may match arbitrary bytes.\n    ///\n    /// When enabled (the default), all compiled programs exclusively match\n    /// valid UTF-8 bytes.\n    pub fn only_utf8(mut self, yes: bool) -> Self {\n        self.compiled.only_utf8 = yes;\n        self\n    }\n\n    /// When set, the machine returned is suitable for use in the DFA matching\n    /// engine.\n    ///\n    /// In particular, this ensures that if the regex is not anchored in the\n    /// beginning, then a preceding `.*?` is included in the program. (The NFA\n    /// based engines handle the preceding `.*?` explicitly, which is difficult\n    /// or impossible in the DFA engine.)\n    pub fn dfa(mut self, yes: bool) -> Self {\n        self.compiled.is_dfa = yes;\n        self\n    }\n\n    /// When set, the machine returned is suitable for matching text in\n    /// reverse. In particular, all concatenations are flipped.\n    pub fn reverse(mut self, yes: bool) -> Self {\n        self.compiled.is_reverse = yes;\n        self\n    }\n\n    /// Compile a regular expression given its AST.\n    ///\n    /// The compiler is guaranteed to succeed unless the program exceeds the\n    /// specified size limit. If the size limit is exceeded, then compilation\n    /// stops and returns an error.\n    pub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error> {\n        debug_assert!(!exprs.is_empty());\n        self.num_exprs = exprs.len();\n        if exprs.len() == 1 {\n            self.compile_one(&exprs[0])\n        } else {\n            self.compile_many(exprs)\n        }\n    }\n\n    fn compile_one(mut self, expr: &Hir) -> result::Result<Program, Error> {\n        if self.compiled.only_utf8\n            && expr.properties().look_set().contains(Look::WordAsciiNegate)\n        {\n            return Err(Error::Syntax(\n                \"ASCII-only \\\\B is not allowed in Unicode regexes \\\n                 because it may result in invalid UTF-8 matches\"\n                    .to_string(),\n            ));\n        }\n        // If we're compiling a forward DFA and we aren't anchored, then\n        // add a `.*?` before the first capture group.\n        // Other matching engines handle this by baking the logic into the\n        // matching engine itself.\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        self.compiled.is_anchored_start =\n            expr.properties().look_set_prefix().contains(Look::Start);\n        self.compiled.is_anchored_end =\n            expr.properties().look_set_suffix().contains(Look::End);\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        }\n        self.compiled.captures = vec![None];\n        let patch =\n            self.c_capture(0, expr)?.unwrap_or_else(|| self.next_inst());\n        if self.compiled.needs_dotstar() {\n            self.fill(dotstar_patch.hole, patch.entry);\n        } else {\n            self.compiled.start = patch.entry;\n        }\n        self.fill_to_next(patch.hole);\n        self.compiled.matches = vec![self.insts.len()];\n        self.push_compiled(Inst::Match(0));\n        self.compiled.static_captures_len =\n            expr.properties().static_explicit_captures_len();\n        self.compile_finish()\n    }\n\n    fn compile_many(\n        mut self,\n        exprs: &[Hir],\n    ) -> result::Result<Program, Error> {\n        debug_assert!(exprs.len() > 1);\n\n        self.compiled.is_anchored_start = exprs\n            .iter()\n            .all(|e| e.properties().look_set_prefix().contains(Look::Start));\n        self.compiled.is_anchored_end = exprs\n            .iter()\n            .all(|e| e.properties().look_set_suffix().contains(Look::End));\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        } else {\n            self.compiled.start = 0; // first instruction is always split\n        }\n        self.fill_to_next(dotstar_patch.hole);\n\n        let mut prev_hole = Hole::None;\n        for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } =\n                self.c_capture(0, expr)?.unwrap_or_else(|| self.next_inst());\n            self.fill_to_next(hole);\n            self.compiled.matches.push(self.insts.len());\n            self.push_compiled(Inst::Match(i));\n            prev_hole = self.fill_split(split, Some(entry), None);\n        }\n        let i = exprs.len() - 1;\n        let Patch { hole, entry } =\n            self.c_capture(0, &exprs[i])?.unwrap_or_else(|| self.next_inst());\n        self.fill(prev_hole, entry);\n        self.fill_to_next(hole);\n        self.compiled.matches.push(self.insts.len());\n        self.push_compiled(Inst::Match(i));\n        self.compile_finish()\n    }\n\n    fn compile_finish(mut self) -> result::Result<Program, Error> {\n        self.compiled.insts =\n            self.insts.into_iter().map(|inst| inst.unwrap()).collect();\n        self.compiled.byte_classes = self.byte_classes.byte_classes();\n        self.compiled.capture_name_idx = Arc::new(self.capture_name_idx);\n        Ok(self.compiled)\n    }\n\n    /// Compile expr into self.insts, returning a patch on success,\n    /// or an error if we run out of memory.\n    ///\n    /// All of the c_* methods of the compiler share the contract outlined\n    /// here.\n    ///\n    /// The main thing that a c_* method does is mutate `self.insts`\n    /// to add a list of mostly compiled instructions required to execute\n    /// the given expression. `self.insts` contains MaybeInsts rather than\n    /// Insts because there is some backpatching required.\n    ///\n    /// The `Patch` value returned by each c_* method provides metadata\n    /// about the compiled instructions emitted to `self.insts`. The\n    /// `entry` member of the patch refers to the first instruction\n    /// (the entry point), while the `hole` member contains zero or\n    /// more offsets to partial instructions that need to be backpatched.\n    /// The c_* routine can't know where its list of instructions are going to\n    /// jump to after execution, so it is up to the caller to patch\n    /// these jumps to point to the right place. So compiling some\n    /// expression, e, we would end up with a situation that looked like:\n    ///\n    /// ```text\n    /// self.insts = [ ..., i1, i2, ..., iexit1, ..., iexitn, ...]\n    ///                     ^              ^             ^\n    ///                     |                \\         /\n    ///                   entry                \\     /\n    ///                                         hole\n    /// ```\n    ///\n    /// To compile two expressions, e1 and e2, concatenated together we\n    /// would do:\n    ///\n    /// ```ignore\n    /// let patch1 = self.c(e1);\n    /// let patch2 = self.c(e2);\n    /// ```\n    ///\n    /// while leaves us with a situation that looks like\n    ///\n    /// ```text\n    /// self.insts = [ ..., i1, ..., iexit1, ..., i2, ..., iexit2 ]\n    ///                     ^        ^            ^        ^\n    ///                     |        |            |        |\n    ///                entry1        hole1   entry2        hole2\n    /// ```\n    ///\n    /// Then to merge the two patches together into one we would backpatch\n    /// hole1 with entry2 and return a new patch that enters at entry1\n    /// and has hole2 for a hole. In fact, if you look at the c_concat\n    /// method you will see that it does exactly this, though it handles\n    /// a list of expressions rather than just the two that we use for\n    /// an example.\n    ///\n    /// Ok(None) is returned when an expression is compiled to no\n    /// instruction, and so no patch.entry value makes sense.\n    fn c(&mut self, expr: &Hir) -> ResultOrEmpty {\n        use crate::prog;\n        use regex_syntax::hir::HirKind::*;\n\n        self.check_size()?;\n        match *expr.kind() {\n            Empty => self.c_empty(),\n            Literal(hir::Literal(ref bytes)) => {\n                if self.compiled.is_reverse {\n                    let mut bytes = bytes.to_vec();\n                    bytes.reverse();\n                    self.c_literal(&bytes)\n                } else {\n                    self.c_literal(bytes)\n                }\n            }\n            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),\n            Class(hir::Class::Bytes(ref cls)) => {\n                if self.compiled.uses_bytes() {\n                    self.c_class_bytes(cls.ranges())\n                } else {\n                    assert!(cls.is_ascii());\n                    let mut char_ranges = vec![];\n                    for r in cls.iter() {\n                        let (s, e) = (r.start() as char, r.end() as char);\n                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.c_class(&char_ranges)\n                }\n            }\n            Look(ref look) => match *look {\n                hir::Look::Start if self.compiled.is_reverse => {\n                    self.c_empty_look(prog::EmptyLook::EndText)\n                }\n                hir::Look::Start => {\n                    self.c_empty_look(prog::EmptyLook::StartText)\n                }\n                hir::Look::End if self.compiled.is_reverse => {\n                    self.c_empty_look(prog::EmptyLook::StartText)\n                }\n                hir::Look::End => self.c_empty_look(prog::EmptyLook::EndText),\n                hir::Look::StartLF if self.compiled.is_reverse => {\n                    self.byte_classes.set_range(b'\\n', b'\\n');\n                    self.c_empty_look(prog::EmptyLook::EndLine)\n                }\n                hir::Look::StartLF => {\n                    self.byte_classes.set_range(b'\\n', b'\\n');\n                    self.c_empty_look(prog::EmptyLook::StartLine)\n                }\n                hir::Look::EndLF if self.compiled.is_reverse => {\n                    self.byte_classes.set_range(b'\\n', b'\\n');\n                    self.c_empty_look(prog::EmptyLook::StartLine)\n                }\n                hir::Look::EndLF => {\n                    self.byte_classes.set_range(b'\\n', b'\\n');\n                    self.c_empty_look(prog::EmptyLook::EndLine)\n                }\n                hir::Look::StartCRLF | hir::Look::EndCRLF => {\n                    return Err(Error::Syntax(\n                        \"CRLF-aware line anchors are not supported yet\"\n                            .to_string(),\n                    ));\n                }\n                hir::Look::WordAscii => {\n                    self.byte_classes.set_word_boundary();\n                    self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n                }\n                hir::Look::WordAsciiNegate => {\n                    self.byte_classes.set_word_boundary();\n                    self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n                }\n                hir::Look::WordUnicode => {\n                    if !cfg!(feature = \"unicode-perl\") {\n                        return Err(Error::Syntax(\n                            \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                                .to_string(),\n                        ));\n                    }\n                    self.compiled.has_unicode_word_boundary = true;\n                    self.byte_classes.set_word_boundary();\n                    // We also make sure that all ASCII bytes are in a different\n                    // class from non-ASCII bytes. Otherwise, it's possible for\n                    // ASCII bytes to get lumped into the same class as non-ASCII\n                    // bytes. This in turn may cause the lazy DFA to falsely start\n                    // when it sees an ASCII byte that maps to a byte class with\n                    // non-ASCII bytes. This ensures that never happens.\n                    self.byte_classes.set_range(0, 0x7F);\n                    self.c_empty_look(prog::EmptyLook::WordBoundary)\n                }\n                hir::Look::WordUnicodeNegate => {\n                    if !cfg!(feature = \"unicode-perl\") {\n                        return Err(Error::Syntax(\n                            \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                                .to_string(),\n                        ));\n                    }\n                    self.compiled.has_unicode_word_boundary = true;\n                    self.byte_classes.set_word_boundary();\n                    // See comments above for why we set the ASCII range here.\n                    self.byte_classes.set_range(0, 0x7F);\n                    self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n                }\n            },\n            Capture(hir::Capture { index, ref name, ref sub }) => {\n                if index as usize >= self.compiled.captures.len() {\n                    let name = match *name {\n                        None => None,\n                        Some(ref boxed_str) => Some(boxed_str.to_string()),\n                    };\n                    self.compiled.captures.push(name.clone());\n                    if let Some(name) = name {\n                        self.capture_name_idx.insert(name, index as usize);\n                    }\n                }\n                self.c_capture(2 * index as usize, sub)\n            }\n            Concat(ref es) => {\n                if self.compiled.is_reverse {\n                    self.c_concat(es.iter().rev())\n                } else {\n                    self.c_concat(es)\n                }\n            }\n            Alternation(ref es) => self.c_alternate(&**es),\n            Repetition(ref rep) => self.c_repeat(rep),\n        }\n    }\n\n    fn c_empty(&mut self) -> ResultOrEmpty {\n        // See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8\n        // See: CVE-2022-24713\n        //\n        // Since 'empty' sub-expressions don't increase the size of\n        // the actual compiled object, we \"fake\" an increase in its\n        // size so that our 'check_size_limit' routine will eventually\n        // stop compilation if there are too many empty sub-expressions\n        // (e.g., via a large repetition).\n        self.extra_inst_bytes += std::mem::size_of::<Inst>();\n        Ok(None)\n    }\n\n    fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty {\n        if self.num_exprs > 1 || self.compiled.is_dfa {\n            // Don't ever compile Save instructions for regex sets because\n            // they are never used. They are also never used in DFA programs\n            // because DFAs can't handle captures.\n            self.c(expr)\n        } else {\n            let entry = self.insts.len();\n            let hole = self.push_hole(InstHole::Save { slot: first_slot });\n            let patch = self.c(expr)?.unwrap_or_else(|| self.next_inst());\n            self.fill(hole, patch.entry);\n            self.fill_to_next(patch.hole);\n            let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });\n            Ok(Some(Patch { hole, entry }))\n        }\n    }\n\n    fn c_dotstar(&mut self) -> Result {\n        let hir = if self.compiled.only_utf8() {\n            Hir::dot(hir::Dot::AnyChar)\n        } else {\n            Hir::dot(hir::Dot::AnyByte)\n        };\n        Ok(self\n            .c(&Hir::repetition(hir::Repetition {\n                min: 0,\n                max: None,\n                greedy: false,\n                sub: Box::new(hir),\n            }))?\n            .unwrap())\n    }\n\n    fn c_char(&mut self, c: char) -> ResultOrEmpty {\n        if self.compiled.uses_bytes() {\n            if c.is_ascii() {\n                let b = c as u8;\n                let hole =\n                    self.push_hole(InstHole::Bytes { start: b, end: b });\n                self.byte_classes.set_range(b, b);\n                Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n            } else {\n                self.c_class(&[hir::ClassUnicodeRange::new(c, c)])\n            }\n        } else {\n            let hole = self.push_hole(InstHole::Char { c });\n            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n        }\n    }\n\n    fn c_class(&mut self, ranges: &[hir::ClassUnicodeRange]) -> ResultOrEmpty {\n        use std::mem::size_of;\n\n        if ranges.is_empty() {\n            return Err(Error::Syntax(\n                \"empty character classes are not allowed\".to_string(),\n            ));\n        }\n        if self.compiled.uses_bytes() {\n            Ok(Some(CompileClass { c: self, ranges }.compile()?))\n        } else {\n            let ranges: Vec<(char, char)> =\n                ranges.iter().map(|r| (r.start(), r.end())).collect();\n            let hole = if ranges.len() == 1 && ranges[0].0 == ranges[0].1 {\n                self.push_hole(InstHole::Char { c: ranges[0].0 })\n            } else {\n                self.extra_inst_bytes +=\n                    ranges.len() * (size_of::<char>() * 2);\n                self.push_hole(InstHole::Ranges { ranges })\n            };\n            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n        }\n    }\n\n    fn c_byte(&mut self, b: u8) -> ResultOrEmpty {\n        self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])\n    }\n\n    fn c_class_bytes(\n        &mut self,\n        ranges: &[hir::ClassBytesRange],\n    ) -> ResultOrEmpty {\n        if ranges.is_empty() {\n            return Err(Error::Syntax(\n                \"empty character classes are not allowed\".to_string(),\n            ));\n        }\n\n        let first_split_entry = self.insts.len();\n        let mut holes = vec![];\n        let mut prev_hole = Hole::None;\n        for r in &ranges[0..ranges.len() - 1] {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let next = self.insts.len();\n            self.byte_classes.set_range(r.start(), r.end());\n            holes.push(self.push_hole(InstHole::Bytes {\n                start: r.start(),\n                end: r.end(),\n            }));\n            prev_hole = self.fill_split(split, Some(next), None);\n        }\n        let next = self.insts.len();\n        let r = &ranges[ranges.len() - 1];\n        self.byte_classes.set_range(r.start(), r.end());\n        holes.push(\n            self.push_hole(InstHole::Bytes { start: r.start(), end: r.end() }),\n        );\n        self.fill(prev_hole, next);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }\n\n    fn c_empty_look(&mut self, look: EmptyLook) -> ResultOrEmpty {\n        let hole = self.push_hole(InstHole::EmptyLook { look });\n        Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n    }\n\n    fn c_literal(&mut self, bytes: &[u8]) -> ResultOrEmpty {\n        match core::str::from_utf8(bytes) {\n            Ok(string) => {\n                let mut it = string.chars();\n                let Patch { mut hole, entry } = loop {\n                    match it.next() {\n                        None => return self.c_empty(),\n                        Some(ch) => {\n                            if let Some(p) = self.c_char(ch)? {\n                                break p;\n                            }\n                        }\n                    }\n                };\n                for ch in it {\n                    if let Some(p) = self.c_char(ch)? {\n                        self.fill(hole, p.entry);\n                        hole = p.hole;\n                    }\n                }\n                Ok(Some(Patch { hole, entry }))\n            }\n            Err(_) => {\n                assert!(self.compiled.uses_bytes());\n                let mut it = bytes.iter().copied();\n                let Patch { mut hole, entry } = loop {\n                    match it.next() {\n                        None => return self.c_empty(),\n                        Some(byte) => {\n                            if let Some(p) = self.c_byte(byte)? {\n                                break p;\n                            }\n                        }\n                    }\n                };\n                for byte in it {\n                    if let Some(p) = self.c_byte(byte)? {\n                        self.fill(hole, p.entry);\n                        hole = p.hole;\n                    }\n                }\n                Ok(Some(Patch { hole, entry }))\n            }\n        }\n    }\n\n    fn c_concat<'a, I>(&mut self, exprs: I) -> ResultOrEmpty\n    where\n        I: IntoIterator<Item = &'a Hir>,\n    {\n        let mut exprs = exprs.into_iter();\n        let Patch { mut hole, entry } = loop {\n            match exprs.next() {\n                None => return self.c_empty(),\n                Some(e) => {\n                    if let Some(p) = self.c(e)? {\n                        break p;\n                    }\n                }\n            }\n        };\n        for e in exprs {\n            if let Some(p) = self.c(e)? {\n                self.fill(hole, p.entry);\n                hole = p.hole;\n            }\n        }\n        Ok(Some(Patch { hole, entry }))\n    }\n\n    fn c_alternate(&mut self, exprs: &[Hir]) -> ResultOrEmpty {\n        debug_assert!(\n            exprs.len() >= 2,\n            \"alternates must have at least 2 exprs\"\n        );\n\n        // Initial entry point is always the first split.\n        let first_split_entry = self.insts.len();\n\n        // Save up all of the holes from each alternate. They will all get\n        // patched to point to the same location.\n        let mut holes = vec![];\n\n        // true indicates that the hole is a split where we want to fill\n        // the second branch.\n        let mut prev_hole = (Hole::None, false);\n        for e in &exprs[0..exprs.len() - 1] {\n            if prev_hole.1 {\n                let next = self.insts.len();\n                self.fill_split(prev_hole.0, None, Some(next));\n            } else {\n                self.fill_to_next(prev_hole.0);\n            }\n            let split = self.push_split_hole();\n            if let Some(Patch { hole, entry }) = self.c(e)? {\n                holes.push(hole);\n                prev_hole = (self.fill_split(split, Some(entry), None), false);\n            } else {\n                let (split1, split2) = split.dup_one();\n                holes.push(split1);\n                prev_hole = (split2, true);\n            }\n        }\n        if let Some(Patch { hole, entry }) = self.c(&exprs[exprs.len() - 1])? {\n            holes.push(hole);\n            if prev_hole.1 {\n                self.fill_split(prev_hole.0, None, Some(entry));\n            } else {\n                self.fill(prev_hole.0, entry);\n            }\n        } else {\n            // We ignore prev_hole.1. When it's true, it means we have two\n            // empty branches both pushing prev_hole.0 into holes, so both\n            // branches will go to the same place anyway.\n            holes.push(prev_hole.0);\n        }\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }\n\n    fn c_repeat(&mut self, rep: &hir::Repetition) -> ResultOrEmpty {\n        match (rep.min, rep.max) {\n            (0, Some(1)) => self.c_repeat_zero_or_one(&rep.sub, rep.greedy),\n            (0, None) => self.c_repeat_zero_or_more(&rep.sub, rep.greedy),\n            (1, None) => self.c_repeat_one_or_more(&rep.sub, rep.greedy),\n            (min, None) => {\n                self.c_repeat_range_min_or_more(&rep.sub, rep.greedy, min)\n            }\n            (min, Some(max)) => {\n                self.c_repeat_range(&rep.sub, rep.greedy, min, max)\n            }\n        }\n    }\n\n    fn c_repeat_zero_or_one(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        let holes = vec![hole_rep, split_hole];\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: split_entry }))\n    }\n\n    fn c_repeat_zero_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n\n        self.fill(hole_rep, split_entry);\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: split_entry }))\n    }\n\n    fn c_repeat_one_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty {\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return Ok(None),\n        };\n        self.fill_to_next(hole_rep);\n        let split = self.push_split_hole();\n\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: entry_rep }))\n    }\n\n    fn c_repeat_range_min_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n    ) -> ResultOrEmpty {\n        let min = u32_to_usize(min);\n        // Using next_inst() is ok, because we can't return it (concat would\n        // have to return Some(_) while c_repeat_range_min_or_more returns\n        // None).\n        let patch_concat = self\n            .c_concat(iter::repeat(expr).take(min))?\n            .unwrap_or_else(|| self.next_inst());\n        if let Some(patch_rep) = self.c_repeat_zero_or_more(expr, greedy)? {\n            self.fill(patch_concat.hole, patch_rep.entry);\n            Ok(Some(Patch { hole: patch_rep.hole, entry: patch_concat.entry }))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn c_repeat_range(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n        max: u32,\n    ) -> ResultOrEmpty {\n        let (min, max) = (u32_to_usize(min), u32_to_usize(max));\n        debug_assert!(min <= max);\n        let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n        if min == max {\n            return Ok(patch_concat);\n        }\n        // Same reasoning as in c_repeat_range_min_or_more (we know that min <\n        // max at this point).\n        let patch_concat = patch_concat.unwrap_or_else(|| self.next_inst());\n        let initial_entry = patch_concat.entry;\n        // It is much simpler to compile, e.g., `a{2,5}` as:\n        //\n        //     aaa?a?a?\n        //\n        // But you end up with a sequence of instructions like this:\n        //\n        //     0: 'a'\n        //     1: 'a',\n        //     2: split(3, 4)\n        //     3: 'a'\n        //     4: split(5, 6)\n        //     5: 'a'\n        //     6: split(7, 8)\n        //     7: 'a'\n        //     8: MATCH\n        //\n        // This is *incredibly* inefficient because the splits end\n        // up forming a chain, which has to be resolved everything a\n        // transition is followed.\n        let mut holes = vec![];\n        let mut prev_hole = patch_concat.hole;\n        for _ in min..max {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } = match self.c(expr)? {\n                Some(p) => p,\n                None => return self.pop_split_hole(),\n            };\n            prev_hole = hole;\n            if greedy {\n                holes.push(self.fill_split(split, Some(entry), None));\n            } else {\n                holes.push(self.fill_split(split, None, Some(entry)));\n            }\n        }\n        holes.push(prev_hole);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: initial_entry }))\n    }\n\n    /// Can be used as a default value for the c_* functions when the call to\n    /// c_function is followed by inserting at least one instruction that is\n    /// always executed after the ones written by the c* function.\n    fn next_inst(&self) -> Patch {\n        Patch { hole: Hole::None, entry: self.insts.len() }\n    }\n\n    fn fill(&mut self, hole: Hole, goto: InstPtr) {\n        match hole {\n            Hole::None => {}\n            Hole::One(pc) => {\n                self.insts[pc].fill(goto);\n            }\n            Hole::Many(holes) => {\n                for hole in holes {\n                    self.fill(hole, goto);\n                }\n            }\n        }\n    }\n\n    fn fill_to_next(&mut self, hole: Hole) {\n        let next = self.insts.len();\n        self.fill(hole, next);\n    }\n\n    fn fill_split(\n        &mut self,\n        hole: Hole,\n        goto1: Option<InstPtr>,\n        goto2: Option<InstPtr>,\n    ) -> Hole {\n        match hole {\n            Hole::None => Hole::None,\n            Hole::One(pc) => match (goto1, goto2) {\n                (Some(goto1), Some(goto2)) => {\n                    self.insts[pc].fill_split(goto1, goto2);\n                    Hole::None\n                }\n                (Some(goto1), None) => {\n                    self.insts[pc].half_fill_split_goto1(goto1);\n                    Hole::One(pc)\n                }\n                (None, Some(goto2)) => {\n                    self.insts[pc].half_fill_split_goto2(goto2);\n                    Hole::One(pc)\n                }\n                (None, None) => unreachable!(\n                    \"at least one of the split \\\n                     holes must be filled\"\n                ),\n            },\n            Hole::Many(holes) => {\n                let mut new_holes = vec![];\n                for hole in holes {\n                    new_holes.push(self.fill_split(hole, goto1, goto2));\n                }\n                if new_holes.is_empty() {\n                    Hole::None\n                } else if new_holes.len() == 1 {\n                    new_holes.pop().unwrap()\n                } else {\n                    Hole::Many(new_holes)\n                }\n            }\n        }\n    }\n\n    fn push_compiled(&mut self, inst: Inst) {\n        self.insts.push(MaybeInst::Compiled(inst));\n    }\n\n    fn push_hole(&mut self, inst: InstHole) -> Hole {\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Uncompiled(inst));\n        Hole::One(hole)\n    }\n\n    fn push_split_hole(&mut self) -> Hole {\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Split);\n        Hole::One(hole)\n    }\n\n    fn pop_split_hole(&mut self) -> ResultOrEmpty {\n        self.insts.pop();\n        Ok(None)\n    }\n\n    fn check_size(&self) -> result::Result<(), Error> {\n        use std::mem::size_of;\n\n        let size =\n            self.extra_inst_bytes + (self.insts.len() * size_of::<Inst>());\n        if size > self.size_limit {\n            Err(Error::CompiledTooBig(self.size_limit))\n        } else {\n            Ok(())\n        }\n    }\n}"],"compile::Hole":["Debug","impl Hole {\n    fn dup_one(self) -> (Self, Self) {\n        match self {\n            Hole::One(pc) => (Hole::One(pc), Hole::One(pc)),\n            Hole::None | Hole::Many(_) => {\n                unreachable!(\"must be called on single hole\")\n            }\n        }\n    }\n}"],"compile::InstHole":["Clone","Debug","impl InstHole {\n    fn fill(&self, goto: InstPtr) -> Inst {\n        match *self {\n            InstHole::Save { slot } => Inst::Save(InstSave { goto, slot }),\n            InstHole::EmptyLook { look } => {\n                Inst::EmptyLook(InstEmptyLook { goto, look })\n            }\n            InstHole::Char { c } => Inst::Char(InstChar { goto, c }),\n            InstHole::Ranges { ref ranges } => Inst::Ranges(InstRanges {\n                goto,\n                ranges: ranges.clone().into_boxed_slice(),\n            }),\n            InstHole::Bytes { start, end } => {\n                Inst::Bytes(InstBytes { goto, start, end })\n            }\n        }\n    }\n}"],"compile::MaybeInst":["Clone","Debug","impl MaybeInst {\n    fn fill(&mut self, goto: InstPtr) {\n        let maybeinst = match *self {\n            MaybeInst::Split => MaybeInst::Split1(goto),\n            MaybeInst::Uncompiled(ref inst) => {\n                MaybeInst::Compiled(inst.fill(goto))\n            }\n            MaybeInst::Split1(goto1) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1,\n                    goto2: goto,\n                }))\n            }\n            MaybeInst::Split2(goto2) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1: goto,\n                    goto2,\n                }))\n            }\n            _ => unreachable!(\n                \"not all instructions were compiled! \\\n                 found uncompiled instruction: {:?}\",\n                self\n            ),\n        };\n        *self = maybeinst;\n    }\n\n    fn fill_split(&mut self, goto1: InstPtr, goto2: InstPtr) {\n        let filled = match *self {\n            MaybeInst::Split => Inst::Split(InstSplit { goto1, goto2 }),\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Compiled(filled);\n    }\n\n    fn half_fill_split_goto1(&mut self, goto1: InstPtr) {\n        let half_filled = match *self {\n            MaybeInst::Split => goto1,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split1(half_filled);\n    }\n\n    fn half_fill_split_goto2(&mut self, goto2: InstPtr) {\n        let half_filled = match *self {\n            MaybeInst::Split => goto2,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split2(half_filled);\n    }\n\n    fn unwrap(self) -> Inst {\n        match self {\n            MaybeInst::Compiled(inst) => inst,\n            _ => unreachable!(\n                \"must be called on a compiled instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        }\n    }\n}"],"compile::Patch":["Debug"],"compile::SuffixCache":["Debug","impl SuffixCache {\n    fn new(size: usize) -> Self {\n        SuffixCache {\n            sparse: vec![0usize; size].into(),\n            dense: Vec::with_capacity(size),\n        }\n    }\n\n    fn get(&mut self, key: SuffixCacheKey, pc: InstPtr) -> Option<InstPtr> {\n        let hash = self.hash(&key);\n        let pos = &mut self.sparse[hash];\n        if let Some(entry) = self.dense.get(*pos) {\n            if entry.key == key {\n                return Some(entry.pc);\n            }\n        }\n        *pos = self.dense.len();\n        self.dense.push(SuffixCacheEntry { key, pc });\n        None\n    }\n\n    fn clear(&mut self) {\n        self.dense.clear();\n    }\n\n    fn hash(&self, suffix: &SuffixCacheKey) -> usize {\n        // Basic FNV-1a hash as described:\n        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n        const FNV_PRIME: u64 = 1_099_511_628_211;\n        let mut h = 14_695_981_039_346_656_037;\n        h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);\n        (h as usize) % self.sparse.len()\n    }\n}"],"compile::SuffixCacheEntry":["Clone","Copy","Debug","Default","Eq","Hash","PartialEq"],"compile::SuffixCacheKey":["Clone","Copy","Debug","Default","Eq","Hash","PartialEq"],"dfa::Byte":["Clone","Copy","Debug","impl Byte {\n    fn byte(b: u8) -> Self {\n        Byte(b as u16)\n    }\n    fn eof() -> Self {\n        Byte(256)\n    }\n    fn is_eof(&self) -> bool {\n        self.0 == 256\n    }\n\n    fn is_ascii_word(&self) -> bool {\n        let b = match self.as_byte() {\n            None => return false,\n            Some(b) => b,\n        };\n        match b {\n            b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'_' => true,\n            _ => false,\n        }\n    }\n\n    fn as_byte(&self) -> Option<u8> {\n        if self.is_eof() {\n            None\n        } else {\n            Some(self.0 as u8)\n        }\n    }\n}"],"dfa::Cache":["Debug","impl Cache {\n    /// Create new empty cache for the DFA engine.\n    pub fn new(prog: &Program) -> Self {\n        // We add 1 to account for the special EOF byte.\n        let num_byte_classes = (prog.byte_classes[255] as usize + 1) + 1;\n        let starts = vec![STATE_UNKNOWN; 256];\n        let mut cache = Cache {\n            inner: CacheInner {\n                compiled: StateMap::new(num_byte_classes),\n                trans: Transitions::new(num_byte_classes),\n                start_states: starts,\n                stack: vec![],\n                flush_count: 0,\n                size: 0,\n                insts_scratch_space: vec![],\n            },\n            qcur: SparseSet::new(prog.insts.len()),\n            qnext: SparseSet::new(prog.insts.len()),\n        };\n        cache.inner.reset_size();\n        cache\n    }\n}"],"dfa::CacheInner":["Debug","impl CacheInner {\n    /// Resets the cache size to account for fixed costs, such as the program\n    /// and stack sizes.\n    fn reset_size(&mut self) {\n        self.size = (self.start_states.len() * mem::size_of::<StatePtr>())\n            + (self.stack.len() * mem::size_of::<InstPtr>());\n    }\n}"],"dfa::EmptyFlags":["Clone","Copy","Debug","Default","Eq","Hash","PartialEq"],"dfa::Fsm":["Debug","impl<'a> Fsm<'a> {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn forward(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        quit_after_match: bool,\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa;\n        let mut dfa = Fsm {\n            prog,\n            start: 0, // filled in below\n            at,\n            quit_after_match,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn reverse(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        quit_after_match: bool,\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa_reverse;\n        let mut dfa = Fsm {\n            prog,\n            start: 0, // filled in below\n            at,\n            quit_after_match,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags_reverse(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        dfa.exec_at_reverse(&mut cache.qcur, &mut cache.qnext, text)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn forward_many(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        matches: &mut [bool],\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize> {\n        debug_assert!(matches.len() == prog.matches.len());\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa;\n        let mut dfa = Fsm {\n            prog,\n            start: 0, // filled in below\n            at,\n            quit_after_match: false,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        let result = dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text);\n        if result.is_match() {\n            if matches.len() == 1 {\n                matches[0] = true;\n            } else {\n                debug_assert!(dfa.last_match_si != STATE_UNKNOWN);\n                debug_assert!(dfa.last_match_si != STATE_DEAD);\n                for ip in dfa.state(dfa.last_match_si).inst_ptrs() {\n                    if let Inst::Match(slot) = dfa.prog[ip] {\n                        matches[slot] = true;\n                    }\n                }\n            }\n        }\n        result\n    }\n\n    /// Executes the DFA on a forward NFA.\n    ///\n    /// {qcur,qnext} are scratch ordered sets which may be non-empty.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn exec_at(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        text: &[u8],\n    ) -> Result<usize> {\n        // For the most part, the DFA is basically:\n        //\n        //   last_match = null\n        //   while current_byte != EOF:\n        //     si = current_state.next[current_byte]\n        //     if si is match\n        //       last_match = si\n        //   return last_match\n        //\n        // However, we need to deal with a few things:\n        //\n        //   1. This is an *online* DFA, so the current state's next list\n        //      may not point to anywhere yet, so we must go out and compute\n        //      them. (They are then cached into the current state's next list\n        //      to avoid re-computation.)\n        //   2. If we come across a state that is known to be dead (i.e., never\n        //      leads to a match), then we can quit early.\n        //   3. If the caller just wants to know if a match occurs, then we\n        //      can quit as soon as we know we have a match. (Full leftmost\n        //      first semantics require continuing on.)\n        //   4. If we're in the start state, then we can use a pre-computed set\n        //      of prefix literals to skip quickly along the input.\n        //   5. After the input is exhausted, we run the DFA on one symbol\n        //      that stands for EOF. This is useful for handling empty width\n        //      assertions.\n        //   6. We can't actually do state.next[byte]. Instead, we have to do\n        //      state.next[byte_classes[byte]], which permits us to keep the\n        //      'next' list very small.\n        //\n        // Since there's a bunch of extra stuff we need to consider, we do some\n        // pretty hairy tricks to get the inner loop to run as fast as\n        // possible.\n        debug_assert!(!self.prog.is_reverse);\n\n        // The last match is the currently known ending match position. It is\n        // reported as an index to the most recent byte that resulted in a\n        // transition to a match state and is always stored in capture slot `1`\n        // when searching forwards. Its maximum value is `text.len()`.\n        let mut result = Result::NoMatch(self.at);\n        let (mut prev_si, mut next_si) = (self.start, self.start);\n        let mut at = self.at;\n        while at < text.len() {\n            // This is the real inner loop. We take advantage of special bits\n            // set in the state pointer to determine whether a state is in the\n            // \"common\" case or not. Specifically, the common case is a\n            // non-match non-start non-dead state that has already been\n            // computed. So long as we remain in the common case, this inner\n            // loop will chew through the input.\n            //\n            // We also unroll the loop 4 times to amortize the cost of checking\n            // whether we've consumed the entire input. We are also careful\n            // to make sure that `prev_si` always represents the previous state\n            // and `next_si` always represents the next state after the loop\n            // exits, even if it isn't always true inside the loop.\n            while next_si <= STATE_MAX && at < text.len() {\n                // Argument for safety is in the definition of next_si.\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                at += 1;\n                if prev_si > STATE_MAX || at + 2 >= text.len() {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                at += 1;\n                if next_si > STATE_MAX {\n                    break;\n                }\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                at += 1;\n                if prev_si > STATE_MAX {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                at += 1;\n            }\n            if next_si & STATE_MATCH > 0 {\n                // A match state is outside of the common case because it needs\n                // special case analysis. In particular, we need to record the\n                // last position as having matched and possibly quit the DFA if\n                // we don't need to keep matching.\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at - 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n                prev_si = next_si;\n\n                // This permits short-circuiting when matching a regex set.\n                // In particular, if this DFA state contains only match states,\n                // then it's impossible to extend the set of matches since\n                // match states are final. Therefore, we can quit.\n                if self.prog.matches.len() > 1 {\n                    let state = self.state(next_si);\n                    let just_matches =\n                        state.inst_ptrs().all(|ip| self.prog[ip].is_match());\n                    if just_matches {\n                        return result;\n                    }\n                }\n\n                // Another inner loop! If the DFA stays in this particular\n                // match state, then we can rip through all of the input\n                // very quickly, and only recording the match location once\n                // we've left this particular state.\n                let cur = at;\n                while (next_si & !STATE_MATCH) == prev_si\n                    && at + 2 < text.len()\n                {\n                    // Argument for safety is in the definition of next_si.\n                    next_si = unsafe {\n                        self.next_si(next_si & !STATE_MATCH, text, at)\n                    };\n                    at += 1;\n                }\n                if at > cur {\n                    result = Result::Match(at - 2);\n                }\n            } else if next_si & STATE_START > 0 {\n                // A start state isn't in the common case because we may\n                // want to do quick prefix scanning. If the program doesn't\n                // have a detected prefix, then start states are actually\n                // considered common and this case is never reached.\n                debug_assert!(self.has_prefix());\n                next_si &= !STATE_START;\n                prev_si = next_si;\n                at = match self.prefix_at(text, at) {\n                    None => return Result::NoMatch(text.len()),\n                    Some(i) => i,\n                };\n            } else if next_si >= STATE_UNKNOWN {\n                if next_si == STATE_QUIT {\n                    return Result::Quit;\n                }\n                // Finally, this corresponds to the case where the transition\n                // entered a state that can never lead to a match or a state\n                // that hasn't been computed yet. The latter being the \"slow\"\n                // path.\n                let byte = Byte::byte(text[at - 1]);\n                // We no longer care about the special bits in the state\n                // pointer.\n                prev_si &= STATE_MAX;\n                // Record where we are. This is used to track progress for\n                // determining whether we should quit if we've flushed the\n                // cache too much.\n                self.at = at;\n                next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                    None => return Result::Quit,\n                    Some(STATE_DEAD) => return result.set_non_match(at),\n                    Some(si) => si,\n                };\n                debug_assert!(next_si != STATE_UNKNOWN);\n                if next_si & STATE_MATCH > 0 {\n                    next_si &= !STATE_MATCH;\n                    result = Result::Match(at - 1);\n                    if self.quit_after_match {\n                        return result;\n                    }\n                    self.last_match_si = next_si;\n                }\n                prev_si = next_si;\n            } else {\n                prev_si = next_si;\n            }\n        }\n\n        // Run the DFA once more on the special EOF sentinel value.\n        // We don't care about the special bits in the state pointer any more,\n        // so get rid of them.\n        prev_si &= STATE_MAX;\n        prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n            None => return Result::Quit,\n            Some(STATE_DEAD) => return result.set_non_match(text.len()),\n            Some(si) => si & !STATE_START,\n        };\n        debug_assert!(prev_si != STATE_UNKNOWN);\n        if prev_si & STATE_MATCH > 0 {\n            prev_si &= !STATE_MATCH;\n            self.last_match_si = prev_si;\n            result = Result::Match(text.len());\n        }\n        result\n    }\n\n    /// Executes the DFA on a reverse NFA.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn exec_at_reverse(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        text: &[u8],\n    ) -> Result<usize> {\n        // The comments in `exec_at` above mostly apply here too. The main\n        // difference is that we move backwards over the input and we look for\n        // the longest possible match instead of the leftmost-first match.\n        //\n        // N.B. The code duplication here is regrettable. Efforts to improve\n        // it without sacrificing performance are welcome. ---AG\n        debug_assert!(self.prog.is_reverse);\n        let mut result = Result::NoMatch(self.at);\n        let (mut prev_si, mut next_si) = (self.start, self.start);\n        let mut at = self.at;\n        while at > 0 {\n            while next_si <= STATE_MAX && at > 0 {\n                // Argument for safety is in the definition of next_si.\n                at -= 1;\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                if prev_si > STATE_MAX || at <= 4 {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                at -= 1;\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                if next_si > STATE_MAX {\n                    break;\n                }\n                at -= 1;\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                if prev_si > STATE_MAX {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                at -= 1;\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n            }\n            if next_si & STATE_MATCH > 0 {\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at + 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n                prev_si = next_si;\n                let cur = at;\n                while (next_si & !STATE_MATCH) == prev_si && at >= 2 {\n                    // Argument for safety is in the definition of next_si.\n                    at -= 1;\n                    next_si = unsafe {\n                        self.next_si(next_si & !STATE_MATCH, text, at)\n                    };\n                }\n                if at < cur {\n                    result = Result::Match(at + 2);\n                }\n            } else if next_si >= STATE_UNKNOWN {\n                if next_si == STATE_QUIT {\n                    return Result::Quit;\n                }\n                let byte = Byte::byte(text[at]);\n                prev_si &= STATE_MAX;\n                self.at = at;\n                next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                    None => return Result::Quit,\n                    Some(STATE_DEAD) => return result.set_non_match(at),\n                    Some(si) => si,\n                };\n                debug_assert!(next_si != STATE_UNKNOWN);\n                if next_si & STATE_MATCH > 0 {\n                    next_si &= !STATE_MATCH;\n                    result = Result::Match(at + 1);\n                    if self.quit_after_match {\n                        return result;\n                    }\n                    self.last_match_si = next_si;\n                }\n                prev_si = next_si;\n            } else {\n                prev_si = next_si;\n            }\n        }\n\n        // Run the DFA once more on the special EOF sentinel value.\n        prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n            None => return Result::Quit,\n            Some(STATE_DEAD) => return result.set_non_match(0),\n            Some(si) => si,\n        };\n        debug_assert!(prev_si != STATE_UNKNOWN);\n        if prev_si & STATE_MATCH > 0 {\n            prev_si &= !STATE_MATCH;\n            self.last_match_si = prev_si;\n            result = Result::Match(0);\n        }\n        result\n    }\n\n    /// next_si transitions to the next state, where the transition input\n    /// corresponds to text[i].\n    ///\n    /// This elides bounds checks, and is therefore not safe.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    unsafe fn next_si(&self, si: StatePtr, text: &[u8], i: usize) -> StatePtr {\n        // What is the argument for safety here?\n        // We have three unchecked accesses that could possibly violate safety:\n        //\n        //   1. The given byte of input (`text[i]`).\n        //   2. The class of the byte of input (`classes[text[i]]`).\n        //   3. The transition for the class (`trans[si + cls]`).\n        //\n        // (1) is only safe when calling next_si is guarded by\n        // `i < text.len()`.\n        //\n        // (2) is the easiest case to guarantee since `text[i]` is always a\n        // `u8` and `self.prog.byte_classes` always has length `u8::MAX`.\n        // (See `ByteClassSet.byte_classes` in `compile.rs`.)\n        //\n        // (3) is only safe if (1)+(2) are safe. Namely, the transitions\n        // of every state are defined to have length equal to the number of\n        // byte classes in the program. Therefore, a valid class leads to a\n        // valid transition. (All possible transitions are valid lookups, even\n        // if it points to a state that hasn't been computed yet.) (3) also\n        // relies on `si` being correct, but StatePtrs should only ever be\n        // retrieved from the transition table, which ensures they are correct.\n        debug_assert!(i < text.len());\n        let b = *text.get_unchecked(i);\n        debug_assert!((b as usize) < self.prog.byte_classes.len());\n        let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n        self.cache.trans.next_unchecked(si, cls as usize)\n    }\n\n    /// Computes the next state given the current state and the current input\n    /// byte (which may be EOF).\n    ///\n    /// If STATE_DEAD is returned, then there is no valid state transition.\n    /// This implies that no permutation of future input can lead to a match\n    /// state.\n    ///\n    /// STATE_UNKNOWN can never be returned.\n    fn exec_byte(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        mut si: StatePtr,\n        b: Byte,\n    ) -> Option<StatePtr> {\n        use crate::prog::Inst::*;\n\n        // Initialize a queue with the current DFA state's NFA states.\n        qcur.clear();\n        for ip in self.state(si).inst_ptrs() {\n            qcur.insert(ip);\n        }\n\n        // Before inspecting the current byte, we may need to also inspect\n        // whether the position immediately preceding the current byte\n        // satisfies the empty assertions found in the current state.\n        //\n        // We only need to do this step if there are any empty assertions in\n        // the current state.\n        let is_word_last = self.state(si).flags().is_word();\n        let is_word = b.is_ascii_word();\n        if self.state(si).flags().has_empty() {\n            // Compute the flags immediately preceding the current byte.\n            // This means we only care about the \"end\" or \"end line\" flags.\n            // (The \"start\" flags are computed immediately following the\n            // current byte and are handled below.)\n            let mut flags = EmptyFlags::default();\n            if b.is_eof() {\n                flags.end = true;\n                flags.end_line = true;\n            } else if b.as_byte().map_or(false, |b| b == b'\\n') {\n                flags.end_line = true;\n            }\n            if is_word_last == is_word {\n                flags.not_word_boundary = true;\n            } else {\n                flags.word_boundary = true;\n            }\n            // Now follow epsilon transitions from every NFA state, but make\n            // sure we only follow transitions that satisfy our flags.\n            qnext.clear();\n            for &ip in &*qcur {\n                self.follow_epsilons(usize_to_u32(ip), qnext, flags);\n            }\n            mem::swap(qcur, qnext);\n        }\n\n        // Now we set flags for immediately after the current byte. Since start\n        // states are processed separately, and are the only states that can\n        // have the StartText flag set, we therefore only need to worry about\n        // the StartLine flag here.\n        //\n        // We do also keep track of whether this DFA state contains a NFA state\n        // that is a matching state. This is precisely how we delay the DFA\n        // matching by one byte in order to process the special EOF sentinel\n        // byte. Namely, if this DFA state containing a matching NFA state,\n        // then it is the *next* DFA state that is marked as a match.\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start_line = b.as_byte().map_or(false, |b| b == b'\\n');\n        if b.is_ascii_word() {\n            state_flags.set_word();\n        }\n        // Now follow all epsilon transitions again, but only after consuming\n        // the current byte.\n        qnext.clear();\n        for &ip in &*qcur {\n            match self.prog[ip as usize] {\n                // These states never happen in a byte-based program.\n                Char(_) | Ranges(_) => unreachable!(),\n                // These states are handled when following epsilon transitions.\n                Save(_) | Split(_) | EmptyLook(_) => {}\n                Match(_) => {\n                    state_flags.set_match();\n                    if !self.continue_past_first_match() {\n                        break;\n                    } else if self.prog.matches.len() > 1\n                        && !qnext.contains(ip as usize)\n                    {\n                        // If we are continuing on to find other matches,\n                        // then keep a record of the match states we've seen.\n                        qnext.insert(ip);\n                    }\n                }\n                Bytes(ref inst) => {\n                    if b.as_byte().map_or(false, |b| inst.matches(b)) {\n                        self.follow_epsilons(\n                            inst.goto as InstPtr,\n                            qnext,\n                            empty_flags,\n                        );\n                    }\n                }\n            }\n        }\n\n        let cache = if b.is_eof() && self.prog.matches.len() > 1 {\n            // If we're processing the last byte of the input and we're\n            // matching a regex set, then make the next state contain the\n            // previous states transitions. We do this so that the main\n            // matching loop can extract all of the match instructions.\n            mem::swap(qcur, qnext);\n            // And don't cache this state because it's totally bunk.\n            false\n        } else {\n            true\n        };\n\n        // We've now built up the set of NFA states that ought to comprise the\n        // next DFA state, so try to find it in the cache, and if it doesn't\n        // exist, cache it.\n        //\n        // N.B. We pass `&mut si` here because the cache may clear itself if\n        // it has gotten too full. When that happens, the location of the\n        // current state may change.\n        let mut next =\n            match self.cached_state(qnext, state_flags, Some(&mut si)) {\n                None => return None,\n                Some(next) => next,\n            };\n        if (self.start & !STATE_START) == next {\n            // Start states can never be match states since all matches are\n            // delayed by one byte.\n            debug_assert!(!self.state(next).flags().is_match());\n            next = self.start_ptr(next);\n        }\n        if next <= STATE_MAX && self.state(next).flags().is_match() {\n            next |= STATE_MATCH;\n        }\n        debug_assert!(next != STATE_UNKNOWN);\n        // And now store our state in the current state's next list.\n        if cache {\n            let cls = self.byte_class(b);\n            self.cache.trans.set_next(si, cls, next);\n        }\n        Some(next)\n    }\n\n    /// Follows the epsilon transitions starting at (and including) `ip`. The\n    /// resulting states are inserted into the ordered set `q`.\n    ///\n    /// Conditional epsilon transitions (i.e., empty width assertions) are only\n    /// followed if they are satisfied by the given flags, which should\n    /// represent the flags set at the current location in the input.\n    ///\n    /// If the current location corresponds to the empty string, then only the\n    /// end line and/or end text flags may be set. If the current location\n    /// corresponds to a real byte in the input, then only the start line\n    /// and/or start text flags may be set.\n    ///\n    /// As an exception to the above, when finding the initial state, any of\n    /// the above flags may be set:\n    ///\n    /// If matching starts at the beginning of the input, then start text and\n    /// start line should be set. If the input is empty, then end text and end\n    /// line should also be set.\n    ///\n    /// If matching starts after the beginning of the input, then only start\n    /// line should be set if the preceding byte is `\\n`. End line should never\n    /// be set in this case. (Even if the following byte is a `\\n`, it will\n    /// be handled in a subsequent DFA state.)\n    fn follow_epsilons(\n        &mut self,\n        ip: InstPtr,\n        q: &mut SparseSet,\n        flags: EmptyFlags,\n    ) {\n        use crate::prog::EmptyLook::*;\n        use crate::prog::Inst::*;\n\n        // We need to traverse the NFA to follow epsilon transitions, so avoid\n        // recursion with an explicit stack.\n        self.cache.stack.push(ip);\n        while let Some(mut ip) = self.cache.stack.pop() {\n            // Try to munch through as many states as possible without\n            // pushes/pops to the stack.\n            loop {\n                // Don't visit states we've already added.\n                if q.contains(ip as usize) {\n                    break;\n                }\n                q.insert(ip as usize);\n                match self.prog[ip as usize] {\n                    Char(_) | Ranges(_) => unreachable!(),\n                    Match(_) | Bytes(_) => {\n                        break;\n                    }\n                    EmptyLook(ref inst) => {\n                        // Only follow empty assertion states if our flags\n                        // satisfy the assertion.\n                        match inst.look {\n                            StartLine if flags.start_line => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            EndLine if flags.end_line => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            StartText if flags.start => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            EndText if flags.end => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            WordBoundaryAscii if flags.word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            NotWordBoundaryAscii\n                                if flags.not_word_boundary =>\n                            {\n                                ip = inst.goto as InstPtr;\n                            }\n                            WordBoundary if flags.word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            NotWordBoundary if flags.not_word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            StartLine | EndLine | StartText | EndText\n                            | WordBoundaryAscii | NotWordBoundaryAscii\n                            | WordBoundary | NotWordBoundary => {\n                                break;\n                            }\n                        }\n                    }\n                    Save(ref inst) => {\n                        ip = inst.goto as InstPtr;\n                    }\n                    Split(ref inst) => {\n                        self.cache.stack.push(inst.goto2 as InstPtr);\n                        ip = inst.goto1 as InstPtr;\n                    }\n                }\n            }\n        }\n    }\n\n    /// Find a previously computed state matching the given set of instructions\n    /// and is_match bool.\n    ///\n    /// The given set of instructions should represent a single state in the\n    /// NFA along with all states reachable without consuming any input.\n    ///\n    /// The is_match bool should be true if and only if the preceding DFA state\n    /// contains an NFA matching state. The cached state produced here will\n    /// then signify a match. (This enables us to delay a match by one byte,\n    /// in order to account for the EOF sentinel byte.)\n    ///\n    /// If the cache is full, then it is wiped before caching a new state.\n    ///\n    /// The current state should be specified if it exists, since it will need\n    /// to be preserved if the cache clears itself. (Start states are\n    /// always saved, so they should not be passed here.) It takes a mutable\n    /// pointer to the index because if the cache is cleared, the state's\n    /// location may change.\n    fn cached_state(\n        &mut self,\n        q: &SparseSet,\n        mut state_flags: StateFlags,\n        current_state: Option<&mut StatePtr>,\n    ) -> Option<StatePtr> {\n        // If we couldn't come up with a non-empty key to represent this state,\n        // then it is dead and can never lead to a match.\n        //\n        // Note that inst_flags represent the set of empty width assertions\n        // in q. We use this as an optimization in exec_byte to determine when\n        // we should follow epsilon transitions at the empty string preceding\n        // the current byte.\n        let key = match self.cached_state_key(q, &mut state_flags) {\n            None => return Some(STATE_DEAD),\n            Some(v) => v,\n        };\n        // In the cache? Cool. Done.\n        if let Some(si) = self.cache.compiled.get_ptr(&key) {\n            return Some(si);\n        }\n        // If the cache has gotten too big, wipe it.\n        if self.approximate_size() > self.prog.dfa_size_limit\n            && !self.clear_cache_and_save(current_state)\n        {\n            // Ooops. DFA is giving up.\n            return None;\n        }\n        // Allocate room for our state and add it.\n        self.add_state(key)\n    }\n\n    /// Produces a key suitable for describing a state in the DFA cache.\n    ///\n    /// The key invariant here is that equivalent keys are produced for any two\n    /// sets of ordered NFA states (and toggling of whether the previous NFA\n    /// states contain a match state) that do not discriminate a match for any\n    /// input.\n    ///\n    /// Specifically, q should be an ordered set of NFA states and is_match\n    /// should be true if and only if the previous NFA states contained a match\n    /// state.\n    fn cached_state_key(\n        &mut self,\n        q: &SparseSet,\n        state_flags: &mut StateFlags,\n    ) -> Option<State> {\n        use crate::prog::Inst::*;\n\n        // We need to build up enough information to recognize pre-built states\n        // in the DFA. Generally speaking, this includes every instruction\n        // except for those which are purely epsilon transitions, e.g., the\n        // Save and Split instructions.\n        //\n        // Empty width assertions are also epsilon transitions, but since they\n        // are conditional, we need to make them part of a state's key in the\n        // cache.\n\n        let mut insts =\n            mem::replace(&mut self.cache.insts_scratch_space, vec![]);\n        insts.clear();\n        // Reserve 1 byte for flags.\n        insts.push(0);\n\n        let mut prev = 0;\n        for &ip in q {\n            let ip = usize_to_u32(ip);\n            match self.prog[ip as usize] {\n                Char(_) | Ranges(_) => unreachable!(),\n                Save(_) | Split(_) => {}\n                Bytes(_) => push_inst_ptr(&mut insts, &mut prev, ip),\n                EmptyLook(_) => {\n                    state_flags.set_empty();\n                    push_inst_ptr(&mut insts, &mut prev, ip)\n                }\n                Match(_) => {\n                    push_inst_ptr(&mut insts, &mut prev, ip);\n                    if !self.continue_past_first_match() {\n                        break;\n                    }\n                }\n            }\n        }\n        // If we couldn't transition to any other instructions and we didn't\n        // see a match when expanding NFA states previously, then this is a\n        // dead state and no amount of additional input can transition out\n        // of this state.\n        let opt_state = if insts.len() == 1 && !state_flags.is_match() {\n            None\n        } else {\n            let StateFlags(f) = *state_flags;\n            insts[0] = f;\n            Some(State { data: Arc::from(&*insts) })\n        };\n        self.cache.insts_scratch_space = insts;\n        opt_state\n    }\n\n    /// Clears the cache, but saves and restores current_state if it is not\n    /// none.\n    ///\n    /// The current state must be provided here in case its location in the\n    /// cache changes.\n    ///\n    /// This returns false if the cache is not cleared and the DFA should\n    /// give up.\n    fn clear_cache_and_save(\n        &mut self,\n        current_state: Option<&mut StatePtr>,\n    ) -> bool {\n        if self.cache.compiled.is_empty() {\n            // Nothing to clear...\n            return true;\n        }\n        match current_state {\n            None => self.clear_cache(),\n            Some(si) => {\n                let cur = self.state(*si).clone();\n                if !self.clear_cache() {\n                    return false;\n                }\n                // The unwrap is OK because we just cleared the cache and\n                // therefore know that the next state pointer won't exceed\n                // STATE_MAX.\n                *si = self.restore_state(cur).unwrap();\n                true\n            }\n        }\n    }\n\n    /// Wipes the state cache, but saves and restores the current start state.\n    ///\n    /// This returns false if the cache is not cleared and the DFA should\n    /// give up.\n    fn clear_cache(&mut self) -> bool {\n        // Bail out of the DFA if we're moving too \"slowly.\"\n        // A heuristic from RE2: assume the DFA is too slow if it is processing\n        // 10 or fewer bytes per state.\n        // Additionally, we permit the cache to be flushed a few times before\n        // caling it quits.\n        let nstates = self.cache.compiled.len();\n        if self.cache.flush_count >= 3\n            && self.at >= self.last_cache_flush\n            && (self.at - self.last_cache_flush) <= 10 * nstates\n        {\n            return false;\n        }\n        // Update statistics tracking cache flushes.\n        self.last_cache_flush = self.at;\n        self.cache.flush_count += 1;\n\n        // OK, actually flush the cache.\n        let start = self.state(self.start & !STATE_START).clone();\n        let last_match = if self.last_match_si <= STATE_MAX {\n            Some(self.state(self.last_match_si).clone())\n        } else {\n            None\n        };\n        self.cache.reset_size();\n        self.cache.trans.clear();\n        self.cache.compiled.clear();\n        for s in &mut self.cache.start_states {\n            *s = STATE_UNKNOWN;\n        }\n        // The unwraps are OK because we just cleared the cache and therefore\n        // know that the next state pointer won't exceed STATE_MAX.\n        let start_ptr = self.restore_state(start).unwrap();\n        self.start = self.start_ptr(start_ptr);\n        if let Some(last_match) = last_match {\n            self.last_match_si = self.restore_state(last_match).unwrap();\n        }\n        true\n    }\n\n    /// Restores the given state back into the cache, and returns a pointer\n    /// to it.\n    fn restore_state(&mut self, state: State) -> Option<StatePtr> {\n        // If we've already stored this state, just return a pointer to it.\n        // None will be the wiser.\n        if let Some(si) = self.cache.compiled.get_ptr(&state) {\n            return Some(si);\n        }\n        self.add_state(state)\n    }\n\n    /// Returns the next state given the current state si and current byte\n    /// b. {qcur,qnext} are used as scratch space for storing ordered NFA\n    /// states.\n    ///\n    /// This tries to fetch the next state from the cache, but if that fails,\n    /// it computes the next state, caches it and returns a pointer to it.\n    ///\n    /// The pointer can be to a real state, or it can be STATE_DEAD.\n    /// STATE_UNKNOWN cannot be returned.\n    ///\n    /// None is returned if a new state could not be allocated (i.e., the DFA\n    /// ran out of space and thinks it's running too slowly).\n    fn next_state(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        si: StatePtr,\n        b: Byte,\n    ) -> Option<StatePtr> {\n        if si == STATE_DEAD {\n            return Some(STATE_DEAD);\n        }\n        match self.cache.trans.next(si, self.byte_class(b)) {\n            STATE_UNKNOWN => self.exec_byte(qcur, qnext, si, b),\n            STATE_QUIT => None,\n            nsi => Some(nsi),\n        }\n    }\n\n    /// Computes and returns the start state, where searching begins at\n    /// position `at` in `text`. If the state has already been computed,\n    /// then it is pulled from the cache. If the state hasn't been cached,\n    /// then it is computed, cached and a pointer to it is returned.\n    ///\n    /// This may return STATE_DEAD but never STATE_UNKNOWN.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn start_state(\n        &mut self,\n        q: &mut SparseSet,\n        empty_flags: EmptyFlags,\n        state_flags: StateFlags,\n    ) -> Option<StatePtr> {\n        // Compute an index into our cache of start states based on the set\n        // of empty/state flags set at the current position in the input. We\n        // don't use every flag since not all flags matter. For example, since\n        // matches are delayed by one byte, start states can never be match\n        // states.\n        let flagi = {\n            (((empty_flags.start as u8) << 0)\n                | ((empty_flags.end as u8) << 1)\n                | ((empty_flags.start_line as u8) << 2)\n                | ((empty_flags.end_line as u8) << 3)\n                | ((empty_flags.word_boundary as u8) << 4)\n                | ((empty_flags.not_word_boundary as u8) << 5)\n                | ((state_flags.is_word() as u8) << 6)) as usize\n        };\n        match self.cache.start_states[flagi] {\n            STATE_UNKNOWN => {}\n            si => return Some(si),\n        }\n        q.clear();\n        let start = usize_to_u32(self.prog.start);\n        self.follow_epsilons(start, q, empty_flags);\n        // Start states can never be match states because we delay every match\n        // by one byte. Given an empty string and an empty match, the match\n        // won't actually occur until the DFA processes the special EOF\n        // sentinel byte.\n        let sp = match self.cached_state(q, state_flags, None) {\n            None => return None,\n            Some(sp) => self.start_ptr(sp),\n        };\n        self.cache.start_states[flagi] = sp;\n        Some(sp)\n    }\n\n    /// Computes the set of starting flags for the given position in text.\n    ///\n    /// This should only be used when executing the DFA forwards over the\n    /// input.\n    fn start_flags(&self, text: &[u8], at: usize) -> (EmptyFlags, StateFlags) {\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start = at == 0;\n        empty_flags.end = text.is_empty();\n        empty_flags.start_line = at == 0 || text[at - 1] == b'\\n';\n        empty_flags.end_line = text.is_empty();\n\n        let is_word_last = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n        let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n        if is_word_last {\n            state_flags.set_word();\n        }\n        if is_word == is_word_last {\n            empty_flags.not_word_boundary = true;\n        } else {\n            empty_flags.word_boundary = true;\n        }\n        (empty_flags, state_flags)\n    }\n\n    /// Computes the set of starting flags for the given position in text.\n    ///\n    /// This should only be used when executing the DFA in reverse over the\n    /// input.\n    fn start_flags_reverse(\n        &self,\n        text: &[u8],\n        at: usize,\n    ) -> (EmptyFlags, StateFlags) {\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start = at == text.len();\n        empty_flags.end = text.is_empty();\n        empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n        empty_flags.end_line = text.is_empty();\n\n        let is_word_last =\n            at < text.len() && Byte::byte(text[at]).is_ascii_word();\n        let is_word = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n        if is_word_last {\n            state_flags.set_word();\n        }\n        if is_word == is_word_last {\n            empty_flags.not_word_boundary = true;\n        } else {\n            empty_flags.word_boundary = true;\n        }\n        (empty_flags, state_flags)\n    }\n\n    /// Returns a reference to a State given a pointer to it.\n    fn state(&self, si: StatePtr) -> &State {\n        self.cache.compiled.get_state(si).unwrap()\n    }\n\n    /// Adds the given state to the DFA.\n    ///\n    /// This allocates room for transitions out of this state in\n    /// self.cache.trans. The transitions can be set with the returned\n    /// StatePtr.\n    ///\n    /// If None is returned, then the state limit was reached and the DFA\n    /// should quit.\n    fn add_state(&mut self, state: State) -> Option<StatePtr> {\n        // This will fail if the next state pointer exceeds STATE_PTR. In\n        // practice, the cache limit will prevent us from ever getting here,\n        // but maybe callers will set the cache size to something ridiculous...\n        let si = match self.cache.trans.add() {\n            None => return None,\n            Some(si) => si,\n        };\n        // If the program has a Unicode word boundary, then set any transitions\n        // for non-ASCII bytes to STATE_QUIT. If the DFA stumbles over such a\n        // transition, then it will quit and an alternative matching engine\n        // will take over.\n        if self.prog.has_unicode_word_boundary {\n            for b in 128..256 {\n                let cls = self.byte_class(Byte::byte(b as u8));\n                self.cache.trans.set_next(si, cls, STATE_QUIT);\n            }\n        }\n        // Finally, put our actual state on to our heap of states and index it\n        // so we can find it later.\n        self.cache.size += self.cache.trans.state_heap_size()\n            + state.data.len()\n            + (2 * mem::size_of::<State>())\n            + mem::size_of::<StatePtr>();\n        self.cache.compiled.insert(state, si);\n        // Transition table and set of states and map should all be in sync.\n        debug_assert!(\n            self.cache.compiled.len() == self.cache.trans.num_states()\n        );\n        Some(si)\n    }\n\n    /// Quickly finds the next occurrence of any literal prefixes in the regex.\n    /// If there are no literal prefixes, then the current position is\n    /// returned. If there are literal prefixes and one could not be found,\n    /// then None is returned.\n    ///\n    /// This should only be called when the DFA is in a start state.\n    fn prefix_at(&self, text: &[u8], at: usize) -> Option<usize> {\n        self.prog.prefixes.find(&text[at..]).map(|(s, _)| at + s)\n    }\n\n    /// Returns the number of byte classes required to discriminate transitions\n    /// in each state.\n    ///\n    /// invariant: num_byte_classes() == len(State.next)\n    fn num_byte_classes(&self) -> usize {\n        // We add 1 to account for the special EOF byte.\n        (self.prog.byte_classes[255] as usize + 1) + 1\n    }\n\n    /// Given an input byte or the special EOF sentinel, return its\n    /// corresponding byte class.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn byte_class(&self, b: Byte) -> usize {\n        match b.as_byte() {\n            None => self.num_byte_classes() - 1,\n            Some(b) => self.u8_class(b),\n        }\n    }\n\n    /// Like byte_class, but explicitly for u8s.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn u8_class(&self, b: u8) -> usize {\n        self.prog.byte_classes[b as usize] as usize\n    }\n\n    /// Returns true if the DFA should continue searching past the first match.\n    ///\n    /// Leftmost first semantics in the DFA are preserved by not following NFA\n    /// transitions after the first match is seen.\n    ///\n    /// On occasion, we want to avoid leftmost first semantics to find either\n    /// the longest match (for reverse search) or all possible matches (for\n    /// regex sets).\n    fn continue_past_first_match(&self) -> bool {\n        self.prog.is_reverse || self.prog.matches.len() > 1\n    }\n\n    /// Returns true if there is a prefix we can quickly search for.\n    fn has_prefix(&self) -> bool {\n        !self.prog.is_reverse\n            && !self.prog.prefixes.is_empty()\n            && !self.prog.is_anchored_start\n    }\n\n    /// Sets the STATE_START bit in the given state pointer if and only if\n    /// we have a prefix to scan for.\n    ///\n    /// If there's no prefix, then it's a waste to treat the start state\n    /// specially.\n    fn start_ptr(&self, si: StatePtr) -> StatePtr {\n        if self.has_prefix() {\n            si | STATE_START\n        } else {\n            si\n        }\n    }\n\n    /// Approximate size returns the approximate heap space currently used by\n    /// the DFA. It is used to determine whether the DFA's state cache needs to\n    /// be wiped. Namely, it is possible that for certain regexes on certain\n    /// inputs, a new state could be created for every byte of input. (This is\n    /// bad for memory use, so we bound it with a cache.)\n    fn approximate_size(&self) -> usize {\n        self.cache.size\n    }\n}"],"dfa::InstPtrs":["impl<'a> Iterator for InstPtrs<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        if self.data.is_empty() {\n            return None;\n        }\n        let (delta, nread) = read_vari32(self.data);\n        let base = self.base as i32 + delta;\n        debug_assert!(base >= 0);\n        debug_assert!(nread > 0);\n        self.data = &self.data[nread..];\n        self.base = base as usize;\n        Some(self.base)\n    }\n}"],"dfa::Result":["Clone","Debug","impl<T> Result<T> {\n    /// Returns true if this result corresponds to a match.\n    pub fn is_match(&self) -> bool {\n        match *self {\n            Result::Match(_) => true,\n            Result::NoMatch(_) | Result::Quit => false,\n        }\n    }\n\n    /// Maps the given function onto T and returns the result.\n    ///\n    /// If this isn't a match, then this is a no-op.\n    #[cfg(feature = \"perf-literal\")]\n    pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> Result<U> {\n        match self {\n            Result::Match(t) => Result::Match(f(t)),\n            Result::NoMatch(x) => Result::NoMatch(x),\n            Result::Quit => Result::Quit,\n        }\n    }\n\n    /// Sets the non-match position.\n    ///\n    /// If this isn't a non-match, then this is a no-op.\n    fn set_non_match(self, at: usize) -> Result<T> {\n        match self {\n            Result::NoMatch(_) => Result::NoMatch(at),\n            r => r,\n        }\n    }\n}"],"dfa::State":["Clone","Eq","Hash","PartialEq","impl State {\n    fn flags(&self) -> StateFlags {\n        StateFlags(self.data[0])\n    }\n\n    fn inst_ptrs(&self) -> InstPtrs<'_> {\n        InstPtrs { base: 0, data: &self.data[1..] }\n    }\n}","impl fmt::Debug for State {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let ips: Vec<usize> = self.inst_ptrs().collect();\n        f.debug_struct(\"State\")\n            .field(\"flags\", &self.flags())\n            .field(\"insts\", &ips)\n            .finish()\n    }\n}"],"dfa::StateFlags":["Clone","Copy","Default","Eq","Hash","PartialEq","impl StateFlags {\n    fn is_match(&self) -> bool {\n        self.0 & 0b0000_0001 > 0\n    }\n\n    fn set_match(&mut self) {\n        self.0 |= 0b0000_0001;\n    }\n\n    fn is_word(&self) -> bool {\n        self.0 & 0b0000_0010 > 0\n    }\n\n    fn set_word(&mut self) {\n        self.0 |= 0b0000_0010;\n    }\n\n    fn has_empty(&self) -> bool {\n        self.0 & 0b0000_0100 > 0\n    }\n\n    fn set_empty(&mut self) {\n        self.0 |= 0b0000_0100;\n    }\n}","impl fmt::Debug for StateFlags {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct(\"StateFlags\")\n            .field(\"is_match\", &self.is_match())\n            .field(\"is_word\", &self.is_word())\n            .field(\"has_empty\", &self.has_empty())\n            .finish()\n    }\n}"],"dfa::StateMap":["Debug","impl StateMap {\n    fn new(num_byte_classes: usize) -> StateMap {\n        StateMap { map: HashMap::new(), states: vec![], num_byte_classes }\n    }\n\n    fn len(&self) -> usize {\n        self.states.len()\n    }\n\n    fn is_empty(&self) -> bool {\n        self.states.is_empty()\n    }\n\n    fn get_ptr(&self, state: &State) -> Option<StatePtr> {\n        self.map.get(state).cloned()\n    }\n\n    fn get_state(&self, si: StatePtr) -> Option<&State> {\n        self.states.get(si as usize / self.num_byte_classes)\n    }\n\n    fn insert(&mut self, state: State, si: StatePtr) {\n        self.map.insert(state.clone(), si);\n        self.states.push(state);\n    }\n\n    fn clear(&mut self) {\n        self.map.clear();\n        self.states.clear();\n    }\n}"],"dfa::Transitions":["Clone","impl Transitions {\n    /// Create a new transition table.\n    ///\n    /// The number of byte classes corresponds to the stride. Every state will\n    /// have `num_byte_classes` slots for transitions.\n    fn new(num_byte_classes: usize) -> Transitions {\n        Transitions { table: vec![], num_byte_classes }\n    }\n\n    /// Returns the total number of states currently in this table.\n    fn num_states(&self) -> usize {\n        self.table.len() / self.num_byte_classes\n    }\n\n    /// Allocates room for one additional state and returns a pointer to it.\n    ///\n    /// If there's no more room, None is returned.\n    fn add(&mut self) -> Option<StatePtr> {\n        let si = self.table.len();\n        if si > STATE_MAX as usize {\n            return None;\n        }\n        self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));\n        Some(usize_to_u32(si))\n    }\n\n    /// Clears the table of all states.\n    fn clear(&mut self) {\n        self.table.clear();\n    }\n\n    /// Sets the transition from (si, cls) to next.\n    fn set_next(&mut self, si: StatePtr, cls: usize, next: StatePtr) {\n        self.table[si as usize + cls] = next;\n    }\n\n    /// Returns the transition corresponding to (si, cls).\n    fn next(&self, si: StatePtr, cls: usize) -> StatePtr {\n        self.table[si as usize + cls]\n    }\n\n    /// The heap size, in bytes, of a single state in the transition table.\n    fn state_heap_size(&self) -> usize {\n        self.num_byte_classes * mem::size_of::<StatePtr>()\n    }\n\n    /// Like `next`, but uses unchecked access and is therefore not safe.\n    unsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr {\n        debug_assert!((si as usize) < self.table.len());\n        debug_assert!(cls < self.num_byte_classes);\n        *self.table.get_unchecked(si as usize + cls)\n    }\n}","impl fmt::Debug for Transitions {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut fmtd = f.debug_map();\n        for si in 0..self.num_states() {\n            let s = si * self.num_byte_classes;\n            let e = s + self.num_byte_classes;\n            fmtd.entry(&si.to_string(), &TransitionsRow(&self.table[s..e]));\n        }\n        fmtd.finish()\n    }\n}"],"dfa::TransitionsRow":["impl<'a> fmt::Debug for TransitionsRow<'a> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let mut fmtd = f.debug_map();\n        for (b, si) in self.0.iter().enumerate() {\n            match *si {\n                STATE_UNKNOWN => {}\n                STATE_DEAD => {\n                    fmtd.entry(&vb(b as usize), &\"DEAD\");\n                }\n                si => {\n                    fmtd.entry(&vb(b as usize), &si.to_string());\n                }\n            }\n        }\n        fmtd.finish()\n    }\n}"],"error::Error":["Clone","PartialEq","impl ::std::error::Error for Error {\n    // TODO: Remove this method entirely on the next breaking semver release.\n    #[allow(deprecated)]\n    fn description(&self) -> &str {\n        match *self {\n            Error::Syntax(ref err) => err,\n            Error::CompiledTooBig(_) => \"compiled program too big\",\n            Error::__Nonexhaustive => unreachable!(),\n        }\n    }\n}","impl fmt::Debug for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Error::Syntax(ref err) => {\n                let hr: String = repeat('~').take(79).collect();\n                writeln!(f, \"Syntax(\")?;\n                writeln!(f, \"{}\", hr)?;\n                writeln!(f, \"{}\", err)?;\n                writeln!(f, \"{}\", hr)?;\n                write!(f, \")\")?;\n                Ok(())\n            }\n            Error::CompiledTooBig(limit) => {\n                f.debug_tuple(\"CompiledTooBig\").field(&limit).finish()\n            }\n            Error::__Nonexhaustive => {\n                f.debug_tuple(\"__Nonexhaustive\").finish()\n            }\n        }\n    }\n}","impl fmt::Display for Error {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match *self {\n            Error::Syntax(ref err) => err.fmt(f),\n            Error::CompiledTooBig(limit) => write!(\n                f,\n                \"Compiled regex exceeds size limit of {} bytes.\",\n                limit\n            ),\n            Error::__Nonexhaustive => unreachable!(),\n        }\n    }\n}"],"exec::Exec":["Debug","impl Clone for Exec {\n    fn clone(&self) -> Exec {\n        let pool = ExecReadOnly::new_pool(&self.ro);\n        Exec { ro: self.ro.clone(), pool }\n    }\n}","impl Exec {\n    /// Get a searcher that isn't Sync.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn searcher(&self) -> ExecNoSync<'_> {\n        ExecNoSync {\n            ro: &self.ro, // a clone is too expensive here! (and not needed)\n            cache: self.pool.get(),\n        }\n    }\n\n    /// Get a searcher that isn't Sync and can match on &str.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn searcher_str(&self) -> ExecNoSyncStr<'_> {\n        ExecNoSyncStr(self.searcher())\n    }\n\n    /// Build a Regex from this executor.\n    pub fn into_regex(self) -> re_unicode::Regex {\n        re_unicode::Regex::from(self)\n    }\n\n    /// Build a RegexSet from this executor.\n    pub fn into_regex_set(self) -> re_set::unicode::RegexSet {\n        re_set::unicode::RegexSet::from(self)\n    }\n\n    /// Build a Regex from this executor that can match arbitrary bytes.\n    pub fn into_byte_regex(self) -> re_bytes::Regex {\n        re_bytes::Regex::from(self)\n    }\n\n    /// Build a RegexSet from this executor that can match arbitrary bytes.\n    pub fn into_byte_regex_set(self) -> re_set::bytes::RegexSet {\n        re_set::bytes::RegexSet::from(self)\n    }\n\n    /// The original regular expressions given by the caller that were\n    /// compiled.\n    pub fn regex_strings(&self) -> &[String] {\n        &self.ro.res\n    }\n\n    /// Return a slice of capture names.\n    ///\n    /// Any capture that isn't named is None.\n    pub fn capture_names(&self) -> &[Option<String>] {\n        &self.ro.nfa.captures\n    }\n\n    /// Return a reference to named groups mapping (from group name to\n    /// group position).\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {\n        &self.ro.nfa.capture_name_idx\n    }\n\n    /// If the number of capture groups in every match is always the same, then\n    /// return that number. Otherwise return `None`.\n    pub fn static_captures_len(&self) -> Option<usize> {\n        self.ro.nfa.static_captures_len\n    }\n}"],"exec::ExecBuilder":["impl ExecBuilder {\n    /// Create a regex execution builder.\n    ///\n    /// This uses default settings for everything except the regex itself,\n    /// which must be provided. Further knobs can be set by calling methods,\n    /// and then finally, `build` to actually create the executor.\n    pub fn new(re: &str) -> Self {\n        Self::new_many(&[re])\n    }\n\n    /// Like new, but compiles the union of the given regular expressions.\n    ///\n    /// Note that when compiling 2 or more regular expressions, capture groups\n    /// are completely unsupported. (This means both `find` and `captures`\n    /// won't work.)\n    pub fn new_many<I, S>(res: I) -> Self\n    where\n        S: AsRef<str>,\n        I: IntoIterator<Item = S>,\n    {\n        let mut opts = RegexOptions::default();\n        opts.pats = res.into_iter().map(|s| s.as_ref().to_owned()).collect();\n        Self::new_options(opts)\n    }\n\n    /// Create a regex execution builder.\n    pub fn new_options(opts: RegexOptions) -> Self {\n        ExecBuilder {\n            options: opts,\n            match_type: None,\n            bytes: false,\n            only_utf8: true,\n        }\n    }\n\n    /// Set the matching engine to be automatically determined.\n    ///\n    /// This is the default state and will apply whatever optimizations are\n    /// possible, such as running a DFA.\n    ///\n    /// This overrides whatever was previously set via the `nfa` or\n    /// `bounded_backtracking` methods.\n    pub fn automatic(mut self) -> Self {\n        self.match_type = None;\n        self\n    }\n\n    /// Sets the matching engine to use the NFA algorithm no matter what\n    /// optimizations are possible.\n    ///\n    /// This overrides whatever was previously set via the `automatic` or\n    /// `bounded_backtracking` methods.\n    pub fn nfa(mut self) -> Self {\n        self.match_type = Some(MatchType::Nfa(MatchNfaType::PikeVM));\n        self\n    }\n\n    /// Sets the matching engine to use a bounded backtracking engine no\n    /// matter what optimizations are possible.\n    ///\n    /// One must use this with care, since the bounded backtracking engine\n    /// uses memory proportion to `len(regex) * len(text)`.\n    ///\n    /// This overrides whatever was previously set via the `automatic` or\n    /// `nfa` methods.\n    pub fn bounded_backtracking(mut self) -> Self {\n        self.match_type = Some(MatchType::Nfa(MatchNfaType::Backtrack));\n        self\n    }\n\n    /// Compiles byte based programs for use with the NFA matching engines.\n    ///\n    /// By default, the NFA engines match on Unicode scalar values. They can\n    /// be made to use byte based programs instead. In general, the byte based\n    /// programs are slower because of a less efficient encoding of character\n    /// classes.\n    ///\n    /// Note that this does not impact DFA matching engines, which always\n    /// execute on bytes.\n    pub fn bytes(mut self, yes: bool) -> Self {\n        self.bytes = yes;\n        self\n    }\n\n    /// When disabled, the program compiled may match arbitrary bytes.\n    ///\n    /// When enabled (the default), all compiled programs exclusively match\n    /// valid UTF-8 bytes.\n    pub fn only_utf8(mut self, yes: bool) -> Self {\n        self.only_utf8 = yes;\n        self\n    }\n\n    /// Set the Unicode flag.\n    pub fn unicode(mut self, yes: bool) -> Self {\n        self.options.unicode = yes;\n        self\n    }\n\n    /// Parse the current set of patterns into their AST and extract literals.\n    fn parse(&self) -> Result<Parsed, Error> {\n        let mut exprs = Vec::with_capacity(self.options.pats.len());\n        let mut prefixes = Some(literal::Seq::empty());\n        let mut suffixes = Some(literal::Seq::empty());\n        let mut bytes = false;\n        let is_set = self.options.pats.len() > 1;\n        // If we're compiling a regex set and that set has any anchored\n        // expressions, then disable all literal optimizations.\n        for pat in &self.options.pats {\n            let mut parser = ParserBuilder::new()\n                .octal(self.options.octal)\n                .case_insensitive(self.options.case_insensitive)\n                .multi_line(self.options.multi_line)\n                .dot_matches_new_line(self.options.dot_matches_new_line)\n                .swap_greed(self.options.swap_greed)\n                .ignore_whitespace(self.options.ignore_whitespace)\n                .unicode(self.options.unicode)\n                .utf8(self.only_utf8)\n                .nest_limit(self.options.nest_limit)\n                .build();\n            let expr =\n                parser.parse(pat).map_err(|e| Error::Syntax(e.to_string()))?;\n            let props = expr.properties();\n            // This used to just check whether the HIR matched valid UTF-8\n            // or not, but in regex-syntax 0.7, we changed our definition of\n            // \"matches valid UTF-8\" to exclude zero-width matches. And in\n            // particular, previously, we considered WordAsciiNegate (that\n            // is '(?-u:\\B)') to be capable of matching invalid UTF-8. Our\n            // matcher engines were built under this assumption and fixing\n            // them is not worth it with the imminent plan to switch over to\n            // regex-automata. So for now, we retain the previous behavior by\n            // just explicitly treating the presence of a negated ASCII word\n            // boundary as forcing use to use a byte oriented automaton.\n            bytes = bytes\n                || !props.is_utf8()\n                || props.look_set().contains(Look::WordAsciiNegate);\n\n            if cfg!(feature = \"perf-literal\") {\n                if !props.look_set_prefix().contains(Look::Start)\n                    && props.look_set().contains(Look::Start)\n                {\n                    // Partial anchors unfortunately make it hard to use\n                    // prefixes, so disable them.\n                    prefixes = None;\n                } else if is_set\n                    && props.look_set_prefix_any().contains(Look::Start)\n                {\n                    // Regex sets with anchors do not go well with literal\n                    // optimizations.\n                    prefixes = None;\n                } else if props.look_set_prefix_any().contains_word() {\n                    // The new literal extractor ignores look-around while\n                    // the old one refused to extract prefixes from regexes\n                    // that began with a \\b. These old creaky regex internals\n                    // can't deal with it, so we drop it.\n                    prefixes = None;\n                } else if props.look_set_prefix_any().contains(Look::StartLF) {\n                    // Similar to the reasoning for word boundaries, this old\n                    // regex engine can't handle literal prefixes with '(?m:^)'\n                    // at the beginning of a regex.\n                    prefixes = None;\n                }\n\n                if !props.look_set_suffix().contains(Look::End)\n                    && props.look_set().contains(Look::End)\n                {\n                    // Partial anchors unfortunately make it hard to use\n                    // suffixes, so disable them.\n                    suffixes = None;\n                } else if is_set\n                    && props.look_set_suffix_any().contains(Look::End)\n                {\n                    // Regex sets with anchors do not go well with literal\n                    // optimizations.\n                    suffixes = None;\n                } else if props.look_set_suffix_any().contains_word() {\n                    // See the prefix case for reasoning here.\n                    suffixes = None;\n                } else if props.look_set_suffix_any().contains(Look::EndLF) {\n                    // See the prefix case for reasoning here.\n                    suffixes = None;\n                }\n\n                let (mut pres, mut suffs) =\n                    if prefixes.is_none() && suffixes.is_none() {\n                        (literal::Seq::infinite(), literal::Seq::infinite())\n                    } else {\n                        literal_analysis(&expr)\n                    };\n                // These old creaky regex internals can't handle cases where\n                // the literal sequences are exact but there are look-around\n                // assertions. So we make sure the sequences are inexact if\n                // there are look-around assertions anywhere. This forces the\n                // regex engines to run instead of assuming that a literal\n                // match implies an overall match.\n                if !props.look_set().is_empty() {\n                    pres.make_inexact();\n                    suffs.make_inexact();\n                }\n                prefixes = prefixes.and_then(|mut prefixes| {\n                    prefixes.union(&mut pres);\n                    Some(prefixes)\n                });\n                suffixes = suffixes.and_then(|mut suffixes| {\n                    suffixes.union(&mut suffs);\n                    Some(suffixes)\n                });\n            }\n            exprs.push(expr);\n        }\n        Ok(Parsed {\n            exprs,\n            prefixes: prefixes.unwrap_or_else(literal::Seq::empty),\n            suffixes: suffixes.unwrap_or_else(literal::Seq::empty),\n            bytes,\n        })\n    }\n\n    /// Build an executor that can run a regular expression.\n    pub fn build(self) -> Result<Exec, Error> {\n        // Special case when we have no patterns to compile.\n        // This can happen when compiling a regex set.\n        if self.options.pats.is_empty() {\n            let ro = Arc::new(ExecReadOnly {\n                res: vec![],\n                nfa: Program::new(),\n                dfa: Program::new(),\n                dfa_reverse: Program::new(),\n                suffixes: LiteralSearcher::empty(),\n                #[cfg(feature = \"perf-literal\")]\n                ac: None,\n                match_type: MatchType::Nothing,\n            });\n            let pool = ExecReadOnly::new_pool(&ro);\n            return Ok(Exec { ro, pool });\n        }\n        let parsed = self.parse()?;\n        let mut nfa = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .bytes(self.bytes || parsed.bytes)\n            .only_utf8(self.only_utf8)\n            .compile(&parsed.exprs)?;\n        let mut dfa = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .dfa(true)\n            .only_utf8(self.only_utf8)\n            .compile(&parsed.exprs)?;\n        let mut dfa_reverse = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .dfa(true)\n            .only_utf8(self.only_utf8)\n            .reverse(true)\n            .compile(&parsed.exprs)?;\n\n        #[cfg(feature = \"perf-literal\")]\n        let ac = self.build_aho_corasick(&parsed);\n        nfa.prefixes = LiteralSearcher::prefixes(parsed.prefixes);\n        dfa.prefixes = nfa.prefixes.clone();\n        dfa.dfa_size_limit = self.options.dfa_size_limit;\n        dfa_reverse.dfa_size_limit = self.options.dfa_size_limit;\n\n        let mut ro = ExecReadOnly {\n            res: self.options.pats,\n            nfa,\n            dfa,\n            dfa_reverse,\n            suffixes: LiteralSearcher::suffixes(parsed.suffixes),\n            #[cfg(feature = \"perf-literal\")]\n            ac,\n            match_type: MatchType::Nothing,\n        };\n        ro.match_type = ro.choose_match_type(self.match_type);\n\n        let ro = Arc::new(ro);\n        let pool = ExecReadOnly::new_pool(&ro);\n        Ok(Exec { ro, pool })\n    }\n\n    #[cfg(feature = \"perf-literal\")]\n    fn build_aho_corasick(&self, parsed: &Parsed) -> Option<AhoCorasick> {\n        if parsed.exprs.len() != 1 {\n            return None;\n        }\n        let lits = match alternation_literals(&parsed.exprs[0]) {\n            None => return None,\n            Some(lits) => lits,\n        };\n        // If we have a small number of literals, then let Teddy handle\n        // things (see literal/mod.rs).\n        if lits.len() <= 32 {\n            return None;\n        }\n        Some(\n            AhoCorasick::builder()\n                .match_kind(MatchKind::LeftmostFirst)\n                .build(&lits)\n                // This should never happen because we'd long exceed the\n                // compilation limit for regexes first.\n                .expect(\"AC automaton too big\"),\n        )\n    }\n}"],"exec::ExecNoSync":["Debug","impl<'c> ExecNoSync<'c> {\n    /// Finds the leftmost-first match using only literal search.\n    #[cfg(feature = \"perf-literal\")]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_literals(\n        &self,\n        ty: MatchLiteralType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        use self::MatchLiteralType::*;\n        match ty {\n            Unanchored => {\n                let lits = &self.ro.nfa.prefixes;\n                lits.find(&text[start..]).map(|(s, e)| (start + s, start + e))\n            }\n            AnchoredStart => {\n                let lits = &self.ro.nfa.prefixes;\n                if start == 0 || !self.ro.nfa.is_anchored_start {\n                    lits.find_start(&text[start..])\n                        .map(|(s, e)| (start + s, start + e))\n                } else {\n                    None\n                }\n            }\n            AnchoredEnd => {\n                let lits = &self.ro.suffixes;\n                lits.find_end(&text[start..])\n                    .map(|(s, e)| (start + s, start + e))\n            }\n            AhoCorasick => self\n                .ro\n                .ac\n                .as_ref()\n                .unwrap()\n                .find(&text[start..])\n                .map(|m| (start + m.start(), start + m.end())),\n        }\n    }\n\n    /// Finds the leftmost-first match (start and end) using only the DFA.\n    ///\n    /// If the result returned indicates that the DFA quit, then another\n    /// matching engine should be used.\n    #[cfg(feature = \"perf-dfa\")]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_dfa_forward(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use crate::dfa::Result::*;\n        let end = match dfa::Fsm::forward(\n            &self.ro.dfa,\n            self.cache.value(),\n            false,\n            text,\n            start,\n        ) {\n            NoMatch(i) => return NoMatch(i),\n            Quit => return Quit,\n            Match(end) if start == end => return Match((start, start)),\n            Match(end) => end,\n        };\n        // Now run the DFA in reverse to find the start of the match.\n        match dfa::Fsm::reverse(\n            &self.ro.dfa_reverse,\n            self.cache.value(),\n            false,\n            &text[start..],\n            end - start,\n        ) {\n            Match(s) => Match((start + s, end)),\n            NoMatch(i) => NoMatch(i),\n            Quit => Quit,\n        }\n    }\n\n    /// Finds the leftmost-first match (start and end) using only the DFA,\n    /// but assumes the regex is anchored at the end and therefore starts at\n    /// the end of the regex and matches in reverse.\n    ///\n    /// If the result returned indicates that the DFA quit, then another\n    /// matching engine should be used.\n    #[cfg(feature = \"perf-dfa\")]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_dfa_anchored_reverse(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use crate::dfa::Result::*;\n        match dfa::Fsm::reverse(\n            &self.ro.dfa_reverse,\n            self.cache.value(),\n            false,\n            &text[start..],\n            text.len() - start,\n        ) {\n            Match(s) => Match((start + s, text.len())),\n            NoMatch(i) => NoMatch(i),\n            Quit => Quit,\n        }\n    }\n\n    /// Finds the end of the shortest match using only the DFA.\n    #[cfg(feature = \"perf-dfa\")]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn shortest_dfa(&self, text: &[u8], start: usize) -> dfa::Result<usize> {\n        dfa::Fsm::forward(&self.ro.dfa, self.cache.value(), true, text, start)\n    }\n\n    /// Finds the end of the shortest match using only the DFA by scanning for\n    /// suffix literals.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn shortest_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<usize> {\n        match self.exec_dfa_reverse_suffix(text, start) {\n            None => self.shortest_dfa(text, start),\n            Some(r) => r.map(|(_, end)| end),\n        }\n    }\n\n    /// Finds the end of the shortest match using only the DFA by scanning for\n    /// suffix literals. It also reports the start of the match.\n    ///\n    /// Note that if None is returned, then the optimization gave up to avoid\n    /// worst case quadratic behavior. A forward scanning DFA should be tried\n    /// next.\n    ///\n    /// If a match is returned and the full leftmost-first match is desired,\n    /// then a forward scan starting from the beginning of the match must be\n    /// done.\n    ///\n    /// If the result returned indicates that the DFA quit, then another\n    /// matching engine should be used.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn exec_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        original_start: usize,\n    ) -> Option<dfa::Result<(usize, usize)>> {\n        use crate::dfa::Result::*;\n\n        let lcs = self.ro.suffixes.lcs();\n        debug_assert!(lcs.len() >= 1);\n        let mut start = original_start;\n        let mut end = start;\n        let mut last_literal = start;\n        while end <= text.len() {\n            last_literal += match lcs.find(&text[last_literal..]) {\n                None => return Some(NoMatch(text.len())),\n                Some(i) => i,\n            };\n            end = last_literal + lcs.len();\n            match dfa::Fsm::reverse(\n                &self.ro.dfa_reverse,\n                self.cache.value(),\n                false,\n                &text[start..end],\n                end - start,\n            ) {\n                Match(0) | NoMatch(0) => return None,\n                Match(i) => return Some(Match((start + i, end))),\n                NoMatch(i) => {\n                    start += i;\n                    last_literal += 1;\n                    continue;\n                }\n                Quit => return Some(Quit),\n            };\n        }\n        Some(NoMatch(text.len()))\n    }\n\n    /// Finds the leftmost-first match (start and end) using only the DFA\n    /// by scanning for suffix literals.\n    ///\n    /// If the result returned indicates that the DFA quit, then another\n    /// matching engine should be used.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)> {\n        use crate::dfa::Result::*;\n\n        let match_start = match self.exec_dfa_reverse_suffix(text, start) {\n            None => return self.find_dfa_forward(text, start),\n            Some(Match((start, _))) => start,\n            Some(r) => return r,\n        };\n        // At this point, we've found a match. The only way to quit now\n        // without a match is if the DFA gives up (seems unlikely).\n        //\n        // Now run the DFA forwards to find the proper end of the match.\n        // (The suffix literal match can only indicate the earliest\n        // possible end location, which may appear before the end of the\n        // leftmost-first match.)\n        match dfa::Fsm::forward(\n            &self.ro.dfa,\n            self.cache.value(),\n            false,\n            text,\n            match_start,\n        ) {\n            NoMatch(_) => panic!(\"BUG: reverse match implies forward match\"),\n            Quit => Quit,\n            Match(e) => Match((match_start, e)),\n        }\n    }\n\n    /// Executes the NFA engine to return whether there is a match or not.\n    ///\n    /// Ideally, we could use shortest_nfa(...).is_some() and get the same\n    /// performance characteristics, but regex sets don't have captures, which\n    /// shortest_nfa depends on.\n    #[cfg(feature = \"perf-dfa\")]\n    fn match_nfa(&self, text: &[u8], start: usize) -> bool {\n        self.match_nfa_type(MatchNfaType::Auto, text, start)\n    }\n\n    /// Like match_nfa, but allows specification of the type of NFA engine.\n    fn match_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> bool {\n        self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut [],\n            true,\n            false,\n            text,\n            start,\n            text.len(),\n        )\n    }\n\n    /// Finds the shortest match using an NFA.\n    #[cfg(feature = \"perf-dfa\")]\n    fn shortest_nfa(&self, text: &[u8], start: usize) -> Option<usize> {\n        self.shortest_nfa_type(MatchNfaType::Auto, text, start)\n    }\n\n    /// Like shortest_nfa, but allows specification of the type of NFA engine.\n    fn shortest_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize> {\n        let mut slots = [None, None];\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut slots,\n            true,\n            true,\n            text,\n            start,\n            text.len(),\n        ) {\n            slots[1]\n        } else {\n            None\n        }\n    }\n\n    /// Like find, but executes an NFA engine.\n    fn find_nfa(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        let mut slots = [None, None];\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut slots,\n            false,\n            false,\n            text,\n            start,\n            text.len(),\n        ) {\n            match (slots[0], slots[1]) {\n                (Some(s), Some(e)) => Some((s, e)),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }\n\n    /// Like find_nfa, but fills in captures.\n    ///\n    /// `slots` should have length equal to `2 * nfa.captures.len()`.\n    #[cfg(feature = \"perf-dfa\")]\n    fn captures_nfa(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        self.captures_nfa_type(\n            MatchNfaType::Auto,\n            slots,\n            text,\n            start,\n            text.len(),\n        )\n    }\n\n    /// Like captures_nfa, but allows specification of type of NFA engine.\n    fn captures_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> Option<(usize, usize)> {\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            slots,\n            false,\n            false,\n            text,\n            start,\n            end,\n        ) {\n            match (slots[0], slots[1]) {\n                (Some(s), Some(e)) => Some((s, e)),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }\n\n    fn exec_nfa(\n        &self,\n        mut ty: MatchNfaType,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        quit_after_match_with_pos: bool,\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool {\n        use self::MatchNfaType::*;\n        if let Auto = ty {\n            if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n                ty = Backtrack;\n            } else {\n                ty = PikeVM;\n            }\n        }\n        // The backtracker can't return the shortest match position as it is\n        // implemented today. So if someone calls `shortest_match` and we need\n        // to run an NFA, then use the PikeVM.\n        if quit_after_match_with_pos || ty == PikeVM {\n            self.exec_pikevm(\n                matches,\n                slots,\n                quit_after_match,\n                text,\n                start,\n                end,\n            )\n        } else {\n            self.exec_backtrack(matches, slots, text, start, end)\n        }\n    }\n\n    /// Always run the NFA algorithm.\n    fn exec_pikevm(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool {\n        if self.ro.nfa.uses_bytes() {\n            pikevm::Fsm::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                quit_after_match,\n                ByteInput::new(text, self.ro.nfa.only_utf8),\n                start,\n                end,\n            )\n        } else {\n            pikevm::Fsm::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                quit_after_match,\n                CharInput::new(text),\n                start,\n                end,\n            )\n        }\n    }\n\n    /// Always runs the NFA using bounded backtracking.\n    fn exec_backtrack(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool {\n        if self.ro.nfa.uses_bytes() {\n            backtrack::Bounded::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                ByteInput::new(text, self.ro.nfa.only_utf8),\n                start,\n                end,\n            )\n        } else {\n            backtrack::Bounded::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                CharInput::new(text),\n                start,\n                end,\n            )\n        }\n    }\n\n    /// Finds which regular expressions match the given text.\n    ///\n    /// `matches` should have length equal to the number of regexes being\n    /// searched.\n    ///\n    /// This is only useful when one wants to know which regexes in a set\n    /// match some text.\n    pub fn many_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: &[u8],\n        start: usize,\n    ) -> bool {\n        use self::MatchType::*;\n        if !self.is_anchor_end_match(text) {\n            return false;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            Literal(ty) => {\n                debug_assert_eq!(matches.len(), 1);\n                matches[0] = self.find_literals(ty, text, start).is_some();\n                matches[0]\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            Dfa | DfaAnchoredReverse | DfaMany => {\n                match dfa::Fsm::forward_many(\n                    &self.ro.dfa,\n                    self.cache.value(),\n                    matches,\n                    text,\n                    start,\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.exec_nfa(\n                        MatchNfaType::Auto,\n                        matches,\n                        &mut [],\n                        false,\n                        false,\n                        text,\n                        start,\n                        text.len(),\n                    ),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            DfaSuffix => {\n                match dfa::Fsm::forward_many(\n                    &self.ro.dfa,\n                    self.cache.value(),\n                    matches,\n                    text,\n                    start,\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.exec_nfa(\n                        MatchNfaType::Auto,\n                        matches,\n                        &mut [],\n                        false,\n                        false,\n                        text,\n                        start,\n                        text.len(),\n                    ),\n                }\n            }\n            Nfa(ty) => self.exec_nfa(\n                ty,\n                matches,\n                &mut [],\n                false,\n                false,\n                text,\n                start,\n                text.len(),\n            ),\n            Nothing => false,\n        }\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_anchor_end_match(&self, text: &[u8]) -> bool {\n        #[cfg(not(feature = \"perf-literal\"))]\n        fn imp(_: &ExecReadOnly, _: &[u8]) -> bool {\n            true\n        }\n\n        #[cfg(feature = \"perf-literal\")]\n        fn imp(ro: &ExecReadOnly, text: &[u8]) -> bool {\n            // Only do this check if the haystack is big (>1MB).\n            if text.len() > (1 << 20) && ro.nfa.is_anchored_end {\n                let lcs = ro.suffixes.lcs();\n                if lcs.len() >= 1 && !lcs.is_suffix(text) {\n                    return false;\n                }\n            }\n            true\n        }\n\n        imp(&self.ro, text)\n    }\n\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {\n        &self.ro.nfa.capture_name_idx\n    }\n}","impl<'c> RegularExpression for ExecNoSync<'c> {\n    type Text = [u8];\n\n    /// Returns the number of capture slots in the regular expression. (There\n    /// are two slots for every capture group, corresponding to possibly empty\n    /// start and end locations of the capture.)\n    fn slots_len(&self) -> usize {\n        self.ro.nfa.captures.len() * 2\n    }\n\n    fn next_after_empty(&self, _text: &[u8], i: usize) -> usize {\n        i + 1\n    }\n\n    /// Returns the end of a match location, possibly occurring before the\n    /// end location of the correct leftmost-first match.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn shortest_match_at(&self, text: &[u8], start: usize) -> Option<usize> {\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).map(|(_, e)| e)\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa | MatchType::DfaMany => {\n                match self.shortest_dfa(text, start) {\n                    dfa::Result::Match(end) => Some(end),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache.value(),\n                    true,\n                    &text[start..],\n                    text.len() - start,\n                ) {\n                    dfa::Result::Match(_) => Some(text.len()),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.shortest_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match(e) => Some(e),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            MatchType::Nfa(ty) => self.shortest_nfa_type(ty, text, start),\n            MatchType::Nothing => None,\n        }\n    }\n\n    /// Returns true if and only if the regex matches text.\n    ///\n    /// For single regular expressions, this is equivalent to calling\n    /// shortest_match(...).is_some().\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_match_at(&self, text: &[u8], start: usize) -> bool {\n        if !self.is_anchor_end_match(text) {\n            return false;\n        }\n        // We need to do this dance because shortest_match relies on the NFA\n        // filling in captures[1], but a RegexSet has no captures. In other\n        // words, a RegexSet can't (currently) use shortest_match. ---AG\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).is_some()\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa | MatchType::DfaMany => {\n                match self.shortest_dfa(text, start) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache.value(),\n                    true,\n                    &text[start..],\n                    text.len() - start,\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.shortest_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            MatchType::Nfa(ty) => self.match_nfa_type(ty, text, start),\n            MatchType::Nothing => false,\n        }\n    }\n\n    /// Finds the start and end location of the leftmost-first match, starting\n    /// at the given location.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_at(&self, text: &[u8], start: usize) -> Option<(usize, usize)> {\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => self.find_literals(ty, text, start),\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa => match self.find_dfa_forward(text, start) {\n                dfa::Result::Match((s, e)) => Some((s, e)),\n                dfa::Result::NoMatch(_) => None,\n                dfa::Result::Quit => {\n                    self.find_nfa(MatchNfaType::Auto, text, start)\n                }\n            },\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match self.find_dfa_anchored_reverse(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => {\n                        self.find_nfa(MatchNfaType::Auto, text, start)\n                    }\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.find_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => {\n                        self.find_nfa(MatchNfaType::Auto, text, start)\n                    }\n                }\n            }\n            MatchType::Nfa(ty) => self.find_nfa(ty, text, start),\n            MatchType::Nothing => None,\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaMany => {\n                unreachable!(\"BUG: RegexSet cannot be used with find\")\n            }\n        }\n    }\n\n    /// Finds the start and end location of the leftmost-first match and also\n    /// fills in all matching capture groups.\n    ///\n    /// The number of capture slots given should be equal to the total number\n    /// of capture slots in the compiled program.\n    ///\n    /// Note that the first two slots always correspond to the start and end\n    /// locations of the overall match.\n    fn captures_read_at(\n        &self,\n        locs: &mut Locations,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        let slots = locs.as_slots();\n        for slot in slots.iter_mut() {\n            *slot = None;\n        }\n        // If the caller unnecessarily uses this, then we try to save them\n        // from themselves.\n        match slots.len() {\n            0 => return self.find_at(text, start),\n            2 => {\n                return self.find_at(text, start).map(|(s, e)| {\n                    slots[0] = Some(s);\n                    slots[1] = Some(e);\n                    (s, e)\n                });\n            }\n            _ => {} // fallthrough\n        }\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).and_then(|(s, e)| {\n                    self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    )\n                })\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa => {\n                if self.ro.nfa.is_anchored_start {\n                    self.captures_nfa(slots, text, start)\n                } else {\n                    match self.find_dfa_forward(text, start) {\n                        dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                            MatchNfaType::Auto,\n                            slots,\n                            text,\n                            s,\n                            e,\n                        ),\n                        dfa::Result::NoMatch(_) => None,\n                        dfa::Result::Quit => {\n                            self.captures_nfa(slots, text, start)\n                        }\n                    }\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match self.find_dfa_anchored_reverse(text, start) {\n                    dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    ),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.captures_nfa(slots, text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.find_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    ),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.captures_nfa(slots, text, start),\n                }\n            }\n            MatchType::Nfa(ty) => {\n                self.captures_nfa_type(ty, slots, text, start, text.len())\n            }\n            MatchType::Nothing => None,\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaMany => {\n                unreachable!(\"BUG: RegexSet cannot be used with captures\")\n            }\n        }\n    }\n}"],"exec::ExecNoSyncStr":["Debug","impl<'c> ExecNoSyncStr<'c> {\n    pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>> {\n        self.0.capture_name_idx()\n    }\n}","impl<'c> RegularExpression for ExecNoSyncStr<'c> {\n    type Text = str;\n\n    fn slots_len(&self) -> usize {\n        self.0.slots_len()\n    }\n\n    fn next_after_empty(&self, text: &str, i: usize) -> usize {\n        next_utf8(text.as_bytes(), i)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn shortest_match_at(&self, text: &str, start: usize) -> Option<usize> {\n        self.0.shortest_match_at(text.as_bytes(), start)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn is_match_at(&self, text: &str, start: usize) -> bool {\n        self.0.is_match_at(text.as_bytes(), start)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find_at(&self, text: &str, start: usize) -> Option<(usize, usize)> {\n        self.0.find_at(text.as_bytes(), start)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn captures_read_at(\n        &self,\n        locs: &mut Locations,\n        text: &str,\n        start: usize,\n    ) -> Option<(usize, usize)> {\n        self.0.captures_read_at(locs, text.as_bytes(), start)\n    }\n}"],"exec::ExecReadOnly":["Debug","impl ExecReadOnly {\n    fn choose_match_type(&self, hint: Option<MatchType>) -> MatchType {\n        if let Some(MatchType::Nfa(_)) = hint {\n            return hint.unwrap();\n        }\n        // If the NFA is empty, then we'll never match anything.\n        if self.nfa.insts.is_empty() {\n            return MatchType::Nothing;\n        }\n        if let Some(literalty) = self.choose_literal_match_type() {\n            return literalty;\n        }\n        if let Some(dfaty) = self.choose_dfa_match_type() {\n            return dfaty;\n        }\n        // We're so totally hosed.\n        MatchType::Nfa(MatchNfaType::Auto)\n    }\n\n    /// If a plain literal scan can be used, then a corresponding literal\n    /// search type is returned.\n    fn choose_literal_match_type(&self) -> Option<MatchType> {\n        #[cfg(not(feature = \"perf-literal\"))]\n        fn imp(_: &ExecReadOnly) -> Option<MatchType> {\n            None\n        }\n\n        #[cfg(feature = \"perf-literal\")]\n        fn imp(ro: &ExecReadOnly) -> Option<MatchType> {\n            // If our set of prefixes is complete, then we can use it to find\n            // a match in lieu of a regex engine. This doesn't quite work well\n            // in the presence of multiple regexes, so only do it when there's\n            // one.\n            //\n            // TODO(burntsushi): Also, don't try to match literals if the regex\n            // is partially anchored. We could technically do it, but we'd need\n            // to create two sets of literals: all of them and then the subset\n            // that aren't anchored. We would then only search for all of them\n            // when at the beginning of the input and use the subset in all\n            // other cases.\n            if ro.res.len() != 1 {\n                return None;\n            }\n            if ro.ac.is_some() {\n                return Some(MatchType::Literal(\n                    MatchLiteralType::AhoCorasick,\n                ));\n            }\n            if ro.nfa.prefixes.complete() {\n                return if ro.nfa.is_anchored_start {\n                    Some(MatchType::Literal(MatchLiteralType::AnchoredStart))\n                } else {\n                    Some(MatchType::Literal(MatchLiteralType::Unanchored))\n                };\n            }\n            if ro.suffixes.complete() {\n                return if ro.nfa.is_anchored_end {\n                    Some(MatchType::Literal(MatchLiteralType::AnchoredEnd))\n                } else {\n                    // This case shouldn't happen. When the regex isn't\n                    // anchored, then complete prefixes should imply complete\n                    // suffixes.\n                    //\n                    // The above is wrong! This case can happen. While\n                    // complete prefixes should imply complete suffixes\n                    // here, that doesn't necessarily mean we have a useful\n                    // prefix matcher! It could be the case that the literal\n                    // searcher decided the prefixes---even though they are\n                    // \"complete\"---weren't good enough and thus created an\n                    // empty matcher. If that happens and we return Unanchored\n                    // here, then we'll end up using that matcher, which is\n                    // very bad because it matches at every position. So...\n                    // return None.\n                    None\n                };\n            }\n            None\n        }\n\n        imp(self)\n    }\n\n    /// If a DFA scan can be used, then choose the appropriate DFA strategy.\n    fn choose_dfa_match_type(&self) -> Option<MatchType> {\n        #[cfg(not(feature = \"perf-dfa\"))]\n        fn imp(_: &ExecReadOnly) -> Option<MatchType> {\n            None\n        }\n\n        #[cfg(feature = \"perf-dfa\")]\n        fn imp(ro: &ExecReadOnly) -> Option<MatchType> {\n            if !dfa::can_exec(&ro.dfa) {\n                return None;\n            }\n            // Regex sets require a slightly specialized path.\n            if ro.res.len() >= 2 {\n                return Some(MatchType::DfaMany);\n            }\n            // If the regex is anchored at the end but not the start, then\n            // just match in reverse from the end of the haystack.\n            if !ro.nfa.is_anchored_start && ro.nfa.is_anchored_end {\n                return Some(MatchType::DfaAnchoredReverse);\n            }\n            #[cfg(feature = \"perf-literal\")]\n            {\n                // If there's a longish suffix literal, then it might be faster\n                // to look for that first.\n                if ro.should_suffix_scan() {\n                    return Some(MatchType::DfaSuffix);\n                }\n            }\n            // Fall back to your garden variety forward searching lazy DFA.\n            Some(MatchType::Dfa)\n        }\n\n        imp(self)\n    }\n\n    /// Returns true if the program is amenable to suffix scanning.\n    ///\n    /// When this is true, as a heuristic, we assume it is OK to quickly scan\n    /// for suffix literals and then do a *reverse* DFA match from any matches\n    /// produced by the literal scan. (And then followed by a forward DFA\n    /// search, since the previously found suffix literal maybe not actually be\n    /// the end of a match.)\n    ///\n    /// This is a bit of a specialized optimization, but can result in pretty\n    /// big performance wins if 1) there are no prefix literals and 2) the\n    /// suffix literals are pretty rare in the text. (1) is obviously easy to\n    /// account for but (2) is harder. As a proxy, we assume that longer\n    /// strings are generally rarer, so we only enable this optimization when\n    /// we have a meaty suffix.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    fn should_suffix_scan(&self) -> bool {\n        if self.suffixes.is_empty() {\n            return false;\n        }\n        let lcs_len = self.suffixes.lcs().char_len();\n        lcs_len >= 3 && lcs_len > self.dfa.prefixes.lcp().char_len()\n    }\n\n    fn new_pool(ro: &Arc<ExecReadOnly>) -> Box<Pool<ProgramCache>> {\n        let ro = ro.clone();\n        Box::new(Pool::new(Box::new(move || {\n            AssertUnwindSafe(RefCell::new(ProgramCacheInner::new(&ro)))\n        })))\n    }\n}"],"exec::MatchLiteralType":["Clone","Copy","Debug"],"exec::MatchNfaType":["Clone","Copy","Debug","Eq","PartialEq"],"exec::MatchType":["Clone","Copy","Debug"],"exec::ProgramCacheInner":["Debug","impl ProgramCacheInner {\n    fn new(ro: &ExecReadOnly) -> Self {\n        ProgramCacheInner {\n            pikevm: pikevm::Cache::new(&ro.nfa),\n            backtrack: backtrack::Cache::new(&ro.nfa),\n            #[cfg(feature = \"perf-dfa\")]\n            dfa: dfa::Cache::new(&ro.dfa),\n            #[cfg(feature = \"perf-dfa\")]\n            dfa_reverse: dfa::Cache::new(&ro.dfa_reverse),\n        }\n    }\n}"],"expand::CaptureRef":["Clone","Copy","Debug","Eq","PartialEq"],"expand::Ref":["Clone","Copy","Debug","Eq","PartialEq","impl From<usize> for Ref<'static> {\n    fn from(x: usize) -> Ref<'static> {\n        Ref::Number(x)\n    }\n}","impl<'a> From<&'a str> for Ref<'a> {\n    fn from(x: &'a str) -> Ref<'a> {\n        Ref::Named(x)\n    }\n}"],"input::ByteInput":["Clone","Copy","Debug","impl<'t> ByteInput<'t> {\n    /// Return a new byte-based input reader for the given string.\n    pub fn new(text: &'t [u8], only_utf8: bool) -> ByteInput<'t> {\n        ByteInput { text, only_utf8 }\n    }\n}","impl<'t> Input for ByteInput<'t> {\n    fn at(&self, i: usize) -> InputAt {\n        if i >= self.len() {\n            InputAt { pos: self.len(), c: None.into(), byte: None, len: 0 }\n        } else {\n            InputAt {\n                pos: i,\n                c: None.into(),\n                byte: self.get(i).cloned(),\n                len: 1,\n            }\n        }\n    }\n\n    fn next_char(&self, at: InputAt) -> Char {\n        decode_utf8(&self[at.pos()..]).map(|(c, _)| c).into()\n    }\n\n    fn previous_char(&self, at: InputAt) -> Char {\n        decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    }\n\n    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {\n        use crate::prog::EmptyLook::*;\n        match empty.look {\n            StartLine => {\n                let c = self.previous_char(at);\n                at.pos() == 0 || c == '\\n'\n            }\n            EndLine => {\n                let c = self.next_char(at);\n                at.pos() == self.len() || c == '\\n'\n            }\n            StartText => at.pos() == 0,\n            EndText => at.pos() == self.len(),\n            WordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() != c2.is_word_char()\n            }\n            NotWordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() == c2.is_word_char()\n            }\n            WordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                if self.only_utf8 {\n                    // If we must match UTF-8, then we can't match word\n                    // boundaries at invalid UTF-8.\n                    if c1.is_none() && !at.is_start() {\n                        return false;\n                    }\n                    if c2.is_none() && !at.is_end() {\n                        return false;\n                    }\n                }\n                c1.is_word_byte() != c2.is_word_byte()\n            }\n            NotWordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                if self.only_utf8 {\n                    // If we must match UTF-8, then we can't match word\n                    // boundaries at invalid UTF-8.\n                    if c1.is_none() && !at.is_start() {\n                        return false;\n                    }\n                    if c2.is_none() && !at.is_end() {\n                        return false;\n                    }\n                }\n                c1.is_word_byte() == c2.is_word_byte()\n            }\n        }\n    }\n\n    fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt> {\n        prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    }\n\n    fn len(&self) -> usize {\n        self.text.len()\n    }\n\n    fn as_bytes(&self) -> &[u8] {\n        self.text\n    }\n}","impl<'t> ops::Deref for ByteInput<'t> {\n    type Target = [u8];\n\n    fn deref(&self) -> &[u8] {\n        self.text\n    }\n}"],"input::Char":["Clone","Copy","Eq","Hash","Ord","PartialEq","PartialOrd","impl Char {\n    /// Returns true iff the character is absent.\n    #[inline]\n    pub fn is_none(self) -> bool {\n        self.0 == u32::MAX\n    }\n\n    /// Returns the length of the character's UTF-8 encoding.\n    ///\n    /// If the character is absent, then `1` is returned.\n    #[inline]\n    pub fn len_utf8(self) -> usize {\n        char::from_u32(self.0).map_or(1, |c| c.len_utf8())\n    }\n\n    /// Returns true iff the character is a word character.\n    ///\n    /// If the character is absent, then false is returned.\n    pub fn is_word_char(self) -> bool {\n        // is_word_character can panic if the Unicode data for \\w isn't\n        // available. However, our compiler ensures that if a Unicode word\n        // boundary is used, then the data must also be available. If it isn't,\n        // then the compiler returns an error.\n        char::from_u32(self.0).map_or(false, regex_syntax::is_word_character)\n    }\n\n    /// Returns true iff the byte is a word byte.\n    ///\n    /// If the byte is absent, then false is returned.\n    pub fn is_word_byte(self) -> bool {\n        match char::from_u32(self.0) {\n            Some(c) if c <= '\\u{7F}' => regex_syntax::is_word_byte(c as u8),\n            None | Some(_) => false,\n        }\n    }\n}","impl From<Option<char>> for Char {\n    fn from(c: Option<char>) -> Char {\n        c.map_or(Char(u32::MAX), |c| c.into())\n    }\n}","impl From<char> for Char {\n    fn from(c: char) -> Char {\n        Char(c as u32)\n    }\n}","impl PartialEq<char> for Char {\n    #[inline]\n    fn eq(&self, other: &char) -> bool {\n        self.0 == *other as u32\n    }\n}","impl PartialOrd<char> for Char {\n    #[inline]\n    fn partial_cmp(&self, other: &char) -> Option<Ordering> {\n        self.0.partial_cmp(&(*other as u32))\n    }\n}","impl fmt::Debug for Char {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match char::from_u32(self.0) {\n            None => write!(f, \"Empty\"),\n            Some(c) => write!(f, \"{:?}\", c),\n        }\n    }\n}"],"input::CharInput":["Clone","Copy","Debug","impl<'t> CharInput<'t> {\n    /// Return a new character input reader for the given string.\n    pub fn new(s: &'t [u8]) -> CharInput<'t> {\n        CharInput(s)\n    }\n}","impl<'t> Input for CharInput<'t> {\n    fn at(&self, i: usize) -> InputAt {\n        if i >= self.len() {\n            InputAt { pos: self.len(), c: None.into(), byte: None, len: 0 }\n        } else {\n            let c = decode_utf8(&self[i..]).map(|(c, _)| c).into();\n            InputAt { pos: i, c, byte: None, len: c.len_utf8() }\n        }\n    }\n\n    fn next_char(&self, at: InputAt) -> Char {\n        at.char()\n    }\n\n    fn previous_char(&self, at: InputAt) -> Char {\n        decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    }\n\n    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool {\n        use crate::prog::EmptyLook::*;\n        match empty.look {\n            StartLine => {\n                let c = self.previous_char(at);\n                at.pos() == 0 || c == '\\n'\n            }\n            EndLine => {\n                let c = self.next_char(at);\n                at.pos() == self.len() || c == '\\n'\n            }\n            StartText => at.pos() == 0,\n            EndText => at.pos() == self.len(),\n            WordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() != c2.is_word_char()\n            }\n            NotWordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() == c2.is_word_char()\n            }\n            WordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_byte() != c2.is_word_byte()\n            }\n            NotWordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_byte() == c2.is_word_byte()\n            }\n        }\n    }\n\n    fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt> {\n        prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    }\n\n    fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    fn as_bytes(&self) -> &[u8] {\n        self.0\n    }\n}","impl<'t> ops::Deref for CharInput<'t> {\n    type Target = [u8];\n\n    fn deref(&self) -> &[u8] {\n        self.0\n    }\n}"],"input::InputAt":["Clone","Copy","Debug","impl InputAt {\n    /// Returns true iff this position is at the beginning of the input.\n    pub fn is_start(&self) -> bool {\n        self.pos == 0\n    }\n\n    /// Returns true iff this position is past the end of the input.\n    pub fn is_end(&self) -> bool {\n        self.c.is_none() && self.byte.is_none()\n    }\n\n    /// Returns the character at this position.\n    ///\n    /// If this position is just before or after the input, then an absent\n    /// character is returned.\n    pub fn char(&self) -> Char {\n        self.c\n    }\n\n    /// Returns the byte at this position.\n    pub fn byte(&self) -> Option<u8> {\n        self.byte\n    }\n\n    /// Returns the UTF-8 width of the character at this position.\n    pub fn len(&self) -> usize {\n        self.len\n    }\n\n    /// Returns whether the UTF-8 width of the character at this position\n    /// is zero.\n    pub fn is_empty(&self) -> bool {\n        self.len == 0\n    }\n\n    /// Returns the byte offset of this position.\n    pub fn pos(&self) -> usize {\n        self.pos\n    }\n\n    /// Returns the byte offset of the next position in the input.\n    pub fn next_pos(&self) -> usize {\n        self.pos + self.len\n    }\n}"],"literal::imp::LiteralIter":["Debug","impl<'a> Iterator for LiteralIter<'a> {\n    type Item = &'a [u8];\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match *self {\n            LiteralIter::Empty => None,\n            LiteralIter::Bytes(ref mut many) => {\n                if many.is_empty() {\n                    None\n                } else {\n                    let next = &many[0..1];\n                    *many = &many[1..];\n                    Some(next)\n                }\n            }\n            LiteralIter::Single(ref mut one) => {\n                if one.is_empty() {\n                    None\n                } else {\n                    let next = &one[..];\n                    *one = &[];\n                    Some(next)\n                }\n            }\n            LiteralIter::AC(ref mut lits) => {\n                if lits.is_empty() {\n                    None\n                } else {\n                    let next = &lits[0];\n                    *lits = &lits[1..];\n                    Some(next.as_bytes())\n                }\n            }\n            LiteralIter::Packed(ref mut lits) => {\n                if lits.is_empty() {\n                    None\n                } else {\n                    let next = &lits[0];\n                    *lits = &lits[1..];\n                    Some(next.as_bytes())\n                }\n            }\n        }\n    }\n}"],"literal::imp::LiteralSearcher":["Clone","Debug","impl LiteralSearcher {\n    /// Returns a matcher that never matches and never advances the input.\n    pub fn empty() -> Self {\n        Self::new(Seq::infinite(), Matcher::Empty)\n    }\n\n    /// Returns a matcher for literal prefixes from the given set.\n    pub fn prefixes(lits: Seq) -> Self {\n        let matcher = Matcher::prefixes(&lits);\n        Self::new(lits, matcher)\n    }\n\n    /// Returns a matcher for literal suffixes from the given set.\n    pub fn suffixes(lits: Seq) -> Self {\n        let matcher = Matcher::suffixes(&lits);\n        Self::new(lits, matcher)\n    }\n\n    fn new(lits: Seq, matcher: Matcher) -> Self {\n        LiteralSearcher {\n            complete: lits.is_exact(),\n            lcp: Memmem::new(lits.longest_common_prefix().unwrap_or(b\"\")),\n            lcs: Memmem::new(lits.longest_common_suffix().unwrap_or(b\"\")),\n            matcher,\n        }\n    }\n\n    /// Returns true if all matches comprise the entire regular expression.\n    ///\n    /// This does not necessarily mean that a literal match implies a match\n    /// of the regular expression. For example, the regular expression `^a`\n    /// is comprised of a single complete literal `a`, but the regular\n    /// expression demands that it only match at the beginning of a string.\n    pub fn complete(&self) -> bool {\n        self.complete && !self.is_empty()\n    }\n\n    /// Find the position of a literal in `haystack` if it exists.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn find(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => Some((0, 0)),\n            Bytes(ref sset) => sset.find(haystack).map(|i| (i, i + 1)),\n            Memmem(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n            AC { ref ac, .. } => {\n                ac.find(haystack).map(|m| (m.start(), m.end()))\n            }\n            Packed { ref s, .. } => {\n                s.find(haystack).map(|m| (m.start(), m.end()))\n            }\n        }\n    }\n\n    /// Like find, except matches must start at index `0`.\n    pub fn find_start(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        for lit in self.iter() {\n            if lit.len() > haystack.len() {\n                continue;\n            }\n            if lit == &haystack[0..lit.len()] {\n                return Some((0, lit.len()));\n            }\n        }\n        None\n    }\n\n    /// Like find, except matches must end at index `haystack.len()`.\n    pub fn find_end(&self, haystack: &[u8]) -> Option<(usize, usize)> {\n        for lit in self.iter() {\n            if lit.len() > haystack.len() {\n                continue;\n            }\n            if lit == &haystack[haystack.len() - lit.len()..] {\n                return Some((haystack.len() - lit.len(), haystack.len()));\n            }\n        }\n        None\n    }\n\n    /// Returns an iterator over all literals to be matched.\n    pub fn iter(&self) -> LiteralIter<'_> {\n        match self.matcher {\n            Matcher::Empty => LiteralIter::Empty,\n            Matcher::Bytes(ref sset) => LiteralIter::Bytes(&sset.dense),\n            Matcher::Memmem(ref s) => LiteralIter::Single(&s.finder.needle()),\n            Matcher::AC { ref lits, .. } => LiteralIter::AC(lits),\n            Matcher::Packed { ref lits, .. } => LiteralIter::Packed(lits),\n        }\n    }\n\n    /// Returns a matcher for the longest common prefix of this matcher.\n    pub fn lcp(&self) -> &Memmem {\n        &self.lcp\n    }\n\n    /// Returns a matcher for the longest common suffix of this matcher.\n    pub fn lcs(&self) -> &Memmem {\n        &self.lcs\n    }\n\n    /// Returns true iff this prefix is empty.\n    pub fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Returns the number of prefixes in this machine.\n    pub fn len(&self) -> usize {\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => 0,\n            Bytes(ref sset) => sset.dense.len(),\n            Memmem(_) => 1,\n            AC { ref ac, .. } => ac.patterns_len(),\n            Packed { ref lits, .. } => lits.len(),\n        }\n    }\n\n    /// Return the approximate heap usage of literals in bytes.\n    pub fn approximate_size(&self) -> usize {\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => 0,\n            Bytes(ref sset) => sset.approximate_size(),\n            Memmem(ref single) => single.approximate_size(),\n            AC { ref ac, .. } => ac.memory_usage(),\n            Packed { ref s, .. } => s.memory_usage(),\n        }\n    }\n}"],"literal::imp::Matcher":["Clone","Debug","impl Matcher {\n    fn prefixes(lits: &Seq) -> Self {\n        let sset = SingleByteSet::prefixes(lits);\n        Matcher::new(lits, sset)\n    }\n\n    fn suffixes(lits: &Seq) -> Self {\n        let sset = SingleByteSet::suffixes(lits);\n        Matcher::new(lits, sset)\n    }\n\n    fn new(lits: &Seq, sset: SingleByteSet) -> Self {\n        if lits.is_empty() || lits.min_literal_len() == Some(0) {\n            return Matcher::Empty;\n        }\n        let lits = match lits.literals() {\n            None => return Matcher::Empty,\n            Some(members) => members,\n        };\n        if sset.dense.len() >= 26 {\n            // Avoid trying to match a large number of single bytes.\n            // This is *very* sensitive to a frequency analysis comparison\n            // between the bytes in sset and the composition of the haystack.\n            // No matter the size of sset, if its members all are rare in the\n            // haystack, then it'd be worth using it. How to tune this... IDK.\n            // ---AG\n            return Matcher::Empty;\n        }\n        if sset.complete {\n            return Matcher::Bytes(sset);\n        }\n        if lits.len() == 1 {\n            return Matcher::Memmem(Memmem::new(lits[0].as_bytes()));\n        }\n\n        let pats: Vec<&[u8]> = lits.iter().map(|lit| lit.as_bytes()).collect();\n        let is_aho_corasick_fast = sset.dense.len() <= 1 && sset.all_ascii;\n        if lits.len() <= 100 && !is_aho_corasick_fast {\n            let mut builder = packed::Config::new()\n                .match_kind(packed::MatchKind::LeftmostFirst)\n                .builder();\n            if let Some(s) = builder.extend(&pats).build() {\n                return Matcher::Packed { s, lits: lits.to_owned() };\n            }\n        }\n        let ac = AhoCorasick::builder()\n            .match_kind(aho_corasick::MatchKind::LeftmostFirst)\n            .kind(Some(aho_corasick::AhoCorasickKind::DFA))\n            .build(&pats)\n            .unwrap();\n        Matcher::AC { ac, lits: lits.to_owned() }\n    }\n}"],"literal::imp::Memmem":["Clone","Debug","impl Memmem {\n    fn new(pat: &[u8]) -> Memmem {\n        Memmem {\n            finder: memmem::Finder::new(pat).into_owned(),\n            char_len: char_len_lossy(pat),\n        }\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn find(&self, haystack: &[u8]) -> Option<usize> {\n        self.finder.find(haystack)\n    }\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn is_suffix(&self, text: &[u8]) -> bool {\n        if text.len() < self.len() {\n            return false;\n        }\n        &text[text.len() - self.len()..] == self.finder.needle()\n    }\n\n    pub fn len(&self) -> usize {\n        self.finder.needle().len()\n    }\n\n    pub fn char_len(&self) -> usize {\n        self.char_len\n    }\n\n    fn approximate_size(&self) -> usize {\n        self.finder.needle().len() * mem::size_of::<u8>()\n    }\n}"],"literal::imp::SingleByteSet":["Clone","Debug","impl SingleByteSet {\n    fn new() -> SingleByteSet {\n        SingleByteSet {\n            sparse: vec![false; 256],\n            dense: vec![],\n            complete: true,\n            all_ascii: true,\n        }\n    }\n\n    fn prefixes(lits: &Seq) -> SingleByteSet {\n        let mut sset = SingleByteSet::new();\n        let lits = match lits.literals() {\n            None => return sset,\n            Some(lits) => lits,\n        };\n        for lit in lits.iter() {\n            sset.complete = sset.complete && lit.len() == 1;\n            if let Some(&b) = lit.as_bytes().get(0) {\n                if !sset.sparse[b as usize] {\n                    if b > 0x7F {\n                        sset.all_ascii = false;\n                    }\n                    sset.dense.push(b);\n                    sset.sparse[b as usize] = true;\n                }\n            }\n        }\n        sset\n    }\n\n    fn suffixes(lits: &Seq) -> SingleByteSet {\n        let mut sset = SingleByteSet::new();\n        let lits = match lits.literals() {\n            None => return sset,\n            Some(lits) => lits,\n        };\n        for lit in lits.iter() {\n            sset.complete = sset.complete && lit.len() == 1;\n            if let Some(&b) = lit.as_bytes().last() {\n                if !sset.sparse[b as usize] {\n                    if b > 0x7F {\n                        sset.all_ascii = false;\n                    }\n                    sset.dense.push(b);\n                    sset.sparse[b as usize] = true;\n                }\n            }\n        }\n        sset\n    }\n\n    /// Faster find that special cases certain sizes to use memchr.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn find(&self, text: &[u8]) -> Option<usize> {\n        match self.dense.len() {\n            0 => None,\n            1 => memchr(self.dense[0], text),\n            2 => memchr2(self.dense[0], self.dense[1], text),\n            3 => memchr3(self.dense[0], self.dense[1], self.dense[2], text),\n            _ => self._find(text),\n        }\n    }\n\n    /// Generic find that works on any sized set.\n    fn _find(&self, haystack: &[u8]) -> Option<usize> {\n        for (i, &b) in haystack.iter().enumerate() {\n            if self.sparse[b as usize] {\n                return Some(i);\n            }\n        }\n        None\n    }\n\n    fn approximate_size(&self) -> usize {\n        (self.dense.len() * mem::size_of::<u8>())\n            + (self.sparse.len() * mem::size_of::<bool>())\n    }\n}"],"pikevm::Cache":["Clone","Debug","impl Cache {\n    /// Create a new allocation used by the NFA machine to record execution\n    /// and captures.\n    pub fn new(_prog: &Program) -> Self {\n        Cache { clist: Threads::new(), nlist: Threads::new(), stack: vec![] }\n    }\n}"],"pikevm::FollowEpsilon":["Clone","Debug"],"pikevm::Fsm":["Debug","impl<'r, I: Input> Fsm<'r, I> {\n    /// Execute the NFA matching engine.\n    ///\n    /// If there's a match, `exec` returns `true` and populates the given\n    /// captures accordingly.\n    pub fn exec(\n        prog: &'r Program,\n        cache: &ProgramCache,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        input: I,\n        start: usize,\n        end: usize,\n    ) -> bool {\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.pikevm;\n        cache.clist.resize(prog.len(), prog.captures.len());\n        cache.nlist.resize(prog.len(), prog.captures.len());\n        let at = input.at(start);\n        Fsm { prog, stack: &mut cache.stack, input }.exec_(\n            &mut cache.clist,\n            &mut cache.nlist,\n            matches,\n            slots,\n            quit_after_match,\n            at,\n            end,\n        )\n    }\n\n    fn exec_(\n        &mut self,\n        mut clist: &mut Threads,\n        mut nlist: &mut Threads,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        mut at: InputAt,\n        end: usize,\n    ) -> bool {\n        let mut matched = false;\n        let mut all_matched = false;\n        clist.set.clear();\n        nlist.set.clear();\n        'LOOP: loop {\n            if clist.set.is_empty() {\n                // Three ways to bail out when our current set of threads is\n                // empty.\n                //\n                // 1. We have a match---so we're done exploring any possible\n                //    alternatives. Time to quit. (We can't do this if we're\n                //    looking for matches for multiple regexes, unless we know\n                //    they all matched.)\n                //\n                // 2. If the expression starts with a '^' we can terminate as\n                //    soon as the last thread dies.\n                if (matched && matches.len() <= 1)\n                    || all_matched\n                    || (!at.is_start() && self.prog.is_anchored_start)\n                {\n                    break;\n                }\n\n                // 3. If there's a literal prefix for the program, try to\n                //    jump ahead quickly. If it can't be found, then we can\n                //    bail out early.\n                if !self.prog.prefixes.is_empty() {\n                    at = match self.input.prefix_at(&self.prog.prefixes, at) {\n                        None => break,\n                        Some(at) => at,\n                    };\n                }\n            }\n\n            // This simulates a preceding '.*?' for every regex by adding\n            // a state starting at the current position in the input for the\n            // beginning of the program only if we don't already have a match.\n            if clist.set.is_empty()\n                || (!self.prog.is_anchored_start && !all_matched)\n            {\n                self.add(&mut clist, slots, 0, at);\n            }\n            // The previous call to \"add\" actually inspects the position just\n            // before the current character. For stepping through the machine,\n            // we can to look at the current character, so we advance the\n            // input.\n            let at_next = self.input.at(at.next_pos());\n            for i in 0..clist.set.len() {\n                let ip = clist.set[i];\n                if self.step(\n                    &mut nlist,\n                    matches,\n                    slots,\n                    clist.caps(ip),\n                    ip,\n                    at,\n                    at_next,\n                ) {\n                    matched = true;\n                    all_matched = all_matched || matches.iter().all(|&b| b);\n                    if quit_after_match {\n                        // If we only care if a match occurs (not its\n                        // position), then we can quit right now.\n                        break 'LOOP;\n                    }\n                    if self.prog.matches.len() == 1 {\n                        // We don't need to check the rest of the threads\n                        // in this set because we've matched something\n                        // (\"leftmost-first\"). However, we still need to check\n                        // threads in the next set to support things like\n                        // greedy matching.\n                        //\n                        // This is only true on normal regexes. For regex sets,\n                        // we need to mush on to observe other matches.\n                        break;\n                    }\n                }\n            }\n            if at.pos() >= end {\n                break;\n            }\n            at = at_next;\n            mem::swap(clist, nlist);\n            nlist.set.clear();\n        }\n        matched\n    }\n\n    /// Step through the input, one token (byte or codepoint) at a time.\n    ///\n    /// nlist is the set of states that will be processed on the next token\n    /// in the input.\n    ///\n    /// caps is the set of captures passed by the caller of the NFA. They are\n    /// written to only when a match state is visited.\n    ///\n    /// thread_caps is the set of captures set for the current NFA state, ip.\n    ///\n    /// at and at_next are the current and next positions in the input. at or\n    /// at_next may be EOF.\n    fn step(\n        &mut self,\n        nlist: &mut Threads,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        thread_caps: &mut [Option<usize>],\n        ip: usize,\n        at: InputAt,\n        at_next: InputAt,\n    ) -> bool {\n        use crate::prog::Inst::*;\n        match self.prog[ip] {\n            Match(match_slot) => {\n                if match_slot < matches.len() {\n                    matches[match_slot] = true;\n                }\n                for (slot, val) in slots.iter_mut().zip(thread_caps.iter()) {\n                    *slot = *val;\n                }\n                true\n            }\n            Char(ref inst) => {\n                if inst.c == at.char() {\n                    self.add(nlist, thread_caps, inst.goto, at_next);\n                }\n                false\n            }\n            Ranges(ref inst) => {\n                if inst.matches(at.char()) {\n                    self.add(nlist, thread_caps, inst.goto, at_next);\n                }\n                false\n            }\n            Bytes(ref inst) => {\n                if let Some(b) = at.byte() {\n                    if inst.matches(b) {\n                        self.add(nlist, thread_caps, inst.goto, at_next);\n                    }\n                }\n                false\n            }\n            EmptyLook(_) | Save(_) | Split(_) => false,\n        }\n    }\n\n    /// Follows epsilon transitions and adds them for processing to nlist,\n    /// starting at and including ip.\n    fn add(\n        &mut self,\n        nlist: &mut Threads,\n        thread_caps: &mut [Option<usize>],\n        ip: usize,\n        at: InputAt,\n    ) {\n        self.stack.push(FollowEpsilon::IP(ip));\n        while let Some(frame) = self.stack.pop() {\n            match frame {\n                FollowEpsilon::IP(ip) => {\n                    self.add_step(nlist, thread_caps, ip, at);\n                }\n                FollowEpsilon::Capture { slot, pos } => {\n                    thread_caps[slot] = pos;\n                }\n            }\n        }\n    }\n\n    /// A helper function for add that avoids excessive pushing to the stack.\n    fn add_step(\n        &mut self,\n        nlist: &mut Threads,\n        thread_caps: &mut [Option<usize>],\n        mut ip: usize,\n        at: InputAt,\n    ) {\n        // Instead of pushing and popping to the stack, we mutate ip as we\n        // traverse the set of states. We only push to the stack when we\n        // absolutely need recursion (restoring captures or following a\n        // branch).\n        use crate::prog::Inst::*;\n        loop {\n            // Don't visit states we've already added.\n            if nlist.set.contains(ip) {\n                return;\n            }\n            nlist.set.insert(ip);\n            match self.prog[ip] {\n                EmptyLook(ref inst) => {\n                    if self.input.is_empty_match(at, inst) {\n                        ip = inst.goto;\n                    }\n                }\n                Save(ref inst) => {\n                    if inst.slot < thread_caps.len() {\n                        self.stack.push(FollowEpsilon::Capture {\n                            slot: inst.slot,\n                            pos: thread_caps[inst.slot],\n                        });\n                        thread_caps[inst.slot] = Some(at.pos());\n                    }\n                    ip = inst.goto;\n                }\n                Split(ref inst) => {\n                    self.stack.push(FollowEpsilon::IP(inst.goto2));\n                    ip = inst.goto1;\n                }\n                Match(_) | Char(_) | Ranges(_) | Bytes(_) => {\n                    let t = &mut nlist.caps(ip);\n                    for (slot, val) in t.iter_mut().zip(thread_caps.iter()) {\n                        *slot = *val;\n                    }\n                    return;\n                }\n            }\n        }\n    }\n}"],"pikevm::Threads":["Clone","Debug","impl Threads {\n    fn new() -> Self {\n        Threads { set: SparseSet::new(0), caps: vec![], slots_per_thread: 0 }\n    }\n\n    fn resize(&mut self, num_insts: usize, ncaps: usize) {\n        if num_insts == self.set.capacity() {\n            return;\n        }\n        self.slots_per_thread = ncaps * 2;\n        self.set = SparseSet::new(num_insts);\n        self.caps = vec![None; self.slots_per_thread * num_insts];\n    }\n\n    fn caps(&mut self, pc: usize) -> &mut [Option<usize>] {\n        let i = pc * self.slots_per_thread;\n        &mut self.caps[i..i + self.slots_per_thread]\n    }\n}"],"pool::Pool":["impl<T: ::std::fmt::Debug> ::std::fmt::Debug for Pool<T> {\n    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n        f.debug_struct(\"Pool\")\n            .field(\"stack\", &self.stack)\n            .field(\"owner\", &self.owner)\n            .field(\"owner_val\", &self.owner_val)\n            .finish()\n    }\n}","impl<T: Send> Pool<T> {\n    /// Create a new pool. The given closure is used to create values in the\n    /// pool when necessary.\n    pub fn new(create: CreateFn<T>) -> Pool<T> {\n        let owner = AtomicUsize::new(0);\n        let owner_val = create();\n        Pool { stack: Mutex::new(vec![]), create, owner, owner_val }\n    }\n\n    /// Get a value from the pool. The caller is guaranteed to have exclusive\n    /// access to the given value.\n    ///\n    /// Note that there is no guarantee provided about which value in the\n    /// pool is returned. That is, calling get, dropping the guard (causing\n    /// the value to go back into the pool) and then calling get again is NOT\n    /// guaranteed to return the same value received in the first get call.\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    pub fn get(&self) -> PoolGuard<'_, T> {\n        // Our fast path checks if the caller is the thread that \"owns\" this\n        // pool. Or stated differently, whether it is the first thread that\n        // tried to extract a value from the pool. If it is, then we can return\n        // a T to the caller without going through a mutex.\n        //\n        // SAFETY: We must guarantee that only one thread gets access to this\n        // value. Since a thread is uniquely identified by the THREAD_ID thread\n        // local, it follows that is the caller's thread ID is equal to the\n        // owner, then only one thread may receive this value.\n        let caller = THREAD_ID.with(|id| *id);\n        let owner = self.owner.load(Ordering::Relaxed);\n        if caller == owner {\n            return self.guard_owned();\n        }\n        self.get_slow(caller, owner)\n    }\n\n    /// This is the \"slow\" version that goes through a mutex to pop an\n    /// allocated value off a stack to return to the caller. (Or, if the stack\n    /// is empty, a new value is created.)\n    ///\n    /// If the pool has no owner, then this will set the owner.\n    #[cold]\n    fn get_slow(&self, caller: usize, owner: usize) -> PoolGuard<'_, T> {\n        use std::sync::atomic::Ordering::Relaxed;\n\n        if owner == 0 {\n            // The sentinel 0 value means this pool is not yet owned. We\n            // try to atomically set the owner. If we do, then this thread\n            // becomes the owner and we can return a guard that represents\n            // the special T for the owner.\n            let res = self.owner.compare_exchange(0, caller, Relaxed, Relaxed);\n            if res.is_ok() {\n                return self.guard_owned();\n            }\n        }\n        let mut stack = self.stack.lock().unwrap();\n        let value = match stack.pop() {\n            None => Box::new((self.create)()),\n            Some(value) => value,\n        };\n        self.guard_stack(value)\n    }\n\n    /// Puts a value back into the pool. Callers don't need to call this. Once\n    /// the guard that's returned by 'get' is dropped, it is put back into the\n    /// pool automatically.\n    fn put(&self, value: Box<T>) {\n        let mut stack = self.stack.lock().unwrap();\n        stack.push(value);\n    }\n\n    /// Create a guard that represents the special owned T.\n    fn guard_owned(&self) -> PoolGuard<'_, T> {\n        PoolGuard { pool: self, value: None }\n    }\n\n    /// Create a guard that contains a value from the pool's stack.\n    fn guard_stack(&self, value: Box<T>) -> PoolGuard<'_, T> {\n        PoolGuard { pool: self, value: Some(value) }\n    }\n}","unsafe impl<T: Send> Sync for Pool<T> {}"],"pool::PoolGuard":["Debug","impl<'a, T: Send> Drop for PoolGuard<'a, T> {\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn drop(&mut self) {\n        if let Some(value) = self.value.take() {\n            self.pool.put(value);\n        }\n    }\n}","impl<'a, T: Send> PoolGuard<'a, T> {\n    /// Return the underlying value.\n    pub fn value(&self) -> &T {\n        match self.value {\n            None => &self.pool.owner_val,\n            Some(ref v) => &**v,\n        }\n    }\n}"],"prog::EmptyLook":["Clone","Copy","Debug","Eq","PartialEq"],"prog::Inst":["Clone","Debug","impl Inst {\n    /// Returns true if and only if this is a match instruction.\n    pub fn is_match(&self) -> bool {\n        match *self {\n            Inst::Match(_) => true,\n            _ => false,\n        }\n    }\n}"],"prog::InstBytes":["Clone","Debug","impl InstBytes {\n    /// Returns true if and only if the given byte is in this range.\n    pub fn matches(&self, byte: u8) -> bool {\n        self.start <= byte && byte <= self.end\n    }\n}"],"prog::InstChar":["Clone","Debug"],"prog::InstEmptyLook":["Clone","Debug"],"prog::InstRanges":["Clone","Debug","impl InstRanges {\n    /// Tests whether the given input character matches this instruction.\n    pub fn matches(&self, c: Char) -> bool {\n        // This speeds up the `match_class_unicode` benchmark by checking\n        // some common cases quickly without binary search. e.g., Matching\n        // a Unicode class on predominantly ASCII text.\n        for r in self.ranges.iter().take(4) {\n            if c < r.0 {\n                return false;\n            }\n            if c <= r.1 {\n                return true;\n            }\n        }\n        self.ranges\n            .binary_search_by(|r| {\n                if r.1 < c {\n                    Ordering::Less\n                } else if r.0 > c {\n                    Ordering::Greater\n                } else {\n                    Ordering::Equal\n                }\n            })\n            .is_ok()\n    }\n\n    /// Return the number of distinct characters represented by all of the\n    /// ranges.\n    pub fn num_chars(&self) -> usize {\n        self.ranges\n            .iter()\n            .map(|&(s, e)| 1 + (e as u32) - (s as u32))\n            .sum::<u32>() as usize\n    }\n}"],"prog::InstSave":["Clone","Debug"],"prog::InstSplit":["Clone","Debug"],"prog::Program":["Clone","impl Deref for Program {\n    type Target = [Inst];\n\n    #[cfg_attr(feature = \"perf-inline\", inline(always))]\n    fn deref(&self) -> &Self::Target {\n        &*self.insts\n    }\n}","impl Program {\n    /// Creates an empty instruction sequence. Fields are given default\n    /// values.\n    pub fn new() -> Self {\n        Program {\n            insts: vec![],\n            matches: vec![],\n            captures: vec![],\n            capture_name_idx: Arc::new(HashMap::new()),\n            static_captures_len: None,\n            start: 0,\n            byte_classes: vec![0; 256],\n            only_utf8: true,\n            is_bytes: false,\n            is_dfa: false,\n            is_reverse: false,\n            is_anchored_start: false,\n            is_anchored_end: false,\n            has_unicode_word_boundary: false,\n            prefixes: LiteralSearcher::empty(),\n            dfa_size_limit: 2 * (1 << 20),\n        }\n    }\n\n    /// If pc is an index to a no-op instruction (like Save), then return the\n    /// next pc that is not a no-op instruction.\n    pub fn skip(&self, mut pc: usize) -> usize {\n        loop {\n            match self[pc] {\n                Inst::Save(ref i) => pc = i.goto,\n                _ => return pc,\n            }\n        }\n    }\n\n    /// Return true if and only if an execution engine at instruction `pc` will\n    /// always lead to a match.\n    pub fn leads_to_match(&self, pc: usize) -> bool {\n        if self.matches.len() > 1 {\n            // If we have a regex set, then we have more than one ending\n            // state, so leading to one of those states is generally\n            // meaningless.\n            return false;\n        }\n        match self[self.skip(pc)] {\n            Inst::Match(_) => true,\n            _ => false,\n        }\n    }\n\n    /// Returns true if the current configuration demands that an implicit\n    /// `.*?` be prepended to the instruction sequence.\n    pub fn needs_dotstar(&self) -> bool {\n        self.is_dfa && !self.is_reverse && !self.is_anchored_start\n    }\n\n    /// Returns true if this program uses Byte instructions instead of\n    /// Char/Range instructions.\n    pub fn uses_bytes(&self) -> bool {\n        self.is_bytes || self.is_dfa\n    }\n\n    /// Returns true if this program exclusively matches valid UTF-8 bytes.\n    ///\n    /// That is, if an invalid UTF-8 byte is seen, then no match is possible.\n    pub fn only_utf8(&self) -> bool {\n        self.only_utf8\n    }\n\n    /// Return the approximate heap usage of this instruction sequence in\n    /// bytes.\n    pub fn approximate_size(&self) -> usize {\n        // The only instruction that uses heap space is Ranges (for\n        // Unicode codepoint programs) to store non-overlapping codepoint\n        // ranges. To keep this operation constant time, we ignore them.\n        (self.len() * mem::size_of::<Inst>())\n            + (self.matches.len() * mem::size_of::<InstPtr>())\n            + (self.captures.len() * mem::size_of::<Option<String>>())\n            + (self.capture_name_idx.len()\n                * (mem::size_of::<String>() + mem::size_of::<usize>()))\n            + (self.byte_classes.len() * mem::size_of::<u8>())\n            + self.prefixes.approximate_size()\n    }\n}","impl fmt::Debug for Program {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        use self::Inst::*;\n\n        fn with_goto(cur: usize, goto: usize, fmtd: String) -> String {\n            if goto == cur + 1 {\n                fmtd\n            } else {\n                format!(\"{} (goto: {})\", fmtd, goto)\n            }\n        }\n\n        fn visible_byte(b: u8) -> String {\n            use std::ascii::escape_default;\n            let escaped = escape_default(b).collect::<Vec<u8>>();\n            String::from_utf8_lossy(&escaped).into_owned()\n        }\n\n        for (pc, inst) in self.iter().enumerate() {\n            match *inst {\n                Match(slot) => write!(f, \"{:04} Match({:?})\", pc, slot)?,\n                Save(ref inst) => {\n                    let s = format!(\"{:04} Save({})\", pc, inst.slot);\n                    write!(f, \"{}\", with_goto(pc, inst.goto, s))?;\n                }\n                Split(ref inst) => {\n                    write!(\n                        f,\n                        \"{:04} Split({}, {})\",\n                        pc, inst.goto1, inst.goto2\n                    )?;\n                }\n                EmptyLook(ref inst) => {\n                    let s = format!(\"{:?}\", inst.look);\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n                Char(ref inst) => {\n                    let s = format!(\"{:?}\", inst.c);\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n                Ranges(ref inst) => {\n                    let ranges = inst\n                        .ranges\n                        .iter()\n                        .map(|r| format!(\"{:?}-{:?}\", r.0, r.1))\n                        .collect::<Vec<String>>()\n                        .join(\", \");\n                    write!(\n                        f,\n                        \"{:04} {}\",\n                        pc,\n                        with_goto(pc, inst.goto, ranges)\n                    )?;\n                }\n                Bytes(ref inst) => {\n                    let s = format!(\n                        \"Bytes({}, {})\",\n                        visible_byte(inst.start),\n                        visible_byte(inst.end)\n                    );\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n            }\n            if pc == self.start {\n                write!(f, \" (start)\")?;\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }\n}"],"re_builder::RegexOptions":["Clone","Debug","impl Default for RegexOptions {\n    fn default() -> Self {\n        RegexOptions {\n            pats: vec![],\n            size_limit: 10 * (1 << 20),\n            dfa_size_limit: 2 * (1 << 20),\n            nest_limit: 250,\n            case_insensitive: false,\n            multi_line: false,\n            dot_matches_new_line: false,\n            swap_greed: false,\n            ignore_whitespace: false,\n            unicode: true,\n            octal: false,\n        }\n    }\n}"],"re_builder::bytes::RegexBuilder":["Debug","impl RegexBuilder {\n                /// Create a new regular expression builder with the given pattern.\n                ///\n                /// If the pattern is invalid, then an error will be returned when\n                /// `build` is called.\n                pub fn new(pattern: &str) -> RegexBuilder {\n                    let mut builder = RegexBuilder(RegexOptions::default());\n                    builder.0.pats.push(pattern.to_owned());\n                    builder\n                }\n\n                /// Consume the builder and compile the regular expression.\n                ///\n                /// Note that calling `as_str` on the resulting `Regex` will produce the\n                /// pattern given to `new` verbatim. Notably, it will not incorporate any\n                /// of the flags set on this builder.\n                pub fn build(&self) -> Result<Regex, Error> {\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(Regex::from)\n                }\n\n                /// Set the value for the case insensitive (`i`) flag.\n                ///\n                /// When enabled, letters in the pattern will match both upper case and\n                /// lower case variants.\n                pub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.case_insensitive = yes;\n                    self\n                }\n\n                /// Set the value for the multi-line matching (`m`) flag.\n                ///\n                /// When enabled, `^` matches the beginning of lines and `$` matches the\n                /// end of lines.\n                ///\n                /// By default, they match beginning/end of the input.\n                pub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.multi_line = yes;\n                    self\n                }\n\n                /// Set the value for the any character (`s`) flag, where in `.` matches\n                /// anything when `s` is set and matches anything except for new line when\n                /// it is not set (the default).\n                ///\n                /// N.B. \"matches anything\" means \"any byte\" when Unicode is disabled and\n                /// means \"any valid UTF-8 encoding of any Unicode scalar value\" when\n                /// Unicode is enabled.\n                pub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }\n\n                /// Set the value for the greedy swap (`U`) flag.\n                ///\n                /// When enabled, a pattern like `a*` is lazy (tries to find shortest\n                /// match) and `a*?` is greedy (tries to find longest match).\n                ///\n                /// By default, `a*` is greedy and `a*?` is lazy.\n                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.swap_greed = yes;\n                    self\n                }\n\n                /// Set the value for the ignore whitespace (`x`) flag.\n                ///\n                /// When enabled, whitespace such as new lines and spaces will be ignored\n                /// between expressions of the pattern, and `#` can be used to start a\n                /// comment until the next new line.\n                pub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.ignore_whitespace = yes;\n                    self\n                }\n\n                /// Set the value for the Unicode (`u`) flag.\n                ///\n                /// Enabled by default. When disabled, character classes such as `\\w` only\n                /// match ASCII word characters instead of all Unicode word characters.\n                pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.unicode = yes;\n                    self\n                }\n\n                /// Whether to support octal syntax or not.\n                ///\n                /// Octal syntax is a little-known way of uttering Unicode codepoints in\n                /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n                /// `\\141` are all equivalent regular expressions, where the last example\n                /// shows octal syntax.\n                ///\n                /// While supporting octal syntax isn't in and of itself a problem, it does\n                /// make good error messages harder. That is, in PCRE based regex engines,\n                /// syntax like `\\0` invokes a backreference, which is explicitly\n                /// unsupported in Rust's regex engine. However, many users expect it to\n                /// be supported. Therefore, when octal support is disabled, the error\n                /// message will explicitly mention that backreferences aren't supported.\n                ///\n                /// Octal syntax is disabled by default.\n                pub fn octal(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.octal = yes;\n                    self\n                }\n\n                /// Set the approximate size limit of the compiled regular expression.\n                ///\n                /// This roughly corresponds to the number of bytes occupied by a single\n                /// compiled program. If the program exceeds this number, then a\n                /// compilation error is returned.\n                pub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder {\n                    self.0.size_limit = limit;\n                    self\n                }\n\n                /// Set the approximate size of the cache used by the DFA.\n                ///\n                /// This roughly corresponds to the number of bytes that the DFA will\n                /// use while searching.\n                ///\n                /// Note that this is a *per thread* limit. There is no way to set a global\n                /// limit. In particular, if a regex is used from multiple threads\n                /// simultaneously, then each thread may use up to the number of bytes\n                /// specified here.\n                pub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder {\n                    self.0.dfa_size_limit = limit;\n                    self\n                }\n\n                /// Set the nesting limit for this parser.\n                ///\n                /// The nesting limit controls how deep the abstract syntax tree is allowed\n                /// to be. If the AST exceeds the given limit (e.g., with too many nested\n                /// groups), then an error is returned by the parser.\n                ///\n                /// The purpose of this limit is to act as a heuristic to prevent stack\n                /// overflow for consumers that do structural induction on an `Ast` using\n                /// explicit recursion. While this crate never does this (instead using\n                /// constant stack space and moving the call stack to the heap), other\n                /// crates may.\n                ///\n                /// This limit is not checked until the entire Ast is parsed. Therefore,\n                /// if callers want to put a limit on the amount of heap space used, then\n                /// they should impose a limit on the length, in bytes, of the concrete\n                /// pattern string. In particular, this is viable since this parser\n                /// implementation will limit itself to heap space proportional to the\n                /// length of the pattern string.\n                ///\n                /// Note that a nest limit of `0` will return a nest limit error for most\n                /// patterns but not all. For example, a nest limit of `0` permits `a` but\n                /// not `ab`, since `ab` requires a concatenation, which results in a nest\n                /// depth of `1`. In general, a nest limit is not something that manifests\n                /// in an obvious way in the concrete syntax, therefore, it should not be\n                /// used in a granular way.\n                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder {\n                    self.0.nest_limit = limit;\n                    self\n                }\n            }"],"re_builder::set_bytes::RegexSetBuilder":["Debug","impl RegexSetBuilder {\n                /// Create a new regular expression builder with the given pattern.\n                ///\n                /// If the pattern is invalid, then an error will be returned when\n                /// `build` is called.\n                pub fn new<I, S>(patterns: I) -> RegexSetBuilder\n                where\n                    S: AsRef<str>,\n                    I: IntoIterator<Item = S>,\n                {\n                    let mut builder = RegexSetBuilder(RegexOptions::default());\n                    for pat in patterns {\n                        builder.0.pats.push(pat.as_ref().to_owned());\n                    }\n                    builder\n                }\n\n                /// Consume the builder and compile the regular expressions into a set.\n                pub fn build(&self) -> Result<RegexSet, Error> {\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(RegexSet::from)\n                }\n\n                /// Set the value for the case insensitive (`i`) flag.\n                pub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.case_insensitive = yes;\n                    self\n                }\n\n                /// Set the value for the multi-line matching (`m`) flag.\n                pub fn multi_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.multi_line = yes;\n                    self\n                }\n\n                /// Set the value for the any character (`s`) flag, where in `.` matches\n                /// anything when `s` is set and matches anything except for new line when\n                /// it is not set (the default).\n                ///\n                /// N.B. \"matches anything\" means \"any byte\" for `regex::bytes::RegexSet`\n                /// expressions and means \"any Unicode scalar value\" for `regex::RegexSet`\n                /// expressions.\n                pub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }\n\n                /// Set the value for the greedy swap (`U`) flag.\n                pub fn swap_greed(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.swap_greed = yes;\n                    self\n                }\n\n                /// Set the value for the ignore whitespace (`x`) flag.\n                pub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.ignore_whitespace = yes;\n                    self\n                }\n\n                /// Set the value for the Unicode (`u`) flag.\n                pub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder {\n                    self.0.unicode = yes;\n                    self\n                }\n\n                /// Whether to support octal syntax or not.\n                ///\n                /// Octal syntax is a little-known way of uttering Unicode codepoints in\n                /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n                /// `\\141` are all equivalent regular expressions, where the last example\n                /// shows octal syntax.\n                ///\n                /// While supporting octal syntax isn't in and of itself a problem, it does\n                /// make good error messages harder. That is, in PCRE based regex engines,\n                /// syntax like `\\0` invokes a backreference, which is explicitly\n                /// unsupported in Rust's regex engine. However, many users expect it to\n                /// be supported. Therefore, when octal support is disabled, the error\n                /// message will explicitly mention that backreferences aren't supported.\n                ///\n                /// Octal syntax is disabled by default.\n                pub fn octal(&mut self, yes: bool) -> &mut RegexSetBuilder {\n                    self.0.octal = yes;\n                    self\n                }\n\n                /// Set the approximate size limit of the compiled regular expression.\n                ///\n                /// This roughly corresponds to the number of bytes occupied by a single\n                /// compiled program. If the program exceeds this number, then a\n                /// compilation error is returned.\n                pub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder {\n                    self.0.size_limit = limit;\n                    self\n                }\n\n                /// Set the approximate size of the cache used by the DFA.\n                ///\n                /// This roughly corresponds to the number of bytes that the DFA will\n                /// use while searching.\n                ///\n                /// Note that this is a *per thread* limit. There is no way to set a global\n                /// limit. In particular, if a regex is used from multiple threads\n                /// simultaneously, then each thread may use up to the number of bytes\n                /// specified here.\n                pub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder {\n                    self.0.dfa_size_limit = limit;\n                    self\n                }\n\n                /// Set the nesting limit for this parser.\n                ///\n                /// The nesting limit controls how deep the abstract syntax tree is allowed\n                /// to be. If the AST exceeds the given limit (e.g., with too many nested\n                /// groups), then an error is returned by the parser.\n                ///\n                /// The purpose of this limit is to act as a heuristic to prevent stack\n                /// overflow for consumers that do structural induction on an `Ast` using\n                /// explicit recursion. While this crate never does this (instead using\n                /// constant stack space and moving the call stack to the heap), other\n                /// crates may.\n                ///\n                /// This limit is not checked until the entire Ast is parsed. Therefore,\n                /// if callers want to put a limit on the amount of heap space used, then\n                /// they should impose a limit on the length, in bytes, of the concrete\n                /// pattern string. In particular, this is viable since this parser\n                /// implementation will limit itself to heap space proportional to the\n                /// length of the pattern string.\n                ///\n                /// Note that a nest limit of `0` will return a nest limit error for most\n                /// patterns but not all. For example, a nest limit of `0` permits `a` but\n                /// not `ab`, since `ab` requires a concatenation, which results in a nest\n                /// depth of `1`. In general, a nest limit is not something that manifests\n                /// in an obvious way in the concrete syntax, therefore, it should not be\n                /// used in a granular way.\n                pub fn nest_limit(\n                    &mut self,\n                    limit: u32,\n                ) -> &mut RegexSetBuilder {\n                    self.0.nest_limit = limit;\n                    self\n                }\n            }"],"re_builder::set_unicode::RegexSetBuilder":["Debug","impl RegexSetBuilder {\n                /// Create a new regular expression builder with the given pattern.\n                ///\n                /// If the pattern is invalid, then an error will be returned when\n                /// `build` is called.\n                pub fn new<I, S>(patterns: I) -> RegexSetBuilder\n                where\n                    S: AsRef<str>,\n                    I: IntoIterator<Item = S>,\n                {\n                    let mut builder = RegexSetBuilder(RegexOptions::default());\n                    for pat in patterns {\n                        builder.0.pats.push(pat.as_ref().to_owned());\n                    }\n                    builder\n                }\n\n                /// Consume the builder and compile the regular expressions into a set.\n                pub fn build(&self) -> Result<RegexSet, Error> {\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(RegexSet::from)\n                }\n\n                /// Set the value for the case insensitive (`i`) flag.\n                pub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.case_insensitive = yes;\n                    self\n                }\n\n                /// Set the value for the multi-line matching (`m`) flag.\n                pub fn multi_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.multi_line = yes;\n                    self\n                }\n\n                /// Set the value for the any character (`s`) flag, where in `.` matches\n                /// anything when `s` is set and matches anything except for new line when\n                /// it is not set (the default).\n                ///\n                /// N.B. \"matches anything\" means \"any byte\" for `regex::bytes::RegexSet`\n                /// expressions and means \"any Unicode scalar value\" for `regex::RegexSet`\n                /// expressions.\n                pub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }\n\n                /// Set the value for the greedy swap (`U`) flag.\n                pub fn swap_greed(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.swap_greed = yes;\n                    self\n                }\n\n                /// Set the value for the ignore whitespace (`x`) flag.\n                pub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder {\n                    self.0.ignore_whitespace = yes;\n                    self\n                }\n\n                /// Set the value for the Unicode (`u`) flag.\n                pub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder {\n                    self.0.unicode = yes;\n                    self\n                }\n\n                /// Whether to support octal syntax or not.\n                ///\n                /// Octal syntax is a little-known way of uttering Unicode codepoints in\n                /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n                /// `\\141` are all equivalent regular expressions, where the last example\n                /// shows octal syntax.\n                ///\n                /// While supporting octal syntax isn't in and of itself a problem, it does\n                /// make good error messages harder. That is, in PCRE based regex engines,\n                /// syntax like `\\0` invokes a backreference, which is explicitly\n                /// unsupported in Rust's regex engine. However, many users expect it to\n                /// be supported. Therefore, when octal support is disabled, the error\n                /// message will explicitly mention that backreferences aren't supported.\n                ///\n                /// Octal syntax is disabled by default.\n                pub fn octal(&mut self, yes: bool) -> &mut RegexSetBuilder {\n                    self.0.octal = yes;\n                    self\n                }\n\n                /// Set the approximate size limit of the compiled regular expression.\n                ///\n                /// This roughly corresponds to the number of bytes occupied by a single\n                /// compiled program. If the program exceeds this number, then a\n                /// compilation error is returned.\n                pub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder {\n                    self.0.size_limit = limit;\n                    self\n                }\n\n                /// Set the approximate size of the cache used by the DFA.\n                ///\n                /// This roughly corresponds to the number of bytes that the DFA will\n                /// use while searching.\n                ///\n                /// Note that this is a *per thread* limit. There is no way to set a global\n                /// limit. In particular, if a regex is used from multiple threads\n                /// simultaneously, then each thread may use up to the number of bytes\n                /// specified here.\n                pub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder {\n                    self.0.dfa_size_limit = limit;\n                    self\n                }\n\n                /// Set the nesting limit for this parser.\n                ///\n                /// The nesting limit controls how deep the abstract syntax tree is allowed\n                /// to be. If the AST exceeds the given limit (e.g., with too many nested\n                /// groups), then an error is returned by the parser.\n                ///\n                /// The purpose of this limit is to act as a heuristic to prevent stack\n                /// overflow for consumers that do structural induction on an `Ast` using\n                /// explicit recursion. While this crate never does this (instead using\n                /// constant stack space and moving the call stack to the heap), other\n                /// crates may.\n                ///\n                /// This limit is not checked until the entire Ast is parsed. Therefore,\n                /// if callers want to put a limit on the amount of heap space used, then\n                /// they should impose a limit on the length, in bytes, of the concrete\n                /// pattern string. In particular, this is viable since this parser\n                /// implementation will limit itself to heap space proportional to the\n                /// length of the pattern string.\n                ///\n                /// Note that a nest limit of `0` will return a nest limit error for most\n                /// patterns but not all. For example, a nest limit of `0` permits `a` but\n                /// not `ab`, since `ab` requires a concatenation, which results in a nest\n                /// depth of `1`. In general, a nest limit is not something that manifests\n                /// in an obvious way in the concrete syntax, therefore, it should not be\n                /// used in a granular way.\n                pub fn nest_limit(\n                    &mut self,\n                    limit: u32,\n                ) -> &mut RegexSetBuilder {\n                    self.0.nest_limit = limit;\n                    self\n                }\n            }"],"re_builder::unicode::RegexBuilder":["Debug","impl RegexBuilder {\n                /// Create a new regular expression builder with the given pattern.\n                ///\n                /// If the pattern is invalid, then an error will be returned when\n                /// `build` is called.\n                pub fn new(pattern: &str) -> RegexBuilder {\n                    let mut builder = RegexBuilder(RegexOptions::default());\n                    builder.0.pats.push(pattern.to_owned());\n                    builder\n                }\n\n                /// Consume the builder and compile the regular expression.\n                ///\n                /// Note that calling `as_str` on the resulting `Regex` will produce the\n                /// pattern given to `new` verbatim. Notably, it will not incorporate any\n                /// of the flags set on this builder.\n                pub fn build(&self) -> Result<Regex, Error> {\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(Regex::from)\n                }\n\n                /// Set the value for the case insensitive (`i`) flag.\n                ///\n                /// When enabled, letters in the pattern will match both upper case and\n                /// lower case variants.\n                pub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.case_insensitive = yes;\n                    self\n                }\n\n                /// Set the value for the multi-line matching (`m`) flag.\n                ///\n                /// When enabled, `^` matches the beginning of lines and `$` matches the\n                /// end of lines.\n                ///\n                /// By default, they match beginning/end of the input.\n                pub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.multi_line = yes;\n                    self\n                }\n\n                /// Set the value for the any character (`s`) flag, where in `.` matches\n                /// anything when `s` is set and matches anything except for new line when\n                /// it is not set (the default).\n                ///\n                /// N.B. \"matches anything\" means \"any byte\" when Unicode is disabled and\n                /// means \"any valid UTF-8 encoding of any Unicode scalar value\" when\n                /// Unicode is enabled.\n                pub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }\n\n                /// Set the value for the greedy swap (`U`) flag.\n                ///\n                /// When enabled, a pattern like `a*` is lazy (tries to find shortest\n                /// match) and `a*?` is greedy (tries to find longest match).\n                ///\n                /// By default, `a*` is greedy and `a*?` is lazy.\n                pub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.swap_greed = yes;\n                    self\n                }\n\n                /// Set the value for the ignore whitespace (`x`) flag.\n                ///\n                /// When enabled, whitespace such as new lines and spaces will be ignored\n                /// between expressions of the pattern, and `#` can be used to start a\n                /// comment until the next new line.\n                pub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder {\n                    self.0.ignore_whitespace = yes;\n                    self\n                }\n\n                /// Set the value for the Unicode (`u`) flag.\n                ///\n                /// Enabled by default. When disabled, character classes such as `\\w` only\n                /// match ASCII word characters instead of all Unicode word characters.\n                pub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.unicode = yes;\n                    self\n                }\n\n                /// Whether to support octal syntax or not.\n                ///\n                /// Octal syntax is a little-known way of uttering Unicode codepoints in\n                /// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n                /// `\\141` are all equivalent regular expressions, where the last example\n                /// shows octal syntax.\n                ///\n                /// While supporting octal syntax isn't in and of itself a problem, it does\n                /// make good error messages harder. That is, in PCRE based regex engines,\n                /// syntax like `\\0` invokes a backreference, which is explicitly\n                /// unsupported in Rust's regex engine. However, many users expect it to\n                /// be supported. Therefore, when octal support is disabled, the error\n                /// message will explicitly mention that backreferences aren't supported.\n                ///\n                /// Octal syntax is disabled by default.\n                pub fn octal(&mut self, yes: bool) -> &mut RegexBuilder {\n                    self.0.octal = yes;\n                    self\n                }\n\n                /// Set the approximate size limit of the compiled regular expression.\n                ///\n                /// This roughly corresponds to the number of bytes occupied by a single\n                /// compiled program. If the program exceeds this number, then a\n                /// compilation error is returned.\n                pub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder {\n                    self.0.size_limit = limit;\n                    self\n                }\n\n                /// Set the approximate size of the cache used by the DFA.\n                ///\n                /// This roughly corresponds to the number of bytes that the DFA will\n                /// use while searching.\n                ///\n                /// Note that this is a *per thread* limit. There is no way to set a global\n                /// limit. In particular, if a regex is used from multiple threads\n                /// simultaneously, then each thread may use up to the number of bytes\n                /// specified here.\n                pub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder {\n                    self.0.dfa_size_limit = limit;\n                    self\n                }\n\n                /// Set the nesting limit for this parser.\n                ///\n                /// The nesting limit controls how deep the abstract syntax tree is allowed\n                /// to be. If the AST exceeds the given limit (e.g., with too many nested\n                /// groups), then an error is returned by the parser.\n                ///\n                /// The purpose of this limit is to act as a heuristic to prevent stack\n                /// overflow for consumers that do structural induction on an `Ast` using\n                /// explicit recursion. While this crate never does this (instead using\n                /// constant stack space and moving the call stack to the heap), other\n                /// crates may.\n                ///\n                /// This limit is not checked until the entire Ast is parsed. Therefore,\n                /// if callers want to put a limit on the amount of heap space used, then\n                /// they should impose a limit on the length, in bytes, of the concrete\n                /// pattern string. In particular, this is viable since this parser\n                /// implementation will limit itself to heap space proportional to the\n                /// length of the pattern string.\n                ///\n                /// Note that a nest limit of `0` will return a nest limit error for most\n                /// patterns but not all. For example, a nest limit of `0` permits `a` but\n                /// not `ab`, since `ab` requires a concatenation, which results in a nest\n                /// depth of `1`. In general, a nest limit is not something that manifests\n                /// in an obvious way in the concrete syntax, therefore, it should not be\n                /// used in a granular way.\n                pub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder {\n                    self.0.nest_limit = limit;\n                    self\n                }\n            }"],"re_bytes::CaptureLocations":["Clone","Debug","impl CaptureLocations {\n    /// Returns the start and end positions of the Nth capture group. Returns\n    /// `None` if `i` is not a valid capture group or if the capture group did\n    /// not match anything. The positions returned are *always* byte indices\n    /// with respect to the original string matched.\n    #[inline]\n    pub fn get(&self, i: usize) -> Option<(usize, usize)> {\n        self.0.pos(i)\n    }\n\n    /// Returns the total number of capture groups (even if they didn't match).\n    ///\n    /// This is always at least `1` since every regex has at least `1`\n    /// capturing group that corresponds to the entire match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    /// An alias for the `get` method for backwards compatibility.\n    ///\n    /// Previously, we exported `get` as `pos` in an undocumented API. To\n    /// prevent breaking that code (e.g., in `regex-capi`), we continue\n    /// re-exporting the same undocumented API.\n    #[doc(hidden)]\n    #[inline]\n    pub fn pos(&self, i: usize) -> Option<(usize, usize)> {\n        self.get(i)\n    }\n}"],"re_bytes::CaptureMatches":["Debug","impl<'r, 't> FusedIterator for CaptureMatches<'r, 't> {}","impl<'r, 't> Iterator for CaptureMatches<'r, 't> {\n    type Item = Captures<'t>;\n\n    fn next(&mut self) -> Option<Captures<'t>> {\n        self.0.next().map(|locs| Captures {\n            text: self.0.text(),\n            locs,\n            named_groups: self.0.regex().capture_name_idx().clone(),\n        })\n    }\n}"],"re_bytes::CaptureNames":["Clone","Debug","impl<'r> ExactSizeIterator for CaptureNames<'r> {}","impl<'r> FusedIterator for CaptureNames<'r> {}","impl<'r> Iterator for CaptureNames<'r> {\n    type Item = Option<&'r str>;\n\n    fn next(&mut self) -> Option<Option<&'r str>> {\n        self.0\n            .next()\n            .as_ref()\n            .map(|slot| slot.as_ref().map(|name| name.as_ref()))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n\n    fn count(self) -> usize {\n        self.0.count()\n    }\n}"],"re_bytes::Captures":["impl<'t, 'i> Index<&'i str> for Captures<'t> {\n    type Output = [u8];\n\n    fn index<'a>(&'a self, name: &'i str) -> &'a [u8] {\n        self.name(name)\n            .map(|m| m.as_bytes())\n            .unwrap_or_else(|| panic!(\"no group named '{}'\", name))\n    }\n}","impl<'t> Captures<'t> {\n    /// Returns the match associated with the capture group at index `i`. If\n    /// `i` does not correspond to a capture group, or if the capture group\n    /// did not participate in the match, then `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// Get the text of the match with a default of an empty string if this\n    /// group didn't participate in the match:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// let re = Regex::new(r\"[a-z]+(?:([0-9]+)|([A-Z]+))\").unwrap();\n    /// let caps = re.captures(b\"abc123\").unwrap();\n    ///\n    /// let text1 = caps.get(1).map_or(&b\"\"[..], |m| m.as_bytes());\n    /// let text2 = caps.get(2).map_or(&b\"\"[..], |m| m.as_bytes());\n    /// assert_eq!(text1, &b\"123\"[..]);\n    /// assert_eq!(text2, &b\"\"[..]);\n    /// ```\n    pub fn get(&self, i: usize) -> Option<Match<'t>> {\n        self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    }\n\n    /// Returns the match for the capture group named `name`. If `name` isn't a\n    /// valid capture group or didn't match anything, then `None` is returned.\n    pub fn name(&self, name: &str) -> Option<Match<'t>> {\n        self.named_groups.get(name).and_then(|&i| self.get(i))\n    }\n\n    /// An iterator that yields all capturing matches in the order in which\n    /// they appear in the regex. If a particular capture group didn't\n    /// participate in the match, then `None` is yielded for that capture.\n    ///\n    /// The first match always corresponds to the overall match of the regex.\n    pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 't> {\n        SubCaptureMatches { caps: self, it: self.locs.iter() }\n    }\n\n    /// Expands all instances of `$name` in `replacement` to the corresponding\n    /// capture group `name`, and writes them to the `dst` buffer given.\n    ///\n    /// `name` may be an integer corresponding to the index of the capture\n    /// group (counted by order of opening parenthesis where `0` is the\n    /// entire match) or it can be a name (consisting of letters, digits or\n    /// underscores) corresponding to a named capture group.\n    ///\n    /// If `name` isn't a valid capture group (whether the name doesn't exist\n    /// or isn't a valid index), then it is replaced with the empty string.\n    ///\n    /// The longest possible name consisting of the characters `[_0-9A-Za-z]`\n    /// is used. e.g., `$1a` looks up the capture group named `1a` and not the\n    /// capture group at index `1`. To exert more precise control over the\n    /// name, or to refer to a capture group name that uses characters outside\n    /// of `[_0-9A-Za-z]`, use braces, e.g., `${1}a` or `${foo[bar].baz}`. When\n    /// using braces, any sequence of valid UTF-8 bytes is permitted. If the\n    /// sequence does not refer to a capture group name in the corresponding\n    /// regex, then it is replaced with an empty string.\n    ///\n    /// To write a literal `$` use `$$`.\n    pub fn expand(&self, replacement: &[u8], dst: &mut Vec<u8>) {\n        expand_bytes(self, replacement, dst)\n    }\n\n    /// Returns the total number of capture groups (even if they didn't match).\n    ///\n    /// This is always at least `1`, since every regex has at least one capture\n    /// group that corresponds to the full match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.locs.len()\n    }\n}","impl<'t> Index<usize> for Captures<'t> {\n    type Output = [u8];\n\n    fn index(&self, i: usize) -> &[u8] {\n        self.get(i)\n            .map(|m| m.as_bytes())\n            .unwrap_or_else(|| panic!(\"no group at index '{}'\", i))\n    }\n}","impl<'t> fmt::Debug for Captures<'t> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Captures\").field(&CapturesDebug(self)).finish()\n    }\n}"],"re_bytes::CapturesDebug":["impl<'c, 't> fmt::Debug for CapturesDebug<'c, 't> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fn escape_bytes(bytes: &[u8]) -> String {\n            let mut s = String::new();\n            for &b in bytes {\n                s.push_str(&escape_byte(b));\n            }\n            s\n        }\n\n        fn escape_byte(byte: u8) -> String {\n            use std::ascii::escape_default;\n\n            let escaped: Vec<u8> = escape_default(byte).collect();\n            String::from_utf8_lossy(&escaped).into_owned()\n        }\n\n        // We'd like to show something nice here, even if it means an\n        // allocation to build a reverse index.\n        let slot_to_name: HashMap<&usize, &String> =\n            self.0.named_groups.iter().map(|(a, b)| (b, a)).collect();\n        let mut map = f.debug_map();\n        for (slot, m) in self.0.locs.iter().enumerate() {\n            let m = m.map(|(s, e)| escape_bytes(&self.0.text[s..e]));\n            if let Some(name) = slot_to_name.get(&slot) {\n                map.entry(&name, &m);\n            } else {\n                map.entry(&slot, &m);\n            }\n        }\n        map.finish()\n    }\n}"],"re_bytes::Match":["Clone","Copy","Eq","PartialEq","impl<'t> Match<'t> {\n    /// Returns the starting byte offset of the match in the haystack.\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.start\n    }\n\n    /// Returns the ending byte offset of the match in the haystack.\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.end\n    }\n\n    /// Returns true if and only if this match has a length of zero.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.start == self.end\n    }\n\n    /// Returns the length, in bytes, of this match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.end - self.start\n    }\n\n    /// Returns the range over the starting and ending byte offsets of the\n    /// match in the haystack.\n    #[inline]\n    pub fn range(&self) -> Range<usize> {\n        self.start..self.end\n    }\n\n    /// Returns the matched text.\n    #[inline]\n    pub fn as_bytes(&self) -> &'t [u8] {\n        &self.text[self.range()]\n    }\n\n    /// Creates a new match from the given haystack and byte offsets.\n    #[inline]\n    fn new(haystack: &'t [u8], start: usize, end: usize) -> Match<'t> {\n        Match { text: haystack, start, end }\n    }\n}","impl<'t> std::fmt::Debug for Match<'t> {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        let mut fmt = f.debug_struct(\"Match\");\n        fmt.field(\"start\", &self.start).field(\"end\", &self.end);\n        if let Ok(s) = std::str::from_utf8(self.as_bytes()) {\n            fmt.field(\"bytes\", &s);\n        } else {\n            // FIXME: It would be nice if this could be printed as a string\n            // with invalid UTF-8 replaced with hex escapes. A alloc would\n            // probably okay if that makes it easier, but regex-automata does\n            // (at time of writing) have internal routines that do this. So\n            // maybe we should expose them.\n            fmt.field(\"bytes\", &self.as_bytes());\n        }\n        fmt.finish()\n    }\n}"],"re_bytes::Matches":["Debug","impl<'r, 't> FusedIterator for Matches<'r, 't> {}","impl<'r, 't> Iterator for Matches<'r, 't> {\n    type Item = Match<'t>;\n\n    fn next(&mut self) -> Option<Match<'t>> {\n        let text = self.0.text();\n        self.0.next().map(|(s, e)| Match::new(text, s, e))\n    }\n}"],"re_bytes::NoExpand":["Clone","Debug","impl<'t> Replacer for NoExpand<'t> {\n    fn replace_append(&mut self, _: &Captures<'_>, dst: &mut Vec<u8>) {\n        dst.extend_from_slice(self.0);\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {\n        Some(Cow::Borrowed(self.0))\n    }\n}"],"re_bytes::Regex":["Clone","impl From<Exec> for Regex {\n    fn from(exec: Exec) -> Regex {\n        Regex(exec)\n    }\n}","impl FromStr for Regex {\n    type Err = Error;\n\n    /// Attempts to parse a string into a regular expression\n    fn from_str(s: &str) -> Result<Regex, Error> {\n        Regex::new(s)\n    }\n}","impl Regex {\n    /// Compiles a regular expression. Once compiled, it can be used repeatedly\n    /// to search, split or replace text in a string.\n    ///\n    /// If an invalid expression is given, then an error is returned.\n    pub fn new(re: &str) -> Result<Regex, Error> {\n        RegexBuilder::new(re).build()\n    }\n\n    /// Returns true if and only if there is a match for the regex in the\n    /// string given.\n    ///\n    /// It is recommended to use this method if all you need to do is test\n    /// a match, since the underlying matching engine may be able to do less\n    /// work.\n    ///\n    /// # Example\n    ///\n    /// Test if some text contains at least one word with exactly 13 ASCII word\n    /// bytes:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let text = b\"I categorically deny having triskaidekaphobia.\";\n    /// assert!(Regex::new(r\"\\b\\w{13}\\b\").unwrap().is_match(text));\n    /// # }\n    /// ```\n    pub fn is_match(&self, text: &[u8]) -> bool {\n        self.is_match_at(text, 0)\n    }\n\n    /// Returns the start and end byte range of the leftmost-first match in\n    /// `text`. If no match exists, then `None` is returned.\n    ///\n    /// Note that this should only be used if you want to discover the position\n    /// of the match. Testing the existence of a match is faster if you use\n    /// `is_match`.\n    ///\n    /// # Example\n    ///\n    /// Find the start and end location of the first word with exactly 13\n    /// ASCII word bytes:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let text = b\"I categorically deny having triskaidekaphobia.\";\n    /// let mat = Regex::new(r\"\\b\\w{13}\\b\").unwrap().find(text).unwrap();\n    /// assert_eq!((mat.start(), mat.end()), (2, 15));\n    /// # }\n    /// ```\n    pub fn find<'t>(&self, text: &'t [u8]) -> Option<Match<'t>> {\n        self.find_at(text, 0)\n    }\n\n    /// Returns an iterator for each successive non-overlapping match in\n    /// `text`, returning the start and end byte indices with respect to\n    /// `text`.\n    ///\n    /// # Example\n    ///\n    /// Find the start and end location of every word with exactly 13 ASCII\n    /// word bytes:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let text = b\"Retroactively relinquishing remunerations is reprehensible.\";\n    /// for mat in Regex::new(r\"\\b\\w{13}\\b\").unwrap().find_iter(text) {\n    ///     println!(\"{:?}\", mat);\n    /// }\n    /// # }\n    /// ```\n    pub fn find_iter<'r, 't>(&'r self, text: &'t [u8]) -> Matches<'r, 't> {\n        Matches(self.0.searcher().find_iter(text))\n    }\n\n    /// Returns the capture groups corresponding to the leftmost-first\n    /// match in `text`. Capture group `0` always corresponds to the entire\n    /// match. If no match is found, then `None` is returned.\n    ///\n    /// You should only use `captures` if you need access to the location of\n    /// capturing group matches. Otherwise, `find` is faster for discovering\n    /// the location of the overall match.\n    ///\n    /// # Examples\n    ///\n    /// Say you have some text with movie names and their release years,\n    /// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for text\n    /// looking like that, while also extracting the movie name and its release\n    /// year separately.\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n    /// let text = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n    /// let caps = re.captures(text).unwrap();\n    /// assert_eq!(caps.get(1).unwrap().as_bytes(), &b\"Citizen Kane\"[..]);\n    /// assert_eq!(caps.get(2).unwrap().as_bytes(), &b\"1941\"[..]);\n    /// assert_eq!(caps.get(0).unwrap().as_bytes(), &b\"'Citizen Kane' (1941)\"[..]);\n    /// // You can also access the groups by index using the Index notation.\n    /// // Note that this will panic on an invalid index.\n    /// assert_eq!(&caps[1], b\"Citizen Kane\");\n    /// assert_eq!(&caps[2], b\"1941\");\n    /// assert_eq!(&caps[0], b\"'Citizen Kane' (1941)\");\n    /// # }\n    /// ```\n    ///\n    /// Note that the full match is at capture group `0`. Each subsequent\n    /// capture group is indexed by the order of its opening `(`.\n    ///\n    /// We can make this example a bit clearer by using *named* capture groups:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n    ///                .unwrap();\n    /// let text = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n    /// let caps = re.captures(text).unwrap();\n    /// assert_eq!(caps.name(\"title\").unwrap().as_bytes(), b\"Citizen Kane\");\n    /// assert_eq!(caps.name(\"year\").unwrap().as_bytes(), b\"1941\");\n    /// assert_eq!(caps.get(0).unwrap().as_bytes(), &b\"'Citizen Kane' (1941)\"[..]);\n    /// // You can also access the groups by name using the Index notation.\n    /// // Note that this will panic on an invalid group name.\n    /// assert_eq!(&caps[\"title\"], b\"Citizen Kane\");\n    /// assert_eq!(&caps[\"year\"], b\"1941\");\n    /// assert_eq!(&caps[0], b\"'Citizen Kane' (1941)\");\n    ///\n    /// # }\n    /// ```\n    ///\n    /// Here we name the capture groups, which we can access with the `name`\n    /// method or the `Index` notation with a `&str`. Note that the named\n    /// capture groups are still accessible with `get` or the `Index` notation\n    /// with a `usize`.\n    ///\n    /// The `0`th capture group is always unnamed, so it must always be\n    /// accessed with `get(0)` or `[0]`.\n    pub fn captures<'t>(&self, text: &'t [u8]) -> Option<Captures<'t>> {\n        self.captures_at(text, 0)\n    }\n\n    /// Returns an iterator over all the non-overlapping capture groups matched\n    /// in `text`. This is operationally the same as `find_iter`, except it\n    /// yields information about capturing group matches.\n    ///\n    /// # Example\n    ///\n    /// We can use this to find all movie titles and their release years in\n    /// some text, where the movie is formatted like \"'Title' (xxxx)\":\n    ///\n    /// ```rust\n    /// # use std::str; use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n    ///                .unwrap();\n    /// let text = b\"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931).\";\n    /// for caps in re.captures_iter(text) {\n    ///     let title = str::from_utf8(&caps[\"title\"]).unwrap();\n    ///     let year = str::from_utf8(&caps[\"year\"]).unwrap();\n    ///     println!(\"Movie: {:?}, Released: {:?}\", title, year);\n    /// }\n    /// // Output:\n    /// // Movie: Citizen Kane, Released: 1941\n    /// // Movie: The Wizard of Oz, Released: 1939\n    /// // Movie: M, Released: 1931\n    /// # }\n    /// ```\n    pub fn captures_iter<'r, 't>(\n        &'r self,\n        text: &'t [u8],\n    ) -> CaptureMatches<'r, 't> {\n        CaptureMatches(self.0.searcher().captures_iter(text))\n    }\n\n    /// Returns an iterator of substrings of `text` delimited by a match of the\n    /// regular expression. Namely, each element of the iterator corresponds to\n    /// text that *isn't* matched by the regular expression.\n    ///\n    /// This method will *not* copy the text given.\n    ///\n    /// # Example\n    ///\n    /// To split a string delimited by arbitrary amounts of spaces or tabs:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"[ \\t]+\").unwrap();\n    /// let fields: Vec<&[u8]> = re.split(b\"a b \\t  c\\td    e\").collect();\n    /// assert_eq!(fields, vec![\n    ///     &b\"a\"[..], &b\"b\"[..], &b\"c\"[..], &b\"d\"[..], &b\"e\"[..],\n    /// ]);\n    /// # }\n    /// ```\n    pub fn split<'r, 't>(&'r self, text: &'t [u8]) -> Split<'r, 't> {\n        Split { finder: self.find_iter(text), last: 0 }\n    }\n\n    /// Returns an iterator of at most `limit` substrings of `text` delimited\n    /// by a match of the regular expression. (A `limit` of `0` will return no\n    /// substrings.) Namely, each element of the iterator corresponds to text\n    /// that *isn't* matched by the regular expression. The remainder of the\n    /// string that is not split will be the last element in the iterator.\n    ///\n    /// This method will *not* copy the text given.\n    ///\n    /// # Example\n    ///\n    /// Get the first two words in some text:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"\\W+\").unwrap();\n    /// let fields: Vec<&[u8]> = re.splitn(b\"Hey! How are you?\", 3).collect();\n    /// assert_eq!(fields, vec![&b\"Hey\"[..], &b\"How\"[..], &b\"are you?\"[..]]);\n    /// # }\n    /// ```\n    pub fn splitn<'r, 't>(\n        &'r self,\n        text: &'t [u8],\n        limit: usize,\n    ) -> SplitN<'r, 't> {\n        SplitN { splits: self.split(text), n: limit }\n    }\n\n    /// Replaces the leftmost-first match with the replacement provided. The\n    /// replacement can be a regular byte string (where `$N` and `$name` are\n    /// expanded to match capture groups) or a function that takes the matches'\n    /// `Captures` and returns the replaced byte string.\n    ///\n    /// If no match is found, then a copy of the byte string is returned\n    /// unchanged.\n    ///\n    /// # Replacement string syntax\n    ///\n    /// All instances of `$name` in the replacement text is replaced with the\n    /// corresponding capture group `name`.\n    ///\n    /// `name` may be an integer corresponding to the index of the\n    /// capture group (counted by order of opening parenthesis where `0` is the\n    /// entire match) or it can be a name (consisting of letters, digits or\n    /// underscores) corresponding to a named capture group.\n    ///\n    /// If `name` isn't a valid capture group (whether the name doesn't exist\n    /// or isn't a valid index), then it is replaced with the empty string.\n    ///\n    /// The longest possible name is used. e.g., `$1a` looks up the capture\n    /// group named `1a` and not the capture group at index `1`. To exert more\n    /// precise control over the name, use braces, e.g., `${1}a`.\n    ///\n    /// To write a literal `$` use `$$`.\n    ///\n    /// # Examples\n    ///\n    /// Note that this function is polymorphic with respect to the replacement.\n    /// In typical usage, this can just be a normal byte string:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(\"[^01]+\").unwrap();\n    /// assert_eq!(re.replace(b\"1078910\", &b\"\"[..]), &b\"1010\"[..]);\n    /// # }\n    /// ```\n    ///\n    /// But anything satisfying the `Replacer` trait will work. For example, a\n    /// closure of type `|&Captures| -> Vec<u8>` provides direct access to the\n    /// captures corresponding to a match. This allows one to access capturing\n    /// group matches easily:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # use regex::bytes::Captures; fn main() {\n    /// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n    /// let result = re.replace(b\"Springsteen, Bruce\", |caps: &Captures| {\n    ///     let mut replacement = caps[2].to_owned();\n    ///     replacement.push(b' ');\n    ///     replacement.extend(&caps[1]);\n    ///     replacement\n    /// });\n    /// assert_eq!(result, &b\"Bruce Springsteen\"[..]);\n    /// # }\n    /// ```\n    ///\n    /// But this is a bit cumbersome to use all the time. Instead, a simple\n    /// syntax is supported that expands `$name` into the corresponding capture\n    /// group. Here's the last example, but using this expansion technique\n    /// with named capture groups:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\").unwrap();\n    /// let result = re.replace(b\"Springsteen, Bruce\", &b\"$first $last\"[..]);\n    /// assert_eq!(result, &b\"Bruce Springsteen\"[..]);\n    /// # }\n    /// ```\n    ///\n    /// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n    /// would produce the same result. To write a literal `$` use `$$`.\n    ///\n    /// Sometimes the replacement string requires use of curly braces to\n    /// delineate a capture group replacement and surrounding literal text.\n    /// For example, if we wanted to join two words together with an\n    /// underscore:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"(?P<first>\\w+)\\s+(?P<second>\\w+)\").unwrap();\n    /// let result = re.replace(b\"deep fried\", &b\"${first}_$second\"[..]);\n    /// assert_eq!(result, &b\"deep_fried\"[..]);\n    /// # }\n    /// ```\n    ///\n    /// Without the curly braces, the capture group name `first_` would be\n    /// used, and since it doesn't exist, it would be replaced with the empty\n    /// string.\n    ///\n    /// Finally, sometimes you just want to replace a literal string with no\n    /// regard for capturing group expansion. This can be done by wrapping a\n    /// byte string with `NoExpand`:\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// use regex::bytes::NoExpand;\n    ///\n    /// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n    /// let result = re.replace(b\"Springsteen, Bruce\", NoExpand(b\"$2 $last\"));\n    /// assert_eq!(result, &b\"$2 $last\"[..]);\n    /// # }\n    /// ```\n    pub fn replace<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        rep: R,\n    ) -> Cow<'t, [u8]> {\n        self.replacen(text, 1, rep)\n    }\n\n    /// Replaces all non-overlapping matches in `text` with the replacement\n    /// provided. This is the same as calling `replacen` with `limit` set to\n    /// `0`.\n    ///\n    /// See the documentation for `replace` for details on how to access\n    /// capturing group matches in the replacement text.\n    pub fn replace_all<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        rep: R,\n    ) -> Cow<'t, [u8]> {\n        self.replacen(text, 0, rep)\n    }\n\n    /// Replaces at most `limit` non-overlapping matches in `text` with the\n    /// replacement provided. If `limit` is 0, then all non-overlapping matches\n    /// are replaced.\n    ///\n    /// See the documentation for `replace` for details on how to access\n    /// capturing group matches in the replacement text.\n    pub fn replacen<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        limit: usize,\n        mut rep: R,\n    ) -> Cow<'t, [u8]> {\n        if let Some(rep) = rep.no_expansion() {\n            let mut it = self.find_iter(text).enumerate().peekable();\n            if it.peek().is_none() {\n                return Cow::Borrowed(text);\n            }\n            let mut new = Vec::with_capacity(text.len());\n            let mut last_match = 0;\n            for (i, m) in it {\n                new.extend_from_slice(&text[last_match..m.start()]);\n                new.extend_from_slice(&rep);\n                last_match = m.end();\n                if limit > 0 && i >= limit - 1 {\n                    break;\n                }\n            }\n            new.extend_from_slice(&text[last_match..]);\n            return Cow::Owned(new);\n        }\n\n        // The slower path, which we use if the replacement needs access to\n        // capture groups.\n        let mut it = self.captures_iter(text).enumerate().peekable();\n        if it.peek().is_none() {\n            return Cow::Borrowed(text);\n        }\n        let mut new = Vec::with_capacity(text.len());\n        let mut last_match = 0;\n        for (i, cap) in it {\n            // unwrap on 0 is OK because captures only reports matches\n            let m = cap.get(0).unwrap();\n            new.extend_from_slice(&text[last_match..m.start()]);\n            rep.replace_append(&cap, &mut new);\n            last_match = m.end();\n            if limit > 0 && i >= limit - 1 {\n                break;\n            }\n        }\n        new.extend_from_slice(&text[last_match..]);\n        Cow::Owned(new)\n    }\n}","impl Regex {\n    /// Returns the end location of a match in the text given.\n    ///\n    /// This method may have the same performance characteristics as\n    /// `is_match`, except it provides an end location for a match. In\n    /// particular, the location returned *may be shorter* than the proper end\n    /// of the leftmost-first match that you would find via `Regex::find`.\n    ///\n    /// Note that it is not guaranteed that this routine finds the shortest or\n    /// \"earliest\" possible match. Instead, the main idea of this API is that\n    /// it returns the offset at the point at which the internal regex engine\n    /// has determined that a match has occurred. This may vary depending on\n    /// which internal regex engine is used, and thus, the offset itself may\n    /// change.\n    ///\n    /// # Example\n    ///\n    /// Typically, `a+` would match the entire first sequence of `a` in some\n    /// text, but `shortest_match` can give up as soon as it sees the first\n    /// `a`.\n    ///\n    /// ```rust\n    /// # use regex::bytes::Regex;\n    /// # fn main() {\n    /// let text = b\"aaaaa\";\n    /// let pos = Regex::new(r\"a+\").unwrap().shortest_match(text);\n    /// assert_eq!(pos, Some(1));\n    /// # }\n    /// ```\n    pub fn shortest_match(&self, text: &[u8]) -> Option<usize> {\n        self.shortest_match_at(text, 0)\n    }\n\n    /// Returns the same as shortest_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn shortest_match_at(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize> {\n        self.0.searcher().shortest_match_at(text, start)\n    }\n\n    /// Returns the same as is_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn is_match_at(&self, text: &[u8], start: usize) -> bool {\n        self.0.searcher().is_match_at(text, start)\n    }\n\n    /// Returns the same as find, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn find_at<'t>(\n        &self,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.0\n            .searcher()\n            .find_at(text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }\n\n    /// Returns the same as [`Regex::captures`], but starts the search at the\n    /// given offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn captures_at<'t>(\n        &self,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Captures<'t>> {\n        let mut locs = self.capture_locations();\n        self.captures_read_at(&mut locs, text, start).map(move |_| Captures {\n            text,\n            locs: locs.0,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }\n\n    /// This is like `captures`, but uses\n    /// [`CaptureLocations`](struct.CaptureLocations.html)\n    /// instead of\n    /// [`Captures`](struct.Captures.html) in order to amortize allocations.\n    ///\n    /// To create a `CaptureLocations` value, use the\n    /// `Regex::capture_locations` method.\n    ///\n    /// This returns the overall match if this was successful, which is always\n    /// equivalence to the `0`th capture group.\n    pub fn captures_read<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n    ) -> Option<Match<'t>> {\n        self.captures_read_at(locs, text, 0)\n    }\n\n    /// Returns the same as `captures_read`, but starts the search at the given\n    /// offset and populates the capture locations given.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn captures_read_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.0\n            .searcher()\n            .captures_read_at(&mut locs.0, text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }\n\n    /// An undocumented alias for `captures_read_at`.\n    ///\n    /// The `regex-capi` crate previously used this routine, so to avoid\n    /// breaking that crate, we continue to provide the name as an undocumented\n    /// alias.\n    #[doc(hidden)]\n    pub fn read_captures_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.captures_read_at(locs, text, start)\n    }\n}","impl Regex {\n    /// Returns the original string of this regex.\n    pub fn as_str(&self) -> &str {\n        &self.0.regex_strings()[0]\n    }\n\n    /// Returns an iterator over the capture names.\n    pub fn capture_names(&self) -> CaptureNames<'_> {\n        CaptureNames(self.0.capture_names().iter())\n    }\n\n    /// Returns the number of captures.\n    pub fn captures_len(&self) -> usize {\n        self.0.capture_names().len()\n    }\n\n    /// Returns the total number of capturing groups that appear in every\n    /// possible match.\n    ///\n    /// If the number of capture groups can vary depending on the match, then\n    /// this returns `None`. That is, a value is only returned when the number\n    /// of matching groups is invariant or \"static.\"\n    ///\n    /// Note that like [`Regex::captures_len`], this **does** include the\n    /// implicit capturing group corresponding to the entire match. Therefore,\n    /// when a non-None value is returned, it is guaranteed to be at least `1`.\n    /// Stated differently, a return value of `Some(0)` is impossible.\n    ///\n    /// # Example\n    ///\n    /// This shows a few cases where a static number of capture groups is\n    /// available and a few cases where it is not.\n    ///\n    /// ```\n    /// use regex::bytes::Regex;\n    ///\n    /// let len = |pattern| {\n    ///     Regex::new(pattern).map(|re| re.static_captures_len())\n    /// };\n    ///\n    /// assert_eq!(Some(1), len(\"a\")?);\n    /// assert_eq!(Some(2), len(\"(a)\")?);\n    /// assert_eq!(Some(2), len(\"(a)|(b)\")?);\n    /// assert_eq!(Some(3), len(\"(a)(b)|(c)(d)\")?);\n    /// assert_eq!(None, len(\"(a)|b\")?);\n    /// assert_eq!(None, len(\"a|(b)\")?);\n    /// assert_eq!(None, len(\"(b)*\")?);\n    /// assert_eq!(Some(2), len(\"(b)+\")?);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    #[inline]\n    pub fn static_captures_len(&self) -> Option<usize> {\n        self.0.static_captures_len().map(|len| len.saturating_add(1))\n    }\n\n    /// Returns an empty set of capture locations that can be reused in\n    /// multiple calls to `captures_read` or `captures_read_at`.\n    pub fn capture_locations(&self) -> CaptureLocations {\n        CaptureLocations(self.0.searcher().locations())\n    }\n\n    /// An alias for `capture_locations` to preserve backward compatibility.\n    ///\n    /// The `regex-capi` crate uses this method, so to avoid breaking that\n    /// crate, we continue to export it as an undocumented API.\n    #[doc(hidden)]\n    pub fn locations(&self) -> CaptureLocations {\n        CaptureLocations(self.0.searcher().locations())\n    }\n}","impl fmt::Debug for Regex {\n    /// Shows the original regular expression.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}","impl fmt::Display for Regex {\n    /// Shows the original regular expression.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}"],"re_bytes::ReplacerRef":["Debug","impl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R> {\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {\n        self.0.replace_append(caps, dst)\n    }\n    fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> {\n        self.0.no_expansion()\n    }\n}"],"re_bytes::Split":["Debug","impl<'r, 't> FusedIterator for Split<'r, 't> {}","impl<'r, 't> Iterator for Split<'r, 't> {\n    type Item = &'t [u8];\n\n    fn next(&mut self) -> Option<&'t [u8]> {\n        let text = self.finder.0.text();\n        match self.finder.next() {\n            None => {\n                if self.last > text.len() {\n                    None\n                } else {\n                    let s = &text[self.last..];\n                    self.last = text.len() + 1; // Next call will return None\n                    Some(s)\n                }\n            }\n            Some(m) => {\n                let matched = &text[self.last..m.start()];\n                self.last = m.end();\n                Some(matched)\n            }\n        }\n    }\n}"],"re_bytes::SplitN":["Debug","impl<'r, 't> FusedIterator for SplitN<'r, 't> {}","impl<'r, 't> Iterator for SplitN<'r, 't> {\n    type Item = &'t [u8];\n\n    fn next(&mut self) -> Option<&'t [u8]> {\n        if self.n == 0 {\n            return None;\n        }\n\n        self.n -= 1;\n        if self.n > 0 {\n            return self.splits.next();\n        }\n\n        let text = self.splits.finder.0.text();\n        if self.splits.last > text.len() {\n            // We've already returned all substrings.\n            None\n        } else {\n            // self.n == 0, so future calls will return None immediately\n            Some(&text[self.splits.last..])\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, Some(self.n))\n    }\n}"],"re_bytes::SubCaptureMatches":["Clone","Debug","impl<'c, 't> FusedIterator for SubCaptureMatches<'c, 't> {}","impl<'c, 't> Iterator for SubCaptureMatches<'c, 't> {\n    type Item = Option<Match<'t>>;\n\n    fn next(&mut self) -> Option<Option<Match<'t>>> {\n        self.it\n            .next()\n            .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    }\n}"],"re_set::bytes::RegexSet":["Clone","impl Default for RegexSet {\n    fn default() -> Self {\n        RegexSet::empty()\n    }\n}","impl From<Exec> for RegexSet {\n    fn from(exec: Exec) -> Self {\n        RegexSet(exec)\n    }\n}","impl RegexSet {\n    /// Create a new regex set with the given regular expressions.\n    ///\n    /// This takes an iterator of `S`, where `S` is something that can produce\n    /// a `&str`. If any of the strings in the iterator are not valid regular\n    /// expressions, then an error is returned.\n    ///\n    /// # Example\n    ///\n    /// Create a new regex set from an iterator of strings:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n    /// assert!(set.is_match(\"foo\"));\n    /// ```\n    pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>\n            where S: AsRef<str>, I: IntoIterator<Item=S> {\n        RegexSetBuilder::new(exprs).build()\n    }\n\n    /// Create a new empty regex set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::empty();\n    /// assert!(set.is_empty());\n    /// ```\n    pub fn empty() -> RegexSet {\n        RegexSetBuilder::new(&[\"\"; 0]).build().unwrap()\n    }\n\n    /// Returns true if and only if one of the regexes in this set matches\n    /// the text given.\n    ///\n    /// This method should be preferred if you only need to test whether any\n    /// of the regexes in the set should match, but don't care about *which*\n    /// regexes matched. This is because the underlying matching engine will\n    /// quit immediately after seeing the first match instead of continuing to\n    /// find all matches.\n    ///\n    /// Note that as with searches using `Regex`, the expression is unanchored\n    /// by default. That is, if the regex does not start with `^` or `\\A`, or\n    /// end with `$` or `\\z`, then it is permitted to match anywhere in the\n    /// text.\n    ///\n    /// # Example\n    ///\n    /// Tests whether a set matches some text:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n    /// assert!(set.is_match(\"foo\"));\n    /// assert!(!set.is_match(\"\"));\n    /// ```\n    pub fn is_match(&self, text: $text_ty) -> bool {\n        self.is_match_at(text, 0)\n    }\n\n    /// Returns the same as is_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    #[doc(hidden)]\n    pub fn is_match_at(&self, text: $text_ty, start: usize) -> bool {\n        self.0.searcher().is_match_at($as_bytes(text), start)\n    }\n\n    /// Returns the set of regular expressions that match in the given text.\n    ///\n    /// The set returned contains the index of each regular expression that\n    /// matches in the given text. The index is in correspondence with the\n    /// order of regular expressions given to `RegexSet`'s constructor.\n    ///\n    /// The set can also be used to iterate over the matched indices.\n    ///\n    /// Note that as with searches using `Regex`, the expression is unanchored\n    /// by default. That is, if the regex does not start with `^` or `\\A`, or\n    /// end with `$` or `\\z`, then it is permitted to match anywhere in the\n    /// text.\n    ///\n    /// # Example\n    ///\n    /// Tests which regular expressions match the given text:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[\n    ///     r\"\\w+\",\n    ///     r\"\\d+\",\n    ///     r\"\\pL+\",\n    ///     r\"foo\",\n    ///     r\"bar\",\n    ///     r\"barfoo\",\n    ///     r\"foobar\",\n    /// ]).unwrap();\n    /// let matches: Vec<_> = set.matches(\"foobar\").into_iter().collect();\n    /// assert_eq!(matches, vec![0, 2, 3, 4, 6]);\n    ///\n    /// // You can also test whether a particular regex matched:\n    /// let matches = set.matches(\"foobar\");\n    /// assert!(!matches.matched(5));\n    /// assert!(matches.matched(6));\n    /// ```\n    pub fn matches(&self, text: $text_ty) -> SetMatches {\n        let mut matches = vec![false; self.0.regex_strings().len()];\n        let any = self.read_matches_at(&mut matches, text, 0);\n        SetMatches {\n            matched_any: any,\n            matches: matches,\n        }\n    }\n\n    /// Returns the same as matches, but starts the search at the given\n    /// offset and stores the matches into the slice given.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    ///\n    /// `matches` must have a length that is at least the number of regexes\n    /// in this set.\n    ///\n    /// This method returns true if and only if at least one member of\n    /// `matches` is true after executing the set against `text`.\n    #[doc(hidden)]\n    pub fn read_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: $text_ty,\n        start: usize,\n    ) -> bool {\n        self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    }\n\n    /// Returns the total number of regular expressions in this set.\n    pub fn len(&self) -> usize {\n        self.0.regex_strings().len()\n    }\n\n    /// Returns `true` if this set contains no regular expressions.\n    pub fn is_empty(&self) -> bool {\n        self.0.regex_strings().is_empty()\n    }\n\n    /// Returns the patterns that this set will match on.\n    ///\n    /// This function can be used to determine the pattern for a match. The\n    /// slice returned has exactly as many patterns givens to this regex set,\n    /// and the order of the slice is the same as the order of the patterns\n    /// provided to the set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[\n    ///     r\"\\w+\",\n    ///     r\"\\d+\",\n    ///     r\"\\pL+\",\n    ///     r\"foo\",\n    ///     r\"bar\",\n    ///     r\"barfoo\",\n    ///     r\"foobar\",\n    /// ]).unwrap();\n    /// let matches: Vec<_> = set\n    ///     .matches(\"foobar\")\n    ///     .into_iter()\n    ///     .map(|match_idx| &set.patterns()[match_idx])\n    ///     .collect();\n    /// assert_eq!(matches, vec![r\"\\w+\", r\"\\pL+\", r\"foo\", r\"bar\", r\"foobar\"]);\n    /// ```\n    pub fn patterns(&self) -> &[String] {\n        self.0.regex_strings()\n    }\n}","impl fmt::Debug for RegexSet {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    }\n}"],"re_set::bytes::SetMatches":["Clone","Debug","impl IntoIterator for SetMatches {\n    type IntoIter = SetMatchesIntoIter;\n    type Item = usize;\n\n    fn into_iter(self) -> Self::IntoIter {\n        SetMatchesIntoIter(self.matches.into_iter().enumerate())\n    }\n}","impl SetMatches {\n    /// Whether this set contains any matches.\n    pub fn matched_any(&self) -> bool {\n        self.matched_any\n    }\n\n    /// Whether the regex at the given index matched.\n    ///\n    /// The index for a regex is determined by its insertion order upon the\n    /// initial construction of a `RegexSet`, starting at `0`.\n    ///\n    /// # Panics\n    ///\n    /// If `regex_index` is greater than or equal to `self.len()`.\n    pub fn matched(&self, regex_index: usize) -> bool {\n        self.matches[regex_index]\n    }\n\n    /// The total number of regexes in the set that created these matches.\n    ///\n    /// **WARNING:** This always returns the same value as [`RegexSet::len`].\n    /// In particular, it does *not* return the number of elements yielded by\n    /// [`SetMatches::iter`]. The only way to determine the total number of\n    /// matched regexes is to iterate over them.\n    pub fn len(&self) -> usize {\n        self.matches.len()\n    }\n\n    /// Returns an iterator over indexes in the regex that matched.\n    ///\n    /// This will always produces matches in ascending order of index, where\n    /// the index corresponds to the index of the regex that matched with\n    /// respect to its position when initially building the set.\n    pub fn iter(&self) -> SetMatchesIter<'_> {\n        SetMatchesIter((&*self.matches).into_iter().enumerate())\n    }\n}"],"re_set::bytes::SetMatchesIntoIter":["Debug","impl DoubleEndedIterator for SetMatchesIntoIter {\n    fn next_back(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }\n}","impl Iterator for SetMatchesIntoIter {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}","impl iter::FusedIterator for SetMatchesIntoIter {}"],"re_set::bytes::SetMatchesIter":["Clone","Debug","impl<'a> DoubleEndedIterator for SetMatchesIter<'a> {\n    fn next_back(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }\n}","impl<'a> Iterator for SetMatchesIter<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}","impl<'a> iter::FusedIterator for SetMatchesIter<'a> {}"],"re_set::unicode::RegexSet":["Clone","impl Default for RegexSet {\n    fn default() -> Self {\n        RegexSet::empty()\n    }\n}","impl From<Exec> for RegexSet {\n    fn from(exec: Exec) -> Self {\n        RegexSet(exec)\n    }\n}","impl RegexSet {\n    /// Create a new regex set with the given regular expressions.\n    ///\n    /// This takes an iterator of `S`, where `S` is something that can produce\n    /// a `&str`. If any of the strings in the iterator are not valid regular\n    /// expressions, then an error is returned.\n    ///\n    /// # Example\n    ///\n    /// Create a new regex set from an iterator of strings:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n    /// assert!(set.is_match(\"foo\"));\n    /// ```\n    pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>\n            where S: AsRef<str>, I: IntoIterator<Item=S> {\n        RegexSetBuilder::new(exprs).build()\n    }\n\n    /// Create a new empty regex set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::empty();\n    /// assert!(set.is_empty());\n    /// ```\n    pub fn empty() -> RegexSet {\n        RegexSetBuilder::new(&[\"\"; 0]).build().unwrap()\n    }\n\n    /// Returns true if and only if one of the regexes in this set matches\n    /// the text given.\n    ///\n    /// This method should be preferred if you only need to test whether any\n    /// of the regexes in the set should match, but don't care about *which*\n    /// regexes matched. This is because the underlying matching engine will\n    /// quit immediately after seeing the first match instead of continuing to\n    /// find all matches.\n    ///\n    /// Note that as with searches using `Regex`, the expression is unanchored\n    /// by default. That is, if the regex does not start with `^` or `\\A`, or\n    /// end with `$` or `\\z`, then it is permitted to match anywhere in the\n    /// text.\n    ///\n    /// # Example\n    ///\n    /// Tests whether a set matches some text:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n    /// assert!(set.is_match(\"foo\"));\n    /// assert!(!set.is_match(\"\"));\n    /// ```\n    pub fn is_match(&self, text: $text_ty) -> bool {\n        self.is_match_at(text, 0)\n    }\n\n    /// Returns the same as is_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    #[doc(hidden)]\n    pub fn is_match_at(&self, text: $text_ty, start: usize) -> bool {\n        self.0.searcher().is_match_at($as_bytes(text), start)\n    }\n\n    /// Returns the set of regular expressions that match in the given text.\n    ///\n    /// The set returned contains the index of each regular expression that\n    /// matches in the given text. The index is in correspondence with the\n    /// order of regular expressions given to `RegexSet`'s constructor.\n    ///\n    /// The set can also be used to iterate over the matched indices.\n    ///\n    /// Note that as with searches using `Regex`, the expression is unanchored\n    /// by default. That is, if the regex does not start with `^` or `\\A`, or\n    /// end with `$` or `\\z`, then it is permitted to match anywhere in the\n    /// text.\n    ///\n    /// # Example\n    ///\n    /// Tests which regular expressions match the given text:\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[\n    ///     r\"\\w+\",\n    ///     r\"\\d+\",\n    ///     r\"\\pL+\",\n    ///     r\"foo\",\n    ///     r\"bar\",\n    ///     r\"barfoo\",\n    ///     r\"foobar\",\n    /// ]).unwrap();\n    /// let matches: Vec<_> = set.matches(\"foobar\").into_iter().collect();\n    /// assert_eq!(matches, vec![0, 2, 3, 4, 6]);\n    ///\n    /// // You can also test whether a particular regex matched:\n    /// let matches = set.matches(\"foobar\");\n    /// assert!(!matches.matched(5));\n    /// assert!(matches.matched(6));\n    /// ```\n    pub fn matches(&self, text: $text_ty) -> SetMatches {\n        let mut matches = vec![false; self.0.regex_strings().len()];\n        let any = self.read_matches_at(&mut matches, text, 0);\n        SetMatches {\n            matched_any: any,\n            matches: matches,\n        }\n    }\n\n    /// Returns the same as matches, but starts the search at the given\n    /// offset and stores the matches into the slice given.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    ///\n    /// `matches` must have a length that is at least the number of regexes\n    /// in this set.\n    ///\n    /// This method returns true if and only if at least one member of\n    /// `matches` is true after executing the set against `text`.\n    #[doc(hidden)]\n    pub fn read_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: $text_ty,\n        start: usize,\n    ) -> bool {\n        self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    }\n\n    /// Returns the total number of regular expressions in this set.\n    pub fn len(&self) -> usize {\n        self.0.regex_strings().len()\n    }\n\n    /// Returns `true` if this set contains no regular expressions.\n    pub fn is_empty(&self) -> bool {\n        self.0.regex_strings().is_empty()\n    }\n\n    /// Returns the patterns that this set will match on.\n    ///\n    /// This function can be used to determine the pattern for a match. The\n    /// slice returned has exactly as many patterns givens to this regex set,\n    /// and the order of the slice is the same as the order of the patterns\n    /// provided to the set.\n    ///\n    /// # Example\n    ///\n    /// ```rust\n    /// # use regex::RegexSet;\n    /// let set = RegexSet::new(&[\n    ///     r\"\\w+\",\n    ///     r\"\\d+\",\n    ///     r\"\\pL+\",\n    ///     r\"foo\",\n    ///     r\"bar\",\n    ///     r\"barfoo\",\n    ///     r\"foobar\",\n    /// ]).unwrap();\n    /// let matches: Vec<_> = set\n    ///     .matches(\"foobar\")\n    ///     .into_iter()\n    ///     .map(|match_idx| &set.patterns()[match_idx])\n    ///     .collect();\n    /// assert_eq!(matches, vec![r\"\\w+\", r\"\\pL+\", r\"foo\", r\"bar\", r\"foobar\"]);\n    /// ```\n    pub fn patterns(&self) -> &[String] {\n        self.0.regex_strings()\n    }\n}","impl fmt::Debug for RegexSet {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    }\n}"],"re_set::unicode::SetMatches":["Clone","Debug","impl IntoIterator for SetMatches {\n    type IntoIter = SetMatchesIntoIter;\n    type Item = usize;\n\n    fn into_iter(self) -> Self::IntoIter {\n        SetMatchesIntoIter(self.matches.into_iter().enumerate())\n    }\n}","impl SetMatches {\n    /// Whether this set contains any matches.\n    pub fn matched_any(&self) -> bool {\n        self.matched_any\n    }\n\n    /// Whether the regex at the given index matched.\n    ///\n    /// The index for a regex is determined by its insertion order upon the\n    /// initial construction of a `RegexSet`, starting at `0`.\n    ///\n    /// # Panics\n    ///\n    /// If `regex_index` is greater than or equal to `self.len()`.\n    pub fn matched(&self, regex_index: usize) -> bool {\n        self.matches[regex_index]\n    }\n\n    /// The total number of regexes in the set that created these matches.\n    ///\n    /// **WARNING:** This always returns the same value as [`RegexSet::len`].\n    /// In particular, it does *not* return the number of elements yielded by\n    /// [`SetMatches::iter`]. The only way to determine the total number of\n    /// matched regexes is to iterate over them.\n    pub fn len(&self) -> usize {\n        self.matches.len()\n    }\n\n    /// Returns an iterator over indexes in the regex that matched.\n    ///\n    /// This will always produces matches in ascending order of index, where\n    /// the index corresponds to the index of the regex that matched with\n    /// respect to its position when initially building the set.\n    pub fn iter(&self) -> SetMatchesIter<'_> {\n        SetMatchesIter((&*self.matches).into_iter().enumerate())\n    }\n}"],"re_set::unicode::SetMatchesIntoIter":["Debug","impl DoubleEndedIterator for SetMatchesIntoIter {\n    fn next_back(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }\n}","impl Iterator for SetMatchesIntoIter {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}","impl iter::FusedIterator for SetMatchesIntoIter {}"],"re_set::unicode::SetMatchesIter":["Clone","Debug","impl<'a> DoubleEndedIterator for SetMatchesIter<'a> {\n    fn next_back(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }\n}","impl<'a> Iterator for SetMatchesIter<'a> {\n    type Item = usize;\n\n    fn next(&mut self) -> Option<usize> {\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n}","impl<'a> iter::FusedIterator for SetMatchesIter<'a> {}"],"re_trait::CaptureMatches":["Debug","impl<'t, R> CaptureMatches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't,\n{\n    /// Return the text being searched.\n    pub fn text(&self) -> &'t R::Text {\n        self.0.text()\n    }\n\n    /// Return the underlying regex.\n    pub fn regex(&self) -> &R {\n        self.0.regex()\n    }\n}","impl<'t, R> FusedIterator for CaptureMatches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't + AsRef<[u8]>,\n{\n}","impl<'t, R> Iterator for CaptureMatches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't + AsRef<[u8]>,\n{\n    type Item = Locations;\n\n    fn next(&mut self) -> Option<Locations> {\n        if self.0.last_end > self.0.text.as_ref().len() {\n            return None;\n        }\n        let mut locs = self.0.re.locations();\n        let (s, e) = match self.0.re.captures_read_at(\n            &mut locs,\n            self.0.text,\n            self.0.last_end,\n        ) {\n            None => return None,\n            Some((s, e)) => (s, e),\n        };\n        if s == e {\n            self.0.last_end = self.0.re.next_after_empty(self.0.text, e);\n            if Some(e) == self.0.last_match {\n                return self.next();\n            }\n        } else {\n            self.0.last_end = e;\n        }\n        self.0.last_match = Some(e);\n        Some(locs)\n    }\n}"],"re_trait::Locations":["Clone","Debug","impl Locations {\n    /// Returns the start and end positions of the Nth capture group. Returns\n    /// `None` if `i` is not a valid capture group or if the capture group did\n    /// not match anything. The positions returned are *always* byte indices\n    /// with respect to the original string matched.\n    pub fn pos(&self, i: usize) -> Option<(usize, usize)> {\n        let (s, e) = (i.checked_mul(2)?, i.checked_mul(2)?.checked_add(1)?);\n        match (self.0.get(s), self.0.get(e)) {\n            (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),\n            _ => None,\n        }\n    }\n\n    /// Creates an iterator of all the capture group positions in order of\n    /// appearance in the regular expression. Positions are byte indices\n    /// in terms of the original string matched.\n    pub fn iter(&self) -> SubCapturesPosIter<'_> {\n        SubCapturesPosIter { idx: 0, locs: self }\n    }\n\n    /// Returns the total number of capturing groups.\n    ///\n    /// This is always at least `1` since every regex has at least `1`\n    /// capturing group that corresponds to the entire match.\n    pub fn len(&self) -> usize {\n        self.0.len() / 2\n    }\n\n    /// Return the individual slots as a slice.\n    pub(crate) fn as_slots(&mut self) -> &mut [Slot] {\n        &mut self.0\n    }\n}"],"re_trait::Matches":["Debug","impl<'t, R> FusedIterator for Matches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't + AsRef<[u8]>,\n{\n}","impl<'t, R> Iterator for Matches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't + AsRef<[u8]>,\n{\n    type Item = (usize, usize);\n\n    fn next(&mut self) -> Option<(usize, usize)> {\n        if self.last_end > self.text.as_ref().len() {\n            return None;\n        }\n        let (s, e) = match self.re.find_at(self.text, self.last_end) {\n            None => return None,\n            Some((s, e)) => (s, e),\n        };\n        if s == e {\n            // This is an empty match. To ensure we make progress, start\n            // the next search at the smallest possible starting position\n            // of the next match following this one.\n            self.last_end = self.re.next_after_empty(self.text, e);\n            // Don't accept empty matches immediately following a match.\n            // Just move on to the next match.\n            if Some(e) == self.last_match {\n                return self.next();\n            }\n        } else {\n            self.last_end = e;\n        }\n        self.last_match = Some(e);\n        Some((s, e))\n    }\n}","impl<'t, R> Matches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't,\n{\n    /// Return the text being searched.\n    pub fn text(&self) -> &'t R::Text {\n        self.text\n    }\n\n    /// Return the underlying regex.\n    pub fn regex(&self) -> &R {\n        &self.re\n    }\n}"],"re_trait::SubCapturesPosIter":["Clone","Debug","impl<'c> ExactSizeIterator for SubCapturesPosIter<'c> {}","impl<'c> FusedIterator for SubCapturesPosIter<'c> {}","impl<'c> Iterator for SubCapturesPosIter<'c> {\n    type Item = Option<(usize, usize)>;\n\n    fn next(&mut self) -> Option<Option<(usize, usize)>> {\n        if self.idx >= self.locs.len() {\n            return None;\n        }\n        let x = match self.locs.pos(self.idx) {\n            None => Some(None),\n            Some((s, e)) => Some(Some((s, e))),\n        };\n        self.idx += 1;\n        x\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        let len = self.locs.len() - self.idx;\n        (len, Some(len))\n    }\n\n    fn count(self) -> usize {\n        self.len()\n    }\n}"],"re_unicode::CaptureLocations":["Clone","Debug","impl CaptureLocations {\n    /// Returns the start and end positions of the Nth capture group. Returns\n    /// `None` if `i` is not a valid capture group or if the capture group did\n    /// not match anything. The positions returned are *always* byte indices\n    /// with respect to the original string matched.\n    #[inline]\n    pub fn get(&self, i: usize) -> Option<(usize, usize)> {\n        self.0.pos(i)\n    }\n\n    /// Returns the total number of capture groups (even if they didn't match).\n    ///\n    /// This is always at least `1` since every regex has at least `1`\n    /// capturing group that corresponds to the entire match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.0.len()\n    }\n\n    /// An alias for the `get` method for backwards compatibility.\n    ///\n    /// Previously, we exported `get` as `pos` in an undocumented API. To\n    /// prevent breaking that code (e.g., in `regex-capi`), we continue\n    /// re-exporting the same undocumented API.\n    #[doc(hidden)]\n    #[inline]\n    pub fn pos(&self, i: usize) -> Option<(usize, usize)> {\n        self.get(i)\n    }\n}"],"re_unicode::CaptureMatches":["Debug","impl<'r, 't> FusedIterator for CaptureMatches<'r, 't> {}","impl<'r, 't> Iterator for CaptureMatches<'r, 't> {\n    type Item = Captures<'t>;\n\n    fn next(&mut self) -> Option<Captures<'t>> {\n        self.0.next().map(|locs| Captures {\n            text: self.0.text(),\n            locs,\n            named_groups: self.0.regex().capture_name_idx().clone(),\n        })\n    }\n}"],"re_unicode::CaptureNames":["Clone","Debug","impl<'r> ExactSizeIterator for CaptureNames<'r> {}","impl<'r> FusedIterator for CaptureNames<'r> {}","impl<'r> Iterator for CaptureNames<'r> {\n    type Item = Option<&'r str>;\n\n    fn next(&mut self) -> Option<Option<&'r str>> {\n        self.0\n            .next()\n            .as_ref()\n            .map(|slot| slot.as_ref().map(|name| name.as_ref()))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.0.size_hint()\n    }\n\n    fn count(self) -> usize {\n        self.0.count()\n    }\n}"],"re_unicode::Captures":["impl<'t, 'i> Index<&'i str> for Captures<'t> {\n    type Output = str;\n\n    fn index<'a>(&'a self, name: &'i str) -> &'a str {\n        self.name(name)\n            .map(|m| m.as_str())\n            .unwrap_or_else(|| panic!(\"no group named '{}'\", name))\n    }\n}","impl<'t> Captures<'t> {\n    /// Returns the match associated with the capture group at index `i`. If\n    /// `i` does not correspond to a capture group, or if the capture group\n    /// did not participate in the match, then `None` is returned.\n    ///\n    /// # Examples\n    ///\n    /// Get the text of the match with a default of an empty string if this\n    /// group didn't participate in the match:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// let re = Regex::new(r\"[a-z]+(?:([0-9]+)|([A-Z]+))\").unwrap();\n    /// let caps = re.captures(\"abc123\").unwrap();\n    ///\n    /// let text1 = caps.get(1).map_or(\"\", |m| m.as_str());\n    /// let text2 = caps.get(2).map_or(\"\", |m| m.as_str());\n    /// assert_eq!(text1, \"123\");\n    /// assert_eq!(text2, \"\");\n    /// ```\n    pub fn get(&self, i: usize) -> Option<Match<'t>> {\n        self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    }\n\n    /// Returns the match for the capture group named `name`. If `name` isn't a\n    /// valid capture group or didn't match anything, then `None` is returned.\n    pub fn name(&self, name: &str) -> Option<Match<'t>> {\n        self.named_groups.get(name).and_then(|&i| self.get(i))\n    }\n\n    /// An iterator that yields all capturing matches in the order in which\n    /// they appear in the regex. If a particular capture group didn't\n    /// participate in the match, then `None` is yielded for that capture.\n    ///\n    /// The first match always corresponds to the overall match of the regex.\n    pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 't> {\n        SubCaptureMatches { caps: self, it: self.locs.iter() }\n    }\n\n    /// Expands all instances of `$name` in `replacement` to the corresponding\n    /// capture group `name`, and writes them to the `dst` buffer given.\n    ///\n    /// `name` may be an integer corresponding to the index of the capture\n    /// group (counted by order of opening parenthesis where `0` is the\n    /// entire match) or it can be a name (consisting of letters, digits or\n    /// underscores) corresponding to a named capture group.\n    ///\n    /// If `name` isn't a valid capture group (whether the name doesn't exist\n    /// or isn't a valid index), then it is replaced with the empty string.\n    ///\n    /// The longest possible name consisting of the characters `[_0-9A-Za-z]`\n    /// is used. e.g., `$1a` looks up the capture group named `1a` and not the\n    /// capture group at index `1`. To exert more precise control over the\n    /// name, or to refer to a capture group name that uses characters outside\n    /// of `[_0-9A-Za-z]`, use braces, e.g., `${1}a` or `${foo[bar].baz}`. When\n    /// using braces, any sequence of characters is permitted. If the sequence\n    /// does not refer to a capture group name in the corresponding regex, then\n    /// it is replaced with an empty string.\n    ///\n    /// To write a literal `$` use `$$`.\n    pub fn expand(&self, replacement: &str, dst: &mut String) {\n        expand_str(self, replacement, dst)\n    }\n\n    /// Returns the total number of capture groups (even if they didn't match).\n    ///\n    /// This is always at least `1`, since every regex has at least one capture\n    /// group that corresponds to the full match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.locs.len()\n    }\n}","impl<'t> Index<usize> for Captures<'t> {\n    type Output = str;\n\n    fn index(&self, i: usize) -> &str {\n        self.get(i)\n            .map(|m| m.as_str())\n            .unwrap_or_else(|| panic!(\"no group at index '{}'\", i))\n    }\n}","impl<'t> fmt::Debug for Captures<'t> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_tuple(\"Captures\").field(&CapturesDebug(self)).finish()\n    }\n}"],"re_unicode::CapturesDebug":["impl<'c, 't> fmt::Debug for CapturesDebug<'c, 't> {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        // We'd like to show something nice here, even if it means an\n        // allocation to build a reverse index.\n        let slot_to_name: HashMap<&usize, &String> =\n            self.0.named_groups.iter().map(|(a, b)| (b, a)).collect();\n        let mut map = f.debug_map();\n        for (slot, m) in self.0.locs.iter().enumerate() {\n            let m = m.map(|(s, e)| &self.0.text[s..e]);\n            if let Some(name) = slot_to_name.get(&slot) {\n                map.entry(&name, &m);\n            } else {\n                map.entry(&slot, &m);\n            }\n        }\n        map.finish()\n    }\n}"],"re_unicode::Match":["Clone","Copy","Eq","PartialEq","impl<'t> Match<'t> {\n    /// Returns the starting byte offset of the match in the haystack.\n    #[inline]\n    pub fn start(&self) -> usize {\n        self.start\n    }\n\n    /// Returns the ending byte offset of the match in the haystack.\n    #[inline]\n    pub fn end(&self) -> usize {\n        self.end\n    }\n\n    /// Returns true if and only if this match has a length of zero.\n    #[inline]\n    pub fn is_empty(&self) -> bool {\n        self.start == self.end\n    }\n\n    /// Returns the length, in bytes, of this match.\n    #[inline]\n    pub fn len(&self) -> usize {\n        self.end - self.start\n    }\n\n    /// Returns the range over the starting and ending byte offsets of the\n    /// match in the haystack.\n    #[inline]\n    pub fn range(&self) -> Range<usize> {\n        self.start..self.end\n    }\n\n    /// Returns the matched text.\n    #[inline]\n    pub fn as_str(&self) -> &'t str {\n        &self.text[self.range()]\n    }\n\n    /// Creates a new match from the given haystack and byte offsets.\n    #[inline]\n    fn new(haystack: &'t str, start: usize, end: usize) -> Match<'t> {\n        Match { text: haystack, start, end }\n    }\n}","impl<'t> std::fmt::Debug for Match<'t> {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        f.debug_struct(\"Match\")\n            .field(\"start\", &self.start)\n            .field(\"end\", &self.end)\n            .field(\"string\", &self.as_str())\n            .finish()\n    }\n}"],"re_unicode::Matches":["Debug","impl<'r, 't> FusedIterator for Matches<'r, 't> {}","impl<'r, 't> Iterator for Matches<'r, 't> {\n    type Item = Match<'t>;\n\n    fn next(&mut self) -> Option<Match<'t>> {\n        let text = self.0.text();\n        self.0.next().map(|(s, e)| Match::new(text, s, e))\n    }\n}"],"re_unicode::NoExpand":["Clone","Debug","impl<'t> Replacer for NoExpand<'t> {\n    fn replace_append(&mut self, _: &Captures<'_>, dst: &mut String) {\n        dst.push_str(self.0);\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<'_, str>> {\n        Some(Cow::Borrowed(self.0))\n    }\n}"],"re_unicode::Regex":["Clone","impl From<Exec> for Regex {\n    fn from(exec: Exec) -> Regex {\n        Regex(exec)\n    }\n}","impl FromStr for Regex {\n    type Err = Error;\n\n    /// Attempts to parse a string into a regular expression\n    fn from_str(s: &str) -> Result<Regex, Error> {\n        Regex::new(s)\n    }\n}","impl Regex {\n    /// Compiles a regular expression. Once compiled, it can be used repeatedly\n    /// to search, split or replace text in a string.\n    ///\n    /// If an invalid expression is given, then an error is returned.\n    pub fn new(re: &str) -> Result<Regex, Error> {\n        RegexBuilder::new(re).build()\n    }\n\n    /// Returns true if and only if there is a match for the regex in the\n    /// string given.\n    ///\n    /// It is recommended to use this method if all you need to do is test\n    /// a match, since the underlying matching engine may be able to do less\n    /// work.\n    ///\n    /// # Example\n    ///\n    /// Test if some text contains at least one word with exactly 13\n    /// Unicode word characters:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let text = \"I categorically deny having triskaidekaphobia.\";\n    /// assert!(Regex::new(r\"\\b\\w{13}\\b\").unwrap().is_match(text));\n    /// # }\n    /// ```\n    pub fn is_match(&self, text: &str) -> bool {\n        self.is_match_at(text, 0)\n    }\n\n    /// Returns the start and end byte range of the leftmost-first match in\n    /// `text`. If no match exists, then `None` is returned.\n    ///\n    /// Note that this should only be used if you want to discover the position\n    /// of the match. Testing the existence of a match is faster if you use\n    /// `is_match`.\n    ///\n    /// # Example\n    ///\n    /// Find the start and end location of the first word with exactly 13\n    /// Unicode word characters:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let text = \"I categorically deny having triskaidekaphobia.\";\n    /// let mat = Regex::new(r\"\\b\\w{13}\\b\").unwrap().find(text).unwrap();\n    /// assert_eq!(mat.start(), 2);\n    /// assert_eq!(mat.end(), 15);\n    /// # }\n    /// ```\n    pub fn find<'t>(&self, text: &'t str) -> Option<Match<'t>> {\n        self.find_at(text, 0)\n    }\n\n    /// Returns an iterator for each successive non-overlapping match in\n    /// `text`, returning the start and end byte indices with respect to\n    /// `text`.\n    ///\n    /// # Example\n    ///\n    /// Find the start and end location of every word with exactly 13 Unicode\n    /// word characters:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let text = \"Retroactively relinquishing remunerations is reprehensible.\";\n    /// for mat in Regex::new(r\"\\b\\w{13}\\b\").unwrap().find_iter(text) {\n    ///     println!(\"{:?}\", mat);\n    /// }\n    /// # }\n    /// ```\n    pub fn find_iter<'r, 't>(&'r self, text: &'t str) -> Matches<'r, 't> {\n        Matches(self.0.searcher_str().find_iter(text))\n    }\n\n    /// Returns the capture groups corresponding to the leftmost-first\n    /// match in `text`. Capture group `0` always corresponds to the entire\n    /// match. If no match is found, then `None` is returned.\n    ///\n    /// You should only use `captures` if you need access to the location of\n    /// capturing group matches. Otherwise, `find` is faster for discovering\n    /// the location of the overall match.\n    ///\n    /// # Examples\n    ///\n    /// Say you have some text with movie names and their release years,\n    /// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for text\n    /// looking like that, while also extracting the movie name and its release\n    /// year separately.\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n    /// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n    /// let caps = re.captures(text).unwrap();\n    /// assert_eq!(caps.get(1).unwrap().as_str(), \"Citizen Kane\");\n    /// assert_eq!(caps.get(2).unwrap().as_str(), \"1941\");\n    /// assert_eq!(caps.get(0).unwrap().as_str(), \"'Citizen Kane' (1941)\");\n    /// // You can also access the groups by index using the Index notation.\n    /// // Note that this will panic on an invalid index.\n    /// assert_eq!(&caps[1], \"Citizen Kane\");\n    /// assert_eq!(&caps[2], \"1941\");\n    /// assert_eq!(&caps[0], \"'Citizen Kane' (1941)\");\n    /// # }\n    /// ```\n    ///\n    /// Note that the full match is at capture group `0`. Each subsequent\n    /// capture group is indexed by the order of its opening `(`.\n    ///\n    /// We can make this example a bit clearer by using *named* capture groups:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n    ///                .unwrap();\n    /// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n    /// let caps = re.captures(text).unwrap();\n    /// assert_eq!(caps.name(\"title\").unwrap().as_str(), \"Citizen Kane\");\n    /// assert_eq!(caps.name(\"year\").unwrap().as_str(), \"1941\");\n    /// assert_eq!(caps.get(0).unwrap().as_str(), \"'Citizen Kane' (1941)\");\n    /// // You can also access the groups by name using the Index notation.\n    /// // Note that this will panic on an invalid group name.\n    /// assert_eq!(&caps[\"title\"], \"Citizen Kane\");\n    /// assert_eq!(&caps[\"year\"], \"1941\");\n    /// assert_eq!(&caps[0], \"'Citizen Kane' (1941)\");\n    ///\n    /// # }\n    /// ```\n    ///\n    /// Here we name the capture groups, which we can access with the `name`\n    /// method or the `Index` notation with a `&str`. Note that the named\n    /// capture groups are still accessible with `get` or the `Index` notation\n    /// with a `usize`.\n    ///\n    /// The `0`th capture group is always unnamed, so it must always be\n    /// accessed with `get(0)` or `[0]`.\n    pub fn captures<'t>(&self, text: &'t str) -> Option<Captures<'t>> {\n        self.captures_at(text, 0)\n    }\n\n    /// Returns an iterator over all the non-overlapping capture groups matched\n    /// in `text`. This is operationally the same as `find_iter`, except it\n    /// yields information about capturing group matches.\n    ///\n    /// # Example\n    ///\n    /// We can use this to find all movie titles and their release years in\n    /// some text, where the movie is formatted like \"'Title' (xxxx)\":\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n    ///                .unwrap();\n    /// let text = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931).\";\n    /// for caps in re.captures_iter(text) {\n    ///     println!(\"Movie: {:?}, Released: {:?}\",\n    ///              &caps[\"title\"], &caps[\"year\"]);\n    /// }\n    /// // Output:\n    /// // Movie: Citizen Kane, Released: 1941\n    /// // Movie: The Wizard of Oz, Released: 1939\n    /// // Movie: M, Released: 1931\n    /// # }\n    /// ```\n    pub fn captures_iter<'r, 't>(\n        &'r self,\n        text: &'t str,\n    ) -> CaptureMatches<'r, 't> {\n        CaptureMatches(self.0.searcher_str().captures_iter(text))\n    }\n\n    /// Returns an iterator of substrings of `text` delimited by a match of the\n    /// regular expression. Namely, each element of the iterator corresponds to\n    /// text that *isn't* matched by the regular expression.\n    ///\n    /// This method will *not* copy the text given.\n    ///\n    /// # Example\n    ///\n    /// To split a string delimited by arbitrary amounts of spaces or tabs:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"[ \\t]+\").unwrap();\n    /// let fields: Vec<&str> = re.split(\"a b \\t  c\\td    e\").collect();\n    /// assert_eq!(fields, vec![\"a\", \"b\", \"c\", \"d\", \"e\"]);\n    /// # }\n    /// ```\n    pub fn split<'r, 't>(&'r self, text: &'t str) -> Split<'r, 't> {\n        Split { finder: self.find_iter(text), last: 0 }\n    }\n\n    /// Returns an iterator of at most `limit` substrings of `text` delimited\n    /// by a match of the regular expression. (A `limit` of `0` will return no\n    /// substrings.) Namely, each element of the iterator corresponds to text\n    /// that *isn't* matched by the regular expression. The remainder of the\n    /// string that is not split will be the last element in the iterator.\n    ///\n    /// This method will *not* copy the text given.\n    ///\n    /// # Example\n    ///\n    /// Get the first two words in some text:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"\\W+\").unwrap();\n    /// let fields: Vec<&str> = re.splitn(\"Hey! How are you?\", 3).collect();\n    /// assert_eq!(fields, vec!(\"Hey\", \"How\", \"are you?\"));\n    /// # }\n    /// ```\n    pub fn splitn<'r, 't>(\n        &'r self,\n        text: &'t str,\n        limit: usize,\n    ) -> SplitN<'r, 't> {\n        SplitN { splits: self.split(text), n: limit }\n    }\n\n    /// Replaces the leftmost-first match with the replacement provided.\n    /// The replacement can be a regular string (where `$N` and `$name` are\n    /// expanded to match capture groups) or a function that takes the matches'\n    /// `Captures` and returns the replaced string.\n    ///\n    /// If no match is found, then a copy of the string is returned unchanged.\n    ///\n    /// # Replacement string syntax\n    ///\n    /// All instances of `$name` in the replacement text is replaced with the\n    /// corresponding capture group `name`.\n    ///\n    /// `name` may be an integer corresponding to the index of the\n    /// capture group (counted by order of opening parenthesis where `0` is the\n    /// entire match) or it can be a name (consisting of letters, digits or\n    /// underscores) corresponding to a named capture group.\n    ///\n    /// If `name` isn't a valid capture group (whether the name doesn't exist\n    /// or isn't a valid index), then it is replaced with the empty string.\n    ///\n    /// The longest possible name is used. e.g., `$1a` looks up the capture\n    /// group named `1a` and not the capture group at index `1`. To exert more\n    /// precise control over the name, use braces, e.g., `${1}a`.\n    ///\n    /// To write a literal `$` use `$$`.\n    ///\n    /// # Examples\n    ///\n    /// Note that this function is polymorphic with respect to the replacement.\n    /// In typical usage, this can just be a normal string:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(\"[^01]+\").unwrap();\n    /// assert_eq!(re.replace(\"1078910\", \"\"), \"1010\");\n    /// # }\n    /// ```\n    ///\n    /// But anything satisfying the `Replacer` trait will work. For example,\n    /// a closure of type `|&Captures| -> String` provides direct access to the\n    /// captures corresponding to a match. This allows one to access\n    /// capturing group matches easily:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # use regex::Captures; fn main() {\n    /// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n    /// let result = re.replace(\"Springsteen, Bruce\", |caps: &Captures| {\n    ///     format!(\"{} {}\", &caps[2], &caps[1])\n    /// });\n    /// assert_eq!(result, \"Bruce Springsteen\");\n    /// # }\n    /// ```\n    ///\n    /// But this is a bit cumbersome to use all the time. Instead, a simple\n    /// syntax is supported that expands `$name` into the corresponding capture\n    /// group. Here's the last example, but using this expansion technique\n    /// with named capture groups:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\").unwrap();\n    /// let result = re.replace(\"Springsteen, Bruce\", \"$first $last\");\n    /// assert_eq!(result, \"Bruce Springsteen\");\n    /// # }\n    /// ```\n    ///\n    /// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n    /// would produce the same result. To write a literal `$` use `$$`.\n    ///\n    /// Sometimes the replacement string requires use of curly braces to\n    /// delineate a capture group replacement and surrounding literal text.\n    /// For example, if we wanted to join two words together with an\n    /// underscore:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let re = Regex::new(r\"(?P<first>\\w+)\\s+(?P<second>\\w+)\").unwrap();\n    /// let result = re.replace(\"deep fried\", \"${first}_$second\");\n    /// assert_eq!(result, \"deep_fried\");\n    /// # }\n    /// ```\n    ///\n    /// Without the curly braces, the capture group name `first_` would be\n    /// used, and since it doesn't exist, it would be replaced with the empty\n    /// string.\n    ///\n    /// Finally, sometimes you just want to replace a literal string with no\n    /// regard for capturing group expansion. This can be done by wrapping a\n    /// byte string with `NoExpand`:\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// use regex::NoExpand;\n    ///\n    /// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n    /// let result = re.replace(\"Springsteen, Bruce\", NoExpand(\"$2 $last\"));\n    /// assert_eq!(result, \"$2 $last\");\n    /// # }\n    /// ```\n    pub fn replace<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        rep: R,\n    ) -> Cow<'t, str> {\n        self.replacen(text, 1, rep)\n    }\n\n    /// Replaces all non-overlapping matches in `text` with the replacement\n    /// provided. This is the same as calling `replacen` with `limit` set to\n    /// `0`.\n    ///\n    /// See the documentation for `replace` for details on how to access\n    /// capturing group matches in the replacement string.\n    pub fn replace_all<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        rep: R,\n    ) -> Cow<'t, str> {\n        self.replacen(text, 0, rep)\n    }\n\n    /// Replaces at most `limit` non-overlapping matches in `text` with the\n    /// replacement provided. If `limit` is 0, then all non-overlapping matches\n    /// are replaced.\n    ///\n    /// See the documentation for `replace` for details on how to access\n    /// capturing group matches in the replacement string.\n    pub fn replacen<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        limit: usize,\n        mut rep: R,\n    ) -> Cow<'t, str> {\n        // If we know that the replacement doesn't have any capture expansions,\n        // then we can use the fast path. The fast path can make a tremendous\n        // difference:\n        //\n        //   1) We use `find_iter` instead of `captures_iter`. Not asking for\n        //      captures generally makes the regex engines faster.\n        //   2) We don't need to look up all of the capture groups and do\n        //      replacements inside the replacement string. We just push it\n        //      at each match and be done with it.\n        if let Some(rep) = rep.no_expansion() {\n            let mut it = self.find_iter(text).enumerate().peekable();\n            if it.peek().is_none() {\n                return Cow::Borrowed(text);\n            }\n            let mut new = String::with_capacity(text.len());\n            let mut last_match = 0;\n            for (i, m) in it {\n                new.push_str(&text[last_match..m.start()]);\n                new.push_str(&rep);\n                last_match = m.end();\n                if limit > 0 && i >= limit - 1 {\n                    break;\n                }\n            }\n            new.push_str(&text[last_match..]);\n            return Cow::Owned(new);\n        }\n\n        // The slower path, which we use if the replacement needs access to\n        // capture groups.\n        let mut it = self.captures_iter(text).enumerate().peekable();\n        if it.peek().is_none() {\n            return Cow::Borrowed(text);\n        }\n        let mut new = String::with_capacity(text.len());\n        let mut last_match = 0;\n        for (i, cap) in it {\n            // unwrap on 0 is OK because captures only reports matches\n            let m = cap.get(0).unwrap();\n            new.push_str(&text[last_match..m.start()]);\n            rep.replace_append(&cap, &mut new);\n            last_match = m.end();\n            if limit > 0 && i >= limit - 1 {\n                break;\n            }\n        }\n        new.push_str(&text[last_match..]);\n        Cow::Owned(new)\n    }\n}","impl Regex {\n    /// Returns the end location of a match in the text given.\n    ///\n    /// This method may have the same performance characteristics as\n    /// `is_match`, except it provides an end location for a match. In\n    /// particular, the location returned *may be shorter* than the proper end\n    /// of the leftmost-first match that you would find via `Regex::find`.\n    ///\n    /// Note that it is not guaranteed that this routine finds the shortest or\n    /// \"earliest\" possible match. Instead, the main idea of this API is that\n    /// it returns the offset at the point at which the internal regex engine\n    /// has determined that a match has occurred. This may vary depending on\n    /// which internal regex engine is used, and thus, the offset itself may\n    /// change.\n    ///\n    /// # Example\n    ///\n    /// Typically, `a+` would match the entire first sequence of `a` in some\n    /// text, but `shortest_match` can give up as soon as it sees the first\n    /// `a`.\n    ///\n    /// ```rust\n    /// # use regex::Regex;\n    /// # fn main() {\n    /// let text = \"aaaaa\";\n    /// let pos = Regex::new(r\"a+\").unwrap().shortest_match(text);\n    /// assert_eq!(pos, Some(1));\n    /// # }\n    /// ```\n    pub fn shortest_match(&self, text: &str) -> Option<usize> {\n        self.shortest_match_at(text, 0)\n    }\n\n    /// Returns the same as `shortest_match`, but starts the search at the\n    /// given offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only match\n    /// when `start == 0`.\n    pub fn shortest_match_at(\n        &self,\n        text: &str,\n        start: usize,\n    ) -> Option<usize> {\n        self.0.searcher_str().shortest_match_at(text, start)\n    }\n\n    /// Returns the same as is_match, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn is_match_at(&self, text: &str, start: usize) -> bool {\n        self.0.searcher_str().is_match_at(text, start)\n    }\n\n    /// Returns the same as find, but starts the search at the given\n    /// offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn find_at<'t>(\n        &self,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.0\n            .searcher_str()\n            .find_at(text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }\n\n    /// Returns the same as [`Regex::captures`], but starts the search at the\n    /// given offset.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn captures_at<'t>(\n        &self,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Captures<'t>> {\n        let mut locs = self.capture_locations();\n        self.captures_read_at(&mut locs, text, start).map(move |_| Captures {\n            text,\n            locs: locs.0,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }\n\n    /// This is like `captures`, but uses\n    /// [`CaptureLocations`](struct.CaptureLocations.html)\n    /// instead of\n    /// [`Captures`](struct.Captures.html) in order to amortize allocations.\n    ///\n    /// To create a `CaptureLocations` value, use the\n    /// `Regex::capture_locations` method.\n    ///\n    /// This returns the overall match if this was successful, which is always\n    /// equivalence to the `0`th capture group.\n    pub fn captures_read<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n    ) -> Option<Match<'t>> {\n        self.captures_read_at(locs, text, 0)\n    }\n\n    /// Returns the same as captures, but starts the search at the given\n    /// offset and populates the capture locations given.\n    ///\n    /// The significance of the starting point is that it takes the surrounding\n    /// context into consideration. For example, the `\\A` anchor can only\n    /// match when `start == 0`.\n    pub fn captures_read_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.0\n            .searcher_str()\n            .captures_read_at(&mut locs.0, text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }\n\n    /// An undocumented alias for `captures_read_at`.\n    ///\n    /// The `regex-capi` crate previously used this routine, so to avoid\n    /// breaking that crate, we continue to provide the name as an undocumented\n    /// alias.\n    #[doc(hidden)]\n    pub fn read_captures_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>> {\n        self.captures_read_at(locs, text, start)\n    }\n}","impl Regex {\n    /// Returns the original string of this regex.\n    pub fn as_str(&self) -> &str {\n        &self.0.regex_strings()[0]\n    }\n\n    /// Returns an iterator over the capture names.\n    pub fn capture_names(&self) -> CaptureNames<'_> {\n        CaptureNames(self.0.capture_names().iter())\n    }\n\n    /// Returns the number of captures.\n    pub fn captures_len(&self) -> usize {\n        self.0.capture_names().len()\n    }\n\n    /// Returns the total number of capturing groups that appear in every\n    /// possible match.\n    ///\n    /// If the number of capture groups can vary depending on the match, then\n    /// this returns `None`. That is, a value is only returned when the number\n    /// of matching groups is invariant or \"static.\"\n    ///\n    /// Note that like [`Regex::captures_len`], this **does** include the\n    /// implicit capturing group corresponding to the entire match. Therefore,\n    /// when a non-None value is returned, it is guaranteed to be at least `1`.\n    /// Stated differently, a return value of `Some(0)` is impossible.\n    ///\n    /// # Example\n    ///\n    /// This shows a few cases where a static number of capture groups is\n    /// available and a few cases where it is not.\n    ///\n    /// ```\n    /// use regex::Regex;\n    ///\n    /// let len = |pattern| {\n    ///     Regex::new(pattern).map(|re| re.static_captures_len())\n    /// };\n    ///\n    /// assert_eq!(Some(1), len(\"a\")?);\n    /// assert_eq!(Some(2), len(\"(a)\")?);\n    /// assert_eq!(Some(2), len(\"(a)|(b)\")?);\n    /// assert_eq!(Some(3), len(\"(a)(b)|(c)(d)\")?);\n    /// assert_eq!(None, len(\"(a)|b\")?);\n    /// assert_eq!(None, len(\"a|(b)\")?);\n    /// assert_eq!(None, len(\"(b)*\")?);\n    /// assert_eq!(Some(2), len(\"(b)+\")?);\n    ///\n    /// # Ok::<(), Box<dyn std::error::Error>>(())\n    /// ```\n    #[inline]\n    pub fn static_captures_len(&self) -> Option<usize> {\n        self.0.static_captures_len().map(|len| len.saturating_add(1))\n    }\n\n    /// Returns an empty set of capture locations that can be reused in\n    /// multiple calls to `captures_read` or `captures_read_at`.\n    pub fn capture_locations(&self) -> CaptureLocations {\n        CaptureLocations(self.0.searcher_str().locations())\n    }\n\n    /// An alias for `capture_locations` to preserve backward compatibility.\n    ///\n    /// The `regex-capi` crate uses this method, so to avoid breaking that\n    /// crate, we continue to export it as an undocumented API.\n    #[doc(hidden)]\n    pub fn locations(&self) -> CaptureLocations {\n        CaptureLocations(self.0.searcher_str().locations())\n    }\n}","impl fmt::Debug for Regex {\n    /// Shows the original regular expression.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        fmt::Display::fmt(self, f)\n    }\n}","impl fmt::Display for Regex {\n    /// Shows the original regular expression.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.as_str())\n    }\n}"],"re_unicode::ReplacerRef":["Debug","impl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R> {\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {\n        self.0.replace_append(caps, dst)\n    }\n    fn no_expansion(&mut self) -> Option<Cow<'_, str>> {\n        self.0.no_expansion()\n    }\n}"],"re_unicode::Split":["Debug","impl<'r, 't> FusedIterator for Split<'r, 't> {}","impl<'r, 't> Iterator for Split<'r, 't> {\n    type Item = &'t str;\n\n    fn next(&mut self) -> Option<&'t str> {\n        let text = self.finder.0.text();\n        match self.finder.next() {\n            None => {\n                if self.last > text.len() {\n                    None\n                } else {\n                    let s = &text[self.last..];\n                    self.last = text.len() + 1; // Next call will return None\n                    Some(s)\n                }\n            }\n            Some(m) => {\n                let matched = &text[self.last..m.start()];\n                self.last = m.end();\n                Some(matched)\n            }\n        }\n    }\n}"],"re_unicode::SplitN":["Debug","impl<'r, 't> FusedIterator for SplitN<'r, 't> {}","impl<'r, 't> Iterator for SplitN<'r, 't> {\n    type Item = &'t str;\n\n    fn next(&mut self) -> Option<&'t str> {\n        if self.n == 0 {\n            return None;\n        }\n\n        self.n -= 1;\n        if self.n > 0 {\n            return self.splits.next();\n        }\n\n        let text = self.splits.finder.0.text();\n        if self.splits.last > text.len() {\n            // We've already returned all substrings.\n            None\n        } else {\n            // self.n == 0, so future calls will return None immediately\n            Some(&text[self.splits.last..])\n        }\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        (0, Some(self.n))\n    }\n}"],"re_unicode::SubCaptureMatches":["Clone","Debug","impl<'c, 't> ExactSizeIterator for SubCaptureMatches<'c, 't> {}","impl<'c, 't> FusedIterator for SubCaptureMatches<'c, 't> {}","impl<'c, 't> Iterator for SubCaptureMatches<'c, 't> {\n    type Item = Option<Match<'t>>;\n\n    fn next(&mut self) -> Option<Option<Match<'t>>> {\n        self.it\n            .next()\n            .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    }\n\n    fn size_hint(&self) -> (usize, Option<usize>) {\n        self.it.size_hint()\n    }\n\n    fn count(self) -> usize {\n        self.it.count()\n    }\n}"],"sparse::SparseSet":["Clone","impl Deref for SparseSet {\n    type Target = [usize];\n\n    fn deref(&self) -> &Self::Target {\n        &self.dense\n    }\n}","impl SparseSet {\n    pub fn new(size: usize) -> SparseSet {\n        SparseSet {\n            dense: Vec::with_capacity(size),\n            sparse: vec![0; size].into_boxed_slice(),\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.dense.len()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.dense.is_empty()\n    }\n\n    pub fn capacity(&self) -> usize {\n        self.dense.capacity()\n    }\n\n    pub fn insert(&mut self, value: usize) {\n        let i = self.len();\n        assert!(i < self.capacity());\n        self.dense.push(value);\n        self.sparse[value] = i;\n    }\n\n    pub fn contains(&self, value: usize) -> bool {\n        let i = self.sparse[value];\n        self.dense.get(i) == Some(&value)\n    }\n\n    pub fn clear(&mut self) {\n        self.dense.clear();\n    }\n}","impl fmt::Debug for SparseSet {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"SparseSet({:?})\", self.dense)\n    }\n}"],"std::borrow::Cow":["impl<'a> Replacer for Cow<'a, [u8]> {\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {\n        caps.expand(self.as_ref(), dst);\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {\n        no_expansion(self)\n    }\n}","impl<'a> Replacer for Cow<'a, str> {\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {\n        self.as_ref().replace_append(caps, dst)\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<'_, str>> {\n        no_expansion(self)\n    }\n}"],"std::ops::Range":["impl<'t> From<Match<'t>> for Range<usize> {\n    fn from(m: Match<'t>) -> Range<usize> {\n        m.range()\n    }\n}"],"std::string::String":["impl Replacer for String {\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String) {\n        self.as_str().replace_append(caps, dst)\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<'_, str>> {\n        no_expansion(self)\n    }\n}"],"std::vec::Vec":["impl Replacer for Vec<u8> {\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {\n        caps.expand(self, dst);\n    }\n\n    fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> {\n        no_expansion(self)\n    }\n}"]},"single_path_import":{"compile::Compiler":"internal::Compiler","error::Error":"Error","exec::Exec":"internal::Exec","exec::ExecBuilder":"internal::ExecBuilder","input::Char":"internal::Char","input::CharInput":"internal::CharInput","input::Input":"internal::Input","input::InputAt":"internal::InputAt","literal::imp::LiteralSearcher":"internal::LiteralSearcher","prog::EmptyLook":"internal::EmptyLook","prog::Inst":"internal::Inst","prog::InstRanges":"internal::InstRanges","prog::Program":"internal::Program","re_unicode::CaptureLocations":"CaptureLocations","re_unicode::CaptureMatches":"CaptureMatches","re_unicode::CaptureNames":"CaptureNames","re_unicode::Captures":"Captures","re_unicode::Locations":"Locations","re_unicode::Match":"Match","re_unicode::Matches":"Matches","re_unicode::NoExpand":"NoExpand","re_unicode::Regex":"Regex","re_unicode::Replacer":"Replacer","re_unicode::ReplacerRef":"ReplacerRef","re_unicode::Split":"Split","re_unicode::SplitN":"SplitN","re_unicode::SubCaptureMatches":"SubCaptureMatches","re_unicode::escape":"escape"},"srcs":{"<&'a T as input::Input>::as_bytes":["fn as_bytes(&self) -> &[u8]{\n        (**self).as_bytes()\n    }","Real(LocalPath(\"src/input.rs\"))"],"<&'a T as input::Input>::at":["fn at(&self, i: usize) -> InputAt{\n        (**self).at(i)\n    }","Real(LocalPath(\"src/input.rs\"))"],"<&'a T as input::Input>::is_empty_match":["fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool{\n        (**self).is_empty_match(at, empty)\n    }","Real(LocalPath(\"src/input.rs\"))"],"<&'a T as input::Input>::len":["fn len(&self) -> usize{\n        (**self).len()\n    }","Real(LocalPath(\"src/input.rs\"))"],"<&'a T as input::Input>::next_char":["fn next_char(&self, at: InputAt) -> Char{\n        (**self).next_char(at)\n    }","Real(LocalPath(\"src/input.rs\"))"],"<&'a T as input::Input>::prefix_at":["fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt>{\n        (**self).prefix_at(prefixes, at)\n    }","Real(LocalPath(\"src/input.rs\"))"],"<&'a T as input::Input>::previous_char":["fn previous_char(&self, at: InputAt) -> Char{\n        (**self).previous_char(at)\n    }","Real(LocalPath(\"src/input.rs\"))"],"<&'a [u8] as re_bytes::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<&'a [u8] as re_bytes::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>){\n        caps.expand(*self, dst);\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<&'a prog::Program as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/prog.rs\"))"],"<&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        self.iter()\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>){\n        caps.expand(self.as_ref(), dst);\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, str>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String){\n        self.as_ref().replace_append(caps, dst)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<&'a std::string::String as re_unicode::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, str>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<&'a std::string::String as re_unicode::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String){\n        self.as_str().replace_append(caps, dst)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<&'a std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<&'a std::vec::Vec<u8> as re_bytes::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>){\n        caps.expand(*self, dst);\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<&'a str as re_unicode::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, str>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<&'a str as re_unicode::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String){\n        caps.expand(*self, dst);\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<F as re_bytes::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>){\n        dst.extend_from_slice((*self)(caps).as_ref());\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<F as re_unicode::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String){\n        dst.push_str((*self)(caps).as_ref());\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<compile::ByteClassSet as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"ByteClassSet\").field(&&self.0[..]).finish()\n    }","Real(LocalPath(\"src/compile.rs\"))"],"<dfa::InstPtrs<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<usize>{\n        if self.data.is_empty() {\n            return None;\n        }\n        let (delta, nread) = read_vari32(self.data);\n        let base = self.base as i32 + delta;\n        debug_assert!(base >= 0);\n        debug_assert!(nread > 0);\n        self.data = &self.data[nread..];\n        self.base = base as usize;\n        Some(self.base)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"<dfa::State as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let ips: Vec<usize> = self.inst_ptrs().collect();\n        f.debug_struct(\"State\")\n            .field(\"flags\", &self.flags())\n            .field(\"insts\", &ips)\n            .finish()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"<dfa::StateFlags as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_struct(\"StateFlags\")\n            .field(\"is_match\", &self.is_match())\n            .field(\"is_word\", &self.is_word())\n            .field(\"has_empty\", &self.has_empty())\n            .finish()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"<dfa::Transitions as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let mut fmtd = f.debug_map();\n        for si in 0..self.num_states() {\n            let s = si * self.num_byte_classes;\n            let e = s + self.num_byte_classes;\n            fmtd.entry(&si.to_string(), &TransitionsRow(&self.table[s..e]));\n        }\n        fmtd.finish()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"<dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        let mut fmtd = f.debug_map();\n        for (b, si) in self.0.iter().enumerate() {\n            match *si {\n                STATE_UNKNOWN => {}\n                STATE_DEAD => {\n                    fmtd.entry(&vb(b as usize), &\"DEAD\");\n                }\n                si => {\n                    fmtd.entry(&vb(b as usize), &si.to_string());\n                }\n            }\n        }\n        fmtd.finish()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"<error::Error as std::error::Error>::description":["#[allow(deprecated)]\nfn description(&self) -> &str{\n        match *self {\n            Error::Syntax(ref err) => err,\n            Error::CompiledTooBig(_) => \"compiled program too big\",\n            Error::__Nonexhaustive => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            Error::Syntax(ref err) => {\n                let hr: String = repeat('~').take(79).collect();\n                writeln!(f, \"Syntax(\")?;\n                writeln!(f, \"{}\", hr)?;\n                writeln!(f, \"{}\", err)?;\n                writeln!(f, \"{}\", hr)?;\n                write!(f, \")\")?;\n                Ok(())\n            }\n            Error::CompiledTooBig(limit) => {\n                f.debug_tuple(\"CompiledTooBig\").field(&limit).finish()\n            }\n            Error::__Nonexhaustive => {\n                f.debug_tuple(\"__Nonexhaustive\").finish()\n            }\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<error::Error as std::fmt::Display>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match *self {\n            Error::Syntax(ref err) => err.fmt(f),\n            Error::CompiledTooBig(limit) => write!(\n                f,\n                \"Compiled regex exceeds size limit of {} bytes.\",\n                limit\n            ),\n            Error::__Nonexhaustive => unreachable!(),\n        }\n    }","Real(LocalPath(\"src/error.rs\"))"],"<exec::Exec as std::clone::Clone>::clone":["fn clone(&self) -> Exec{\n        let pool = ExecReadOnly::new_pool(&self.ro);\n        Exec { ro: self.ro.clone(), pool }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at":["/// Finds the start and end location of the leftmost-first match and also\n/// fills in all matching capture groups.\n///\n/// The number of capture slots given should be equal to the total number\n/// of capture slots in the compiled program.\n///\n/// Note that the first two slots always correspond to the start and end\n/// locations of the overall match.\nfn captures_read_at(\n        &self,\n        locs: &mut Locations,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)>{\n        let slots = locs.as_slots();\n        for slot in slots.iter_mut() {\n            *slot = None;\n        }\n        // If the caller unnecessarily uses this, then we try to save them\n        // from themselves.\n        match slots.len() {\n            0 => return self.find_at(text, start),\n            2 => {\n                return self.find_at(text, start).map(|(s, e)| {\n                    slots[0] = Some(s);\n                    slots[1] = Some(e);\n                    (s, e)\n                });\n            }\n            _ => {} // fallthrough\n        }\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).and_then(|(s, e)| {\n                    self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    )\n                })\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa => {\n                if self.ro.nfa.is_anchored_start {\n                    self.captures_nfa(slots, text, start)\n                } else {\n                    match self.find_dfa_forward(text, start) {\n                        dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                            MatchNfaType::Auto,\n                            slots,\n                            text,\n                            s,\n                            e,\n                        ),\n                        dfa::Result::NoMatch(_) => None,\n                        dfa::Result::Quit => {\n                            self.captures_nfa(slots, text, start)\n                        }\n                    }\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match self.find_dfa_anchored_reverse(text, start) {\n                    dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    ),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.captures_nfa(slots, text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.find_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match((s, e)) => self.captures_nfa_type(\n                        MatchNfaType::Auto,\n                        slots,\n                        text,\n                        s,\n                        e,\n                    ),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.captures_nfa(slots, text, start),\n                }\n            }\n            MatchType::Nfa(ty) => {\n                self.captures_nfa_type(ty, slots, text, start, text.len())\n            }\n            MatchType::Nothing => None,\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaMany => {\n                unreachable!(\"BUG: RegexSet cannot be used with captures\")\n            }\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at":["/// Finds the start and end location of the leftmost-first match, starting\n/// at the given location.\ninline(always)\nfn find_at(&self, text: &[u8], start: usize) -> Option<(usize, usize)>{\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => self.find_literals(ty, text, start),\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa => match self.find_dfa_forward(text, start) {\n                dfa::Result::Match((s, e)) => Some((s, e)),\n                dfa::Result::NoMatch(_) => None,\n                dfa::Result::Quit => {\n                    self.find_nfa(MatchNfaType::Auto, text, start)\n                }\n            },\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match self.find_dfa_anchored_reverse(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => {\n                        self.find_nfa(MatchNfaType::Auto, text, start)\n                    }\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.find_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match((s, e)) => Some((s, e)),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => {\n                        self.find_nfa(MatchNfaType::Auto, text, start)\n                    }\n                }\n            }\n            MatchType::Nfa(ty) => self.find_nfa(ty, text, start),\n            MatchType::Nothing => None,\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaMany => {\n                unreachable!(\"BUG: RegexSet cannot be used with find\")\n            }\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at":["/// Returns true if and only if the regex matches text.\n///\n/// For single regular expressions, this is equivalent to calling\n/// shortest_match(...).is_some().\ninline(always)\nfn is_match_at(&self, text: &[u8], start: usize) -> bool{\n        if !self.is_anchor_end_match(text) {\n            return false;\n        }\n        // We need to do this dance because shortest_match relies on the NFA\n        // filling in captures[1], but a RegexSet has no captures. In other\n        // words, a RegexSet can't (currently) use shortest_match. ---AG\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).is_some()\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa | MatchType::DfaMany => {\n                match self.shortest_dfa(text, start) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache.value(),\n                    true,\n                    &text[start..],\n                    text.len() - start,\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.shortest_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.match_nfa(text, start),\n                }\n            }\n            MatchType::Nfa(ty) => self.match_nfa_type(ty, text, start),\n            MatchType::Nothing => false,\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty":["fn next_after_empty(&self, _text: &[u8], i: usize) -> usize{\n        i + 1\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at":["/// Returns the end of a match location, possibly occurring before the\n/// end location of the correct leftmost-first match.\ninline(always)\nfn shortest_match_at(&self, text: &[u8], start: usize) -> Option<usize>{\n        if !self.is_anchor_end_match(text) {\n            return None;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            MatchType::Literal(ty) => {\n                self.find_literals(ty, text, start).map(|(_, e)| e)\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::Dfa | MatchType::DfaMany => {\n                match self.shortest_dfa(text, start) {\n                    dfa::Result::Match(end) => Some(end),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            MatchType::DfaAnchoredReverse => {\n                match dfa::Fsm::reverse(\n                    &self.ro.dfa_reverse,\n                    self.cache.value(),\n                    true,\n                    &text[start..],\n                    text.len() - start,\n                ) {\n                    dfa::Result::Match(_) => Some(text.len()),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            MatchType::DfaSuffix => {\n                match self.shortest_dfa_reverse_suffix(text, start) {\n                    dfa::Result::Match(e) => Some(e),\n                    dfa::Result::NoMatch(_) => None,\n                    dfa::Result::Quit => self.shortest_nfa(text, start),\n                }\n            }\n            MatchType::Nfa(ty) => self.shortest_nfa_type(ty, text, start),\n            MatchType::Nothing => None,\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len":["/// Returns the number of capture slots in the regular expression. (There\n/// are two slots for every capture group, corresponding to possibly empty\n/// start and end locations of the capture.)\nfn slots_len(&self) -> usize{\n        self.ro.nfa.captures.len() * 2\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at":["inline(always)\nfn captures_read_at(\n        &self,\n        locs: &mut Locations,\n        text: &str,\n        start: usize,\n    ) -> Option<(usize, usize)>{\n        self.0.captures_read_at(locs, text.as_bytes(), start)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at":["inline(always)\nfn find_at(&self, text: &str, start: usize) -> Option<(usize, usize)>{\n        self.0.find_at(text.as_bytes(), start)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at":["inline(always)\nfn is_match_at(&self, text: &str, start: usize) -> bool{\n        self.0.is_match_at(text.as_bytes(), start)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty":["fn next_after_empty(&self, text: &str, i: usize) -> usize{\n        next_utf8(text.as_bytes(), i)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at":["inline(always)\nfn shortest_match_at(&self, text: &str, start: usize) -> Option<usize>{\n        self.0.shortest_match_at(text.as_bytes(), start)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len":["fn slots_len(&self) -> usize{\n        self.0.slots_len()\n    }","Real(LocalPath(\"src/exec.rs\"))"],"<expand::Ref<'a> as std::convert::From<&'a str>>::from":["fn from(x: &'a str) -> Ref<'a>{\n        Ref::Named(x)\n    }","Real(LocalPath(\"src/expand.rs\"))"],"<expand::Ref<'static> as std::convert::From<usize>>::from":["fn from(x: usize) -> Ref<'static>{\n        Ref::Number(x)\n    }","Real(LocalPath(\"src/expand.rs\"))"],"<input::ByteInput<'t> as input::Input>::as_bytes":["fn as_bytes(&self) -> &[u8]{\n        self.text\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::ByteInput<'t> as input::Input>::at":["fn at(&self, i: usize) -> InputAt{\n        if i >= self.len() {\n            InputAt { pos: self.len(), c: None.into(), byte: None, len: 0 }\n        } else {\n            InputAt {\n                pos: i,\n                c: None.into(),\n                byte: self.get(i).cloned(),\n                len: 1,\n            }\n        }\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::ByteInput<'t> as input::Input>::is_empty_match":["fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool{\n        use crate::prog::EmptyLook::*;\n        match empty.look {\n            StartLine => {\n                let c = self.previous_char(at);\n                at.pos() == 0 || c == '\\n'\n            }\n            EndLine => {\n                let c = self.next_char(at);\n                at.pos() == self.len() || c == '\\n'\n            }\n            StartText => at.pos() == 0,\n            EndText => at.pos() == self.len(),\n            WordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() != c2.is_word_char()\n            }\n            NotWordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() == c2.is_word_char()\n            }\n            WordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                if self.only_utf8 {\n                    // If we must match UTF-8, then we can't match word\n                    // boundaries at invalid UTF-8.\n                    if c1.is_none() && !at.is_start() {\n                        return false;\n                    }\n                    if c2.is_none() && !at.is_end() {\n                        return false;\n                    }\n                }\n                c1.is_word_byte() != c2.is_word_byte()\n            }\n            NotWordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                if self.only_utf8 {\n                    // If we must match UTF-8, then we can't match word\n                    // boundaries at invalid UTF-8.\n                    if c1.is_none() && !at.is_start() {\n                        return false;\n                    }\n                    if c2.is_none() && !at.is_end() {\n                        return false;\n                    }\n                }\n                c1.is_word_byte() == c2.is_word_byte()\n            }\n        }\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::ByteInput<'t> as input::Input>::len":["fn len(&self) -> usize{\n        self.text.len()\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::ByteInput<'t> as input::Input>::next_char":["fn next_char(&self, at: InputAt) -> Char{\n        decode_utf8(&self[at.pos()..]).map(|(c, _)| c).into()\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::ByteInput<'t> as input::Input>::prefix_at":["fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt>{\n        prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::ByteInput<'t> as input::Input>::previous_char":["fn previous_char(&self, at: InputAt) -> Char{\n        decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::ByteInput<'t> as std::ops::Deref>::deref":["fn deref(&self) -> &[u8]{\n        self.text\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::Char as std::cmp::PartialEq<char>>::eq":["#[inline]\nfn eq(&self, other: &char) -> bool{\n        self.0 == *other as u32\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::Char as std::cmp::PartialOrd<char>>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &char) -> Option<Ordering>{\n        self.0.partial_cmp(&(*other as u32))\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::Char as std::convert::From<char>>::from":["fn from(c: char) -> Char{\n        Char(c as u32)\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::Char as std::convert::From<std::option::Option<char>>>::from":["fn from(c: Option<char>) -> Char{\n        c.map_or(Char(u32::MAX), |c| c.into())\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::Char as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        match char::from_u32(self.0) {\n            None => write!(f, \"Empty\"),\n            Some(c) => write!(f, \"{:?}\", c),\n        }\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::CharInput<'t> as input::Input>::as_bytes":["fn as_bytes(&self) -> &[u8]{\n        self.0\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::CharInput<'t> as input::Input>::at":["fn at(&self, i: usize) -> InputAt{\n        if i >= self.len() {\n            InputAt { pos: self.len(), c: None.into(), byte: None, len: 0 }\n        } else {\n            let c = decode_utf8(&self[i..]).map(|(c, _)| c).into();\n            InputAt { pos: i, c, byte: None, len: c.len_utf8() }\n        }\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::CharInput<'t> as input::Input>::is_empty_match":["fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool{\n        use crate::prog::EmptyLook::*;\n        match empty.look {\n            StartLine => {\n                let c = self.previous_char(at);\n                at.pos() == 0 || c == '\\n'\n            }\n            EndLine => {\n                let c = self.next_char(at);\n                at.pos() == self.len() || c == '\\n'\n            }\n            StartText => at.pos() == 0,\n            EndText => at.pos() == self.len(),\n            WordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() != c2.is_word_char()\n            }\n            NotWordBoundary => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_char() == c2.is_word_char()\n            }\n            WordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_byte() != c2.is_word_byte()\n            }\n            NotWordBoundaryAscii => {\n                let (c1, c2) = (self.previous_char(at), self.next_char(at));\n                c1.is_word_byte() == c2.is_word_byte()\n            }\n        }\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::CharInput<'t> as input::Input>::len":["fn len(&self) -> usize{\n        self.0.len()\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::CharInput<'t> as input::Input>::next_char":["fn next_char(&self, at: InputAt) -> Char{\n        at.char()\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::CharInput<'t> as input::Input>::prefix_at":["fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt>{\n        prefixes.find(&self[at.pos()..]).map(|(s, _)| self.at(at.pos() + s))\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::CharInput<'t> as input::Input>::previous_char":["fn previous_char(&self, at: InputAt) -> Char{\n        decode_last_utf8(&self[..at.pos()]).map(|(c, _)| c).into()\n    }","Real(LocalPath(\"src/input.rs\"))"],"<input::CharInput<'t> as std::ops::Deref>::deref":["fn deref(&self) -> &[u8]{\n        self.0\n    }","Real(LocalPath(\"src/input.rs\"))"],"<literal::imp::LiteralIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Self::Item>{\n        match *self {\n            LiteralIter::Empty => None,\n            LiteralIter::Bytes(ref mut many) => {\n                if many.is_empty() {\n                    None\n                } else {\n                    let next = &many[0..1];\n                    *many = &many[1..];\n                    Some(next)\n                }\n            }\n            LiteralIter::Single(ref mut one) => {\n                if one.is_empty() {\n                    None\n                } else {\n                    let next = &one[..];\n                    *one = &[];\n                    Some(next)\n                }\n            }\n            LiteralIter::AC(ref mut lits) => {\n                if lits.is_empty() {\n                    None\n                } else {\n                    let next = &lits[0];\n                    *lits = &lits[1..];\n                    Some(next.as_bytes())\n                }\n            }\n            LiteralIter::Packed(ref mut lits) => {\n                if lits.is_empty() {\n                    None\n                } else {\n                    let next = &lits[0];\n                    *lits = &lits[1..];\n                    Some(next.as_bytes())\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"<pool::Pool<T> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result{\n        f.debug_struct(\"Pool\")\n            .field(\"stack\", &self.stack)\n            .field(\"owner\", &self.owner)\n            .field(\"owner_val\", &self.owner_val)\n            .finish()\n    }","Real(LocalPath(\"src/pool.rs\"))"],"<pool::PoolGuard<'a, T> as std::ops::Drop>::drop":["inline(always)\nfn drop(&mut self){\n        if let Some(value) = self.value.take() {\n            self.pool.put(value);\n        }\n    }","Real(LocalPath(\"src/pool.rs\"))"],"<prog::Program as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        use self::Inst::*;\n\n        fn with_goto(cur: usize, goto: usize, fmtd: String) -> String {\n            if goto == cur + 1 {\n                fmtd\n            } else {\n                format!(\"{} (goto: {})\", fmtd, goto)\n            }\n        }\n\n        fn visible_byte(b: u8) -> String {\n            use std::ascii::escape_default;\n            let escaped = escape_default(b).collect::<Vec<u8>>();\n            String::from_utf8_lossy(&escaped).into_owned()\n        }\n\n        for (pc, inst) in self.iter().enumerate() {\n            match *inst {\n                Match(slot) => write!(f, \"{:04} Match({:?})\", pc, slot)?,\n                Save(ref inst) => {\n                    let s = format!(\"{:04} Save({})\", pc, inst.slot);\n                    write!(f, \"{}\", with_goto(pc, inst.goto, s))?;\n                }\n                Split(ref inst) => {\n                    write!(\n                        f,\n                        \"{:04} Split({}, {})\",\n                        pc, inst.goto1, inst.goto2\n                    )?;\n                }\n                EmptyLook(ref inst) => {\n                    let s = format!(\"{:?}\", inst.look);\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n                Char(ref inst) => {\n                    let s = format!(\"{:?}\", inst.c);\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n                Ranges(ref inst) => {\n                    let ranges = inst\n                        .ranges\n                        .iter()\n                        .map(|r| format!(\"{:?}-{:?}\", r.0, r.1))\n                        .collect::<Vec<String>>()\n                        .join(\", \");\n                    write!(\n                        f,\n                        \"{:04} {}\",\n                        pc,\n                        with_goto(pc, inst.goto, ranges)\n                    )?;\n                }\n                Bytes(ref inst) => {\n                    let s = format!(\n                        \"Bytes({}, {})\",\n                        visible_byte(inst.start),\n                        visible_byte(inst.end)\n                    );\n                    write!(f, \"{:04} {}\", pc, with_goto(pc, inst.goto, s))?;\n                }\n            }\n            if pc == self.start {\n                write!(f, \" (start)\")?;\n            }\n            writeln!(f)?;\n        }\n        Ok(())\n    }","Real(LocalPath(\"src/prog.rs\"))"],"<prog::Program as std::fmt::Debug>::fmt::visible_byte":["fn visible_byte(b: u8) -> String{\n            use std::ascii::escape_default;\n            let escaped = escape_default(b).collect::<Vec<u8>>();\n            String::from_utf8_lossy(&escaped).into_owned()\n        }","Real(LocalPath(\"src/prog.rs\"))"],"<prog::Program as std::fmt::Debug>::fmt::with_goto":["fn with_goto(cur: usize, goto: usize, fmtd: String) -> String{\n            if goto == cur + 1 {\n                fmtd\n            } else {\n                format!(\"{} (goto: {})\", fmtd, goto)\n            }\n        }","Real(LocalPath(\"src/prog.rs\"))"],"<prog::Program as std::ops::Deref>::deref":["inline(always)\nfn deref(&self) -> &Self::Target{\n        &*self.insts\n    }","Real(LocalPath(\"src/prog.rs\"))"],"<re_builder::RegexOptions as std::default::Default>::default":["fn default() -> Self{\n        RegexOptions {\n            pats: vec![],\n            size_limit: 10 * (1 << 20),\n            dfa_size_limit: 2 * (1 << 20),\n            nest_limit: 250,\n            case_insensitive: false,\n            multi_line: false,\n            dot_matches_new_line: false,\n            swap_greed: false,\n            ignore_whitespace: false,\n            unicode: true,\n            octal: false,\n        }\n    }","Real(LocalPath(\"src/re_builder.rs\"))"],"<re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Captures<'t>>{\n        self.0.next().map(|locs| Captures {\n            text: self.0.text(),\n            locs,\n            named_groups: self.0.regex().capture_name_idx().clone(),\n        })\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        self.0.count()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Option<&'r str>>{\n        self.0\n            .next()\n            .as_ref()\n            .map(|slot| slot.as_ref().map(|name| name.as_ref()))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Captures<'t> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"Captures\").field(&CapturesDebug(self)).finish()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index":["fn index<'a>(&'a self, name: &'i str) -> &'a [u8]{\n        self.name(name)\n            .map(|m| m.as_bytes())\n            .unwrap_or_else(|| panic!(\"no group named '{}'\", name))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Captures<'t> as std::ops::Index<usize>>::index":["fn index(&self, i: usize) -> &[u8]{\n        self.get(i)\n            .map(|m| m.as_bytes())\n            .unwrap_or_else(|| panic!(\"no group at index '{}'\", i))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fn escape_bytes(bytes: &[u8]) -> String {\n            let mut s = String::new();\n            for &b in bytes {\n                s.push_str(&escape_byte(b));\n            }\n            s\n        }\n\n        fn escape_byte(byte: u8) -> String {\n            use std::ascii::escape_default;\n\n            let escaped: Vec<u8> = escape_default(byte).collect();\n            String::from_utf8_lossy(&escaped).into_owned()\n        }\n\n        // We'd like to show something nice here, even if it means an\n        // allocation to build a reverse index.\n        let slot_to_name: HashMap<&usize, &String> =\n            self.0.named_groups.iter().map(|(a, b)| (b, a)).collect();\n        let mut map = f.debug_map();\n        for (slot, m) in self.0.locs.iter().enumerate() {\n            let m = m.map(|(s, e)| escape_bytes(&self.0.text[s..e]));\n            if let Some(name) = slot_to_name.get(&slot) {\n                map.entry(&name, &m);\n            } else {\n                map.entry(&slot, &m);\n            }\n        }\n        map.finish()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte":["fn escape_byte(byte: u8) -> String{\n            use std::ascii::escape_default;\n\n            let escaped: Vec<u8> = escape_default(byte).collect();\n            String::from_utf8_lossy(&escaped).into_owned()\n        }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes":["fn escape_bytes(bytes: &[u8]) -> String{\n            let mut s = String::new();\n            for &b in bytes {\n                s.push_str(&escape_byte(b));\n            }\n            s\n        }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Match<'t> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        let mut fmt = f.debug_struct(\"Match\");\n        fmt.field(\"start\", &self.start).field(\"end\", &self.end);\n        if let Ok(s) = std::str::from_utf8(self.as_bytes()) {\n            fmt.field(\"bytes\", &s);\n        } else {\n            // FIXME: It would be nice if this could be printed as a string\n            // with invalid UTF-8 replaced with hex escapes. A alloc would\n            // probably okay if that makes it easier, but regex-automata does\n            // (at time of writing) have internal routines that do this. So\n            // maybe we should expose them.\n            fmt.field(\"bytes\", &self.as_bytes());\n        }\n        fmt.finish()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Matches<'r, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Match<'t>>{\n        let text = self.0.text();\n        self.0.next().map(|(s, e)| Match::new(text, s, e))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>>{\n        Some(Cow::Borrowed(self.0))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append":["fn replace_append(&mut self, _: &Captures<'_>, dst: &mut Vec<u8>){\n        dst.extend_from_slice(self.0);\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Regex as std::convert::From<exec::Exec>>::from":["fn from(exec: Exec) -> Regex{\n        Regex(exec)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Regex as std::fmt::Debug>::fmt":["/// Shows the original regular expression.\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Regex as std::fmt::Display>::fmt":["/// Shows the original regular expression.\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{}\", self.as_str())\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Regex as std::str::FromStr>::from_str":["/// Attempts to parse a string into a regular expression\nfn from_str(s: &str) -> Result<Regex, Error>{\n        Regex::new(s)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion":["fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>>{\n        self.0.no_expansion()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>){\n        self.0.replace_append(caps, dst)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::Split<'r, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'t [u8]>{\n        let text = self.finder.0.text();\n        match self.finder.next() {\n            None => {\n                if self.last > text.len() {\n                    None\n                } else {\n                    let s = &text[self.last..];\n                    self.last = text.len() + 1; // Next call will return None\n                    Some(s)\n                }\n            }\n            Some(m) => {\n                let matched = &text[self.last..m.start()];\n                self.last = m.end();\n                Some(matched)\n            }\n        }\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'t [u8]>{\n        if self.n == 0 {\n            return None;\n        }\n\n        self.n -= 1;\n        if self.n > 0 {\n            return self.splits.next();\n        }\n\n        let text = self.splits.finder.0.text();\n        if self.splits.last > text.len() {\n            // We've already returned all substrings.\n            None\n        } else {\n            // self.n == 0, so future calls will return None immediately\n            Some(&text[self.splits.last..])\n        }\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (0, Some(self.n))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Option<Match<'t>>>{\n        self.it\n            .next()\n            .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from":["fn from(exec: Exec) -> Self{\n        RegexSet(exec)\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::RegexSet as std::default::Default>::default":["fn default() -> Self{\n        RegexSet::empty()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::RegexSet as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        SetMatchesIntoIter(self.matches.into_iter().enumerate())\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<usize>{\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next":["fn next(&mut self) -> Option<usize>{\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<usize>{\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<usize>{\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from":["fn from(exec: Exec) -> Self{\n        RegexSet(exec)\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::RegexSet as std::default::Default>::default":["fn default() -> Self{\n        RegexSet::empty()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::RegexSet as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"RegexSet({:?})\", self.0.regex_strings())\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter":["fn into_iter(self) -> Self::IntoIter{\n        SetMatchesIntoIter(self.matches.into_iter().enumerate())\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<usize>{\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next":["fn next(&mut self) -> Option<usize>{\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, false)) => {}\n                Some((i, true)) => return Some(i),\n            }\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back":["fn next_back(&mut self) -> Option<usize>{\n        loop {\n            match self.0.next_back() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<usize>{\n        loop {\n            match self.0.next() {\n                None => return None,\n                Some((_, &false)) => {}\n                Some((i, &true)) => return Some(i),\n            }\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Locations>{\n        if self.0.last_end > self.0.text.as_ref().len() {\n            return None;\n        }\n        let mut locs = self.0.re.locations();\n        let (s, e) = match self.0.re.captures_read_at(\n            &mut locs,\n            self.0.text,\n            self.0.last_end,\n        ) {\n            None => return None,\n            Some((s, e)) => (s, e),\n        };\n        if s == e {\n            self.0.last_end = self.0.re.next_after_empty(self.0.text, e);\n            if Some(e) == self.0.last_match {\n                return self.next();\n            }\n        } else {\n            self.0.last_end = e;\n        }\n        self.0.last_match = Some(e);\n        Some(locs)\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"<re_trait::Matches<'t, R> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<(usize, usize)>{\n        if self.last_end > self.text.as_ref().len() {\n            return None;\n        }\n        let (s, e) = match self.re.find_at(self.text, self.last_end) {\n            None => return None,\n            Some((s, e)) => (s, e),\n        };\n        if s == e {\n            // This is an empty match. To ensure we make progress, start\n            // the next search at the smallest possible starting position\n            // of the next match following this one.\n            self.last_end = self.re.next_after_empty(self.text, e);\n            // Don't accept empty matches immediately following a match.\n            // Just move on to the next match.\n            if Some(e) == self.last_match {\n                return self.next();\n            }\n        } else {\n            self.last_end = e;\n        }\n        self.last_match = Some(e);\n        Some((s, e))\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        self.len()\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Option<(usize, usize)>>{\n        if self.idx >= self.locs.len() {\n            return None;\n        }\n        let x = match self.locs.pos(self.idx) {\n            None => Some(None),\n            Some((s, e)) => Some(Some((s, e))),\n        };\n        self.idx += 1;\n        x\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        let len = self.locs.len() - self.idx;\n        (len, Some(len))\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"<re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Captures<'t>>{\n        self.0.next().map(|locs| Captures {\n            text: self.0.text(),\n            locs,\n            named_groups: self.0.regex().capture_name_idx().clone(),\n        })\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        self.0.count()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Option<&'r str>>{\n        self.0\n            .next()\n            .as_ref()\n            .map(|slot| slot.as_ref().map(|name| name.as_ref()))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.0.size_hint()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Captures<'t> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        f.debug_tuple(\"Captures\").field(&CapturesDebug(self)).finish()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index":["fn index<'a>(&'a self, name: &'i str) -> &'a str{\n        self.name(name)\n            .map(|m| m.as_str())\n            .unwrap_or_else(|| panic!(\"no group named '{}'\", name))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Captures<'t> as std::ops::Index<usize>>::index":["fn index(&self, i: usize) -> &str{\n        self.get(i)\n            .map(|m| m.as_str())\n            .unwrap_or_else(|| panic!(\"no group at index '{}'\", i))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        // We'd like to show something nice here, even if it means an\n        // allocation to build a reverse index.\n        let slot_to_name: HashMap<&usize, &String> =\n            self.0.named_groups.iter().map(|(a, b)| (b, a)).collect();\n        let mut map = f.debug_map();\n        for (slot, m) in self.0.locs.iter().enumerate() {\n            let m = m.map(|(s, e)| &self.0.text[s..e]);\n            if let Some(name) = slot_to_name.get(&slot) {\n                map.entry(&name, &m);\n            } else {\n                map.entry(&slot, &m);\n            }\n        }\n        map.finish()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Match<'t> as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result{\n        f.debug_struct(\"Match\")\n            .field(\"start\", &self.start)\n            .field(\"end\", &self.end)\n            .field(\"string\", &self.as_str())\n            .finish()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Matches<'r, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Match<'t>>{\n        let text = self.0.text();\n        self.0.next().map(|(s, e)| Match::new(text, s, e))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, str>>{\n        Some(Cow::Borrowed(self.0))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append":["fn replace_append(&mut self, _: &Captures<'_>, dst: &mut String){\n        dst.push_str(self.0);\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Regex as std::convert::From<exec::Exec>>::from":["fn from(exec: Exec) -> Regex{\n        Regex(exec)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Regex as std::fmt::Debug>::fmt":["/// Shows the original regular expression.\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        fmt::Display::fmt(self, f)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Regex as std::fmt::Display>::fmt":["/// Shows the original regular expression.\nfn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"{}\", self.as_str())\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Regex as std::str::FromStr>::from_str":["/// Attempts to parse a string into a regular expression\nfn from_str(s: &str) -> Result<Regex, Error>{\n        Regex::new(s)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, str>>{\n        self.0.no_expansion()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String){\n        self.0.replace_append(caps, dst)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::Split<'r, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'t str>{\n        let text = self.finder.0.text();\n        match self.finder.next() {\n            None => {\n                if self.last > text.len() {\n                    None\n                } else {\n                    let s = &text[self.last..];\n                    self.last = text.len() + 1; // Next call will return None\n                    Some(s)\n                }\n            }\n            Some(m) => {\n                let matched = &text[self.last..m.start()];\n                self.last = m.end();\n                Some(matched)\n            }\n        }\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<&'t str>{\n        if self.n == 0 {\n            return None;\n        }\n\n        self.n -= 1;\n        if self.n > 0 {\n            return self.splits.next();\n        }\n\n        let text = self.splits.finder.0.text();\n        if self.splits.last > text.len() {\n            // We've already returned all substrings.\n            None\n        } else {\n            // self.n == 0, so future calls will return None immediately\n            Some(&text[self.splits.last..])\n        }\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        (0, Some(self.n))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::count":["fn count(self) -> usize{\n        self.it.count()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next":["fn next(&mut self) -> Option<Option<Match<'t>>>{\n        self.it\n            .next()\n            .map(|cap| cap.map(|(s, e)| Match::new(self.caps.text, s, e)))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::size_hint":["fn size_hint(&self) -> (usize, Option<usize>){\n        self.it.size_hint()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<sparse::SparseSet as std::fmt::Debug>::fmt":["fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result{\n        write!(f, \"SparseSet({:?})\", self.dense)\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"<sparse::SparseSet as std::ops::Deref>::deref":["fn deref(&self) -> &Self::Target{\n        &self.dense\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>){\n        caps.expand(self.as_ref(), dst);\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, str>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String){\n        self.as_ref().replace_append(caps, dst)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<std::string::String as re_unicode::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, str>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<std::string::String as re_unicode::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String){\n        self.as_str().replace_append(caps, dst)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"<std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion":["fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>>{\n        no_expansion(self)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"<std::vec::Vec<u8> as re_bytes::Replacer>::replace_append":["fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>){\n        caps.expand(self, dst);\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"backtrack::Bounded":["/// A backtracking matching engine.\npub struct Bounded<'a, 'm, 'r, 's, I> {\n    prog: &'r Program,\n    input: I,\n    matches: &'m mut [bool],\n    slots: &'s mut [Slot],\n    m: &'a mut Cache,\n}","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack":["/// The main backtracking loop starting at the given input position.\nfn backtrack(&mut self, start: InputAt) -> bool{\n        // N.B. We use an explicit stack to avoid recursion.\n        // To avoid excessive pushing and popping, most transitions are handled\n        // in the `step` helper function, which only pushes to the stack when\n        // there's a capture or a branch.\n        let mut matched = false;\n        self.m.jobs.push(Job::Inst { ip: 0, at: start });\n        while let Some(job) = self.m.jobs.pop() {\n            match job {\n                Job::Inst { ip, at } => {\n                    if self.step(ip, at) {\n                        // Only quit if we're matching one regex.\n                        // If we're matching a regex set, then mush on and\n                        // try to find other matches (if we want them).\n                        if self.prog.matches.len() == 1 {\n                            return true;\n                        }\n                        matched = true;\n                    }\n                }\n                Job::SaveRestore { slot, old_pos } => {\n                    if slot < self.slots.len() {\n                        self.slots[slot] = old_pos;\n                    }\n                }\n            }\n        }\n        matched\n    }","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear":["/// Clears the cache such that the backtracking engine can be executed\n/// on some input of fixed length.\nfn clear(&mut self){\n        // Reset the job memory so that we start fresh.\n        self.m.jobs.clear();\n\n        // Now we need to clear the bit state set.\n        // We do this by figuring out how much space we need to keep track\n        // of the states we've visited.\n        // Then we reset all existing allocated space to 0.\n        // Finally, we request more space if we need it.\n        //\n        // This is all a little circuitous, but doing this using unchecked\n        // operations doesn't seem to have a measurable impact on performance.\n        // (Probably because backtracking is limited to such small\n        // inputs/regexes in the first place.)\n        let visited_len =\n            (self.prog.len() * (self.input.len() + 1) + BIT_SIZE - 1)\n                / BIT_SIZE;\n        self.m.visited.truncate(visited_len);\n        for v in &mut self.m.visited {\n            *v = 0;\n        }\n        if visited_len > self.m.visited.len() {\n            let len = self.m.visited.len();\n            self.m.visited.reserve_exact(visited_len - len);\n            for _ in 0..(visited_len - len) {\n                self.m.visited.push(0);\n            }\n        }\n    }","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec":["/// Execute the backtracking matching engine.\n///\n/// If there's a match, `exec` returns `true` and populates the given\n/// captures accordingly.\npub fn exec(\n        prog: &'r Program,\n        cache: &ProgramCache,\n        matches: &'m mut [bool],\n        slots: &'s mut [Slot],\n        input: I,\n        start: usize,\n        end: usize,\n    ) -> bool{\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.backtrack;\n        let start = input.at(start);\n        let mut b = Bounded { prog, input, matches, slots, m: cache };\n        b.exec_(start, end)\n    }","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_":["/// Start backtracking at the given position in the input, but also look\n/// for literal prefixes.\nfn exec_(&mut self, mut at: InputAt, end: usize) -> bool{\n        self.clear();\n        // If this is an anchored regex at the beginning of the input, then\n        // we're either already done or we only need to try backtracking once.\n        if self.prog.is_anchored_start {\n            return if !at.is_start() { false } else { self.backtrack(at) };\n        }\n        let mut matched = false;\n        loop {\n            if !self.prog.prefixes.is_empty() {\n                at = match self.input.prefix_at(&self.prog.prefixes, at) {\n                    None => break,\n                    Some(at) => at,\n                };\n            }\n            matched = self.backtrack(at) || matched;\n            if matched && self.prog.matches.len() == 1 {\n                return true;\n            }\n            if at.pos() >= end {\n                break;\n            }\n            at = self.input.at(at.next_pos());\n        }\n        matched\n    }","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited":["fn has_visited(&mut self, ip: InstPtr, at: InputAt) -> bool{\n        let k = ip * (self.input.len() + 1) + at.pos();\n        let k1 = k / BIT_SIZE;\n        let k2 = usize_to_u32(1 << (k & (BIT_SIZE - 1)));\n        if self.m.visited[k1] & k2 == 0 {\n            self.m.visited[k1] |= k2;\n            false\n        } else {\n            true\n        }\n    }","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::step":["fn step(&mut self, mut ip: InstPtr, mut at: InputAt) -> bool{\n        use crate::prog::Inst::*;\n        loop {\n            // This loop is an optimization to avoid constantly pushing/popping\n            // from the stack. Namely, if we're pushing a job only to run it\n            // next, avoid the push and just mutate `ip` (and possibly `at`)\n            // in place.\n            if self.has_visited(ip, at) {\n                return false;\n            }\n            match self.prog[ip] {\n                Match(slot) => {\n                    if slot < self.matches.len() {\n                        self.matches[slot] = true;\n                    }\n                    return true;\n                }\n                Save(ref inst) => {\n                    if let Some(&old_pos) = self.slots.get(inst.slot) {\n                        // If this path doesn't work out, then we save the old\n                        // capture index (if one exists) in an alternate\n                        // job. If the next path fails, then the alternate\n                        // job is popped and the old capture index is restored.\n                        self.m.jobs.push(Job::SaveRestore {\n                            slot: inst.slot,\n                            old_pos,\n                        });\n                        self.slots[inst.slot] = Some(at.pos());\n                    }\n                    ip = inst.goto;\n                }\n                Split(ref inst) => {\n                    self.m.jobs.push(Job::Inst { ip: inst.goto2, at });\n                    ip = inst.goto1;\n                }\n                EmptyLook(ref inst) => {\n                    if self.input.is_empty_match(at, inst) {\n                        ip = inst.goto;\n                    } else {\n                        return false;\n                    }\n                }\n                Char(ref inst) => {\n                    if inst.c == at.char() {\n                        ip = inst.goto;\n                        at = self.input.at(at.next_pos());\n                    } else {\n                        return false;\n                    }\n                }\n                Ranges(ref inst) => {\n                    if inst.matches(at.char()) {\n                        ip = inst.goto;\n                        at = self.input.at(at.next_pos());\n                    } else {\n                        return false;\n                    }\n                }\n                Bytes(ref inst) => {\n                    if let Some(b) = at.byte() {\n                        if inst.matches(b) {\n                            ip = inst.goto;\n                            at = self.input.at(at.next_pos());\n                            continue;\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Cache":["/// Shared cached state between multiple invocations of a backtracking engine\n/// in the same thread.\npub struct Cache {\n    jobs: Vec<Job>,\n    visited: Vec<Bits>,\n}","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Cache::new":["/// Create new empty cache for the backtracking engine.\npub fn new(_prog: &Program) -> Self{\n        Cache { jobs: vec![], visited: vec![] }\n    }","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::Job":["/// A job is an explicit unit of stack space in the backtracking engine.\n///\n/// The \"normal\" representation is a single state transition, which corresponds\n/// to an NFA state and a character in the input. However, the backtracking\n/// engine must keep track of old capture group values. We use the explicit\n/// stack to do it.\nenum Job {\n    Inst { ip: InstPtr, at: InputAt },\n    SaveRestore { slot: usize, old_pos: Option<usize> },\n}","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::should_exec":["/// Returns true iff the given regex and input should be executed by this\n/// engine with reasonable memory usage.\npub fn should_exec(num_insts: usize, text_len: usize) -> bool{\n    // Total memory usage in bytes is determined by:\n    //\n    //   ((len(insts) * (len(input) + 1) + bits - 1) / bits) * (size_of(u32))\n    //\n    // The actual limit picked is pretty much a heuristic.\n    // See: https://github.com/rust-lang/regex/issues/215\n    let size = ((num_insts * (text_len + 1) + BIT_SIZE - 1) / BIT_SIZE) * 4;\n    size <= MAX_SIZE_BYTES\n}","Real(LocalPath(\"src/backtrack.rs\"))"],"backtrack::usize_to_u32":["fn usize_to_u32(n: usize) -> u32{\n    if (n as u64) > (::std::u32::MAX as u64) {\n        panic!(\"BUG: {} is too big to fit into u32\", n)\n    }\n    n as u32\n}","Real(LocalPath(\"src/backtrack.rs\"))"],"compile::ByteClassSet":["struct ByteClassSet([bool; 256]);","Real(LocalPath(\"src/compile.rs\"))"],"compile::ByteClassSet::byte_classes":["fn byte_classes(&self) -> Vec<u8>{\n        // N.B. If you're debugging the DFA, it's useful to simply return\n        // `(0..256).collect()`, which effectively removes the byte classes\n        // and makes the transitions easier to read.\n        // (0usize..256).map(|x| x as u8).collect()\n        let mut byte_classes = vec![0; 256];\n        let mut class = 0u8;\n        let mut i = 0;\n        loop {\n            byte_classes[i] = class as u8;\n            if i >= 255 {\n                break;\n            }\n            if self.0[i] {\n                class = class.checked_add(1).unwrap();\n            }\n            i += 1;\n        }\n        byte_classes\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::ByteClassSet::new":["fn new() -> Self{\n        ByteClassSet([false; 256])\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::ByteClassSet::set_range":["fn set_range(&mut self, start: u8, end: u8){\n        debug_assert!(start <= end);\n        if start > 0 {\n            self.0[start as usize - 1] = true;\n        }\n        self.0[end as usize] = true;\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::ByteClassSet::set_word_boundary":["fn set_word_boundary(&mut self){\n        // We need to mark all ranges of bytes whose pairs result in\n        // evaluating \\b differently.\n        let iswb = is_word_byte;\n        let mut b1: u16 = 0;\n        let mut b2: u16;\n        while b1 <= 255 {\n            b2 = b1 + 1;\n            while b2 <= 255 && iswb(b1 as u8) == iswb(b2 as u8) {\n                b2 += 1;\n            }\n            self.set_range(b1 as u8, (b2 - 1) as u8);\n            b1 = b2;\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::CompileClass":["struct CompileClass<'a, 'b> {\n    c: &'a mut Compiler,\n    ranges: &'b [hir::ClassUnicodeRange],\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::CompileClass::<'a, 'b>::c_utf8_seq":["fn c_utf8_seq(&mut self, seq: &Utf8Sequence) -> Result{\n        if self.c.compiled.is_reverse {\n            self.c_utf8_seq_(seq)\n        } else {\n            self.c_utf8_seq_(seq.into_iter().rev())\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::CompileClass::<'a, 'b>::c_utf8_seq_":["fn c_utf8_seq_<'r, I>(&mut self, seq: I) -> Result\n    where\n        I: IntoIterator<Item = &'r Utf8Range>,{\n        // The initial instruction for each UTF-8 sequence should be the same.\n        let mut from_inst = ::std::usize::MAX;\n        let mut last_hole = Hole::None;\n        for byte_range in seq {\n            let key = SuffixCacheKey {\n                from_inst,\n                start: byte_range.start,\n                end: byte_range.end,\n            };\n            {\n                let pc = self.c.insts.len();\n                if let Some(cached_pc) = self.c.suffix_cache.get(key, pc) {\n                    from_inst = cached_pc;\n                    continue;\n                }\n            }\n            self.c.byte_classes.set_range(byte_range.start, byte_range.end);\n            if from_inst == ::std::usize::MAX {\n                last_hole = self.c.push_hole(InstHole::Bytes {\n                    start: byte_range.start,\n                    end: byte_range.end,\n                });\n            } else {\n                self.c.push_compiled(Inst::Bytes(InstBytes {\n                    goto: from_inst,\n                    start: byte_range.start,\n                    end: byte_range.end,\n                }));\n            }\n            from_inst = self.c.insts.len().checked_sub(1).unwrap();\n            debug_assert!(from_inst < ::std::usize::MAX);\n        }\n        debug_assert!(from_inst < ::std::usize::MAX);\n        Ok(Patch { hole: last_hole, entry: from_inst })\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::CompileClass::<'a, 'b>::compile":["fn compile(mut self) -> Result{\n        let mut holes = vec![];\n        let mut initial_entry = None;\n        let mut last_split = Hole::None;\n        let mut utf8_seqs = self.c.utf8_seqs.take().unwrap();\n        self.c.suffix_cache.clear();\n\n        for (i, range) in self.ranges.iter().enumerate() {\n            let is_last_range = i + 1 == self.ranges.len();\n            utf8_seqs.reset(range.start(), range.end());\n            let mut it = (&mut utf8_seqs).peekable();\n            loop {\n                let utf8_seq = match it.next() {\n                    None => break,\n                    Some(utf8_seq) => utf8_seq,\n                };\n                if is_last_range && it.peek().is_none() {\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    self.c.fill(last_split, entry);\n                    last_split = Hole::None;\n                    if initial_entry.is_none() {\n                        initial_entry = Some(entry);\n                    }\n                } else {\n                    if initial_entry.is_none() {\n                        initial_entry = Some(self.c.insts.len());\n                    }\n                    self.c.fill_to_next(last_split);\n                    last_split = self.c.push_split_hole();\n                    let Patch { hole, entry } = self.c_utf8_seq(&utf8_seq)?;\n                    holes.push(hole);\n                    last_split =\n                        self.c.fill_split(last_split, Some(entry), None);\n                }\n            }\n        }\n        self.c.utf8_seqs = Some(utf8_seqs);\n        Ok(Patch { hole: Hole::Many(holes), entry: initial_entry.unwrap() })\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler":["/// A compiler translates a regular expression AST to a sequence of\n/// instructions. The sequence of instructions represents an NFA.\n#[allow(missing_debug_implementations)]\npub struct Compiler {\n    insts: Vec<MaybeInst>,\n    compiled: Program,\n    capture_name_idx: HashMap<String, usize>,\n    num_exprs: usize,\n    size_limit: usize,\n    suffix_cache: SuffixCache,\n    utf8_seqs: Option<Utf8Sequences>,\n    byte_classes: ByteClassSet,\n    // This keeps track of extra bytes allocated while compiling the regex\n    // program. Currently, this corresponds to two things. First is the heap\n    // memory allocated by Unicode character classes ('InstRanges'). Second is\n    // a \"fake\" amount of memory used by empty sub-expressions, so that enough\n    // empty sub-expressions will ultimately trigger the compiler to bail\n    // because of a size limit restriction. (That empty sub-expressions don't\n    // add to heap memory usage is more-or-less an implementation detail.) In\n    // the second case, if we don't bail, then an excessively large repetition\n    // on an empty sub-expression can result in the compiler using a very large\n    // amount of CPU time.\n    extra_inst_bytes: usize,\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::bytes":["/// If bytes is true, then the program is compiled as a byte based\n/// automaton, which incorporates UTF-8 decoding into the machine. If it's\n/// false, then the automaton is Unicode scalar value based, e.g., an\n/// engine utilizing such an automaton is responsible for UTF-8 decoding.\n///\n/// The specific invariant is that when returning a byte based machine,\n/// the neither the `Char` nor `Ranges` instructions are produced.\n/// Conversely, when producing a Unicode scalar value machine, the `Bytes`\n/// instruction is never produced.\n///\n/// Note that `dfa(true)` implies `bytes(true)`.\npub fn bytes(mut self, yes: bool) -> Self{\n        self.compiled.is_bytes = yes;\n        self\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c":["/// Compile expr into self.insts, returning a patch on success,\n/// or an error if we run out of memory.\n///\n/// All of the c_* methods of the compiler share the contract outlined\n/// here.\n///\n/// The main thing that a c_* method does is mutate `self.insts`\n/// to add a list of mostly compiled instructions required to execute\n/// the given expression. `self.insts` contains MaybeInsts rather than\n/// Insts because there is some backpatching required.\n///\n/// The `Patch` value returned by each c_* method provides metadata\n/// about the compiled instructions emitted to `self.insts`. The\n/// `entry` member of the patch refers to the first instruction\n/// (the entry point), while the `hole` member contains zero or\n/// more offsets to partial instructions that need to be backpatched.\n/// The c_* routine can't know where its list of instructions are going to\n/// jump to after execution, so it is up to the caller to patch\n/// these jumps to point to the right place. So compiling some\n/// expression, e, we would end up with a situation that looked like:\n///\n/// ```text\n/// self.insts = [ ..., i1, i2, ..., iexit1, ..., iexitn, ...]\n///                     ^              ^             ^\n///                     |                \\         /\n///                   entry                \\     /\n///                                         hole\n/// ```\n///\n/// To compile two expressions, e1 and e2, concatenated together we\n/// would do:\n///\n/// ```ignore\n/// let patch1 = self.c(e1);\n/// let patch2 = self.c(e2);\n/// ```\n///\n/// while leaves us with a situation that looks like\n///\n/// ```text\n/// self.insts = [ ..., i1, ..., iexit1, ..., i2, ..., iexit2 ]\n///                     ^        ^            ^        ^\n///                     |        |            |        |\n///                entry1        hole1   entry2        hole2\n/// ```\n///\n/// Then to merge the two patches together into one we would backpatch\n/// hole1 with entry2 and return a new patch that enters at entry1\n/// and has hole2 for a hole. In fact, if you look at the c_concat\n/// method you will see that it does exactly this, though it handles\n/// a list of expressions rather than just the two that we use for\n/// an example.\n///\n/// Ok(None) is returned when an expression is compiled to no\n/// instruction, and so no patch.entry value makes sense.\nfn c(&mut self, expr: &Hir) -> ResultOrEmpty{\n        use crate::prog;\n        use regex_syntax::hir::HirKind::*;\n\n        self.check_size()?;\n        match *expr.kind() {\n            Empty => self.c_empty(),\n            Literal(hir::Literal(ref bytes)) => {\n                if self.compiled.is_reverse {\n                    let mut bytes = bytes.to_vec();\n                    bytes.reverse();\n                    self.c_literal(&bytes)\n                } else {\n                    self.c_literal(bytes)\n                }\n            }\n            Class(hir::Class::Unicode(ref cls)) => self.c_class(cls.ranges()),\n            Class(hir::Class::Bytes(ref cls)) => {\n                if self.compiled.uses_bytes() {\n                    self.c_class_bytes(cls.ranges())\n                } else {\n                    assert!(cls.is_ascii());\n                    let mut char_ranges = vec![];\n                    for r in cls.iter() {\n                        let (s, e) = (r.start() as char, r.end() as char);\n                        char_ranges.push(hir::ClassUnicodeRange::new(s, e));\n                    }\n                    self.c_class(&char_ranges)\n                }\n            }\n            Look(ref look) => match *look {\n                hir::Look::Start if self.compiled.is_reverse => {\n                    self.c_empty_look(prog::EmptyLook::EndText)\n                }\n                hir::Look::Start => {\n                    self.c_empty_look(prog::EmptyLook::StartText)\n                }\n                hir::Look::End if self.compiled.is_reverse => {\n                    self.c_empty_look(prog::EmptyLook::StartText)\n                }\n                hir::Look::End => self.c_empty_look(prog::EmptyLook::EndText),\n                hir::Look::StartLF if self.compiled.is_reverse => {\n                    self.byte_classes.set_range(b'\\n', b'\\n');\n                    self.c_empty_look(prog::EmptyLook::EndLine)\n                }\n                hir::Look::StartLF => {\n                    self.byte_classes.set_range(b'\\n', b'\\n');\n                    self.c_empty_look(prog::EmptyLook::StartLine)\n                }\n                hir::Look::EndLF if self.compiled.is_reverse => {\n                    self.byte_classes.set_range(b'\\n', b'\\n');\n                    self.c_empty_look(prog::EmptyLook::StartLine)\n                }\n                hir::Look::EndLF => {\n                    self.byte_classes.set_range(b'\\n', b'\\n');\n                    self.c_empty_look(prog::EmptyLook::EndLine)\n                }\n                hir::Look::StartCRLF | hir::Look::EndCRLF => {\n                    return Err(Error::Syntax(\n                        \"CRLF-aware line anchors are not supported yet\"\n                            .to_string(),\n                    ));\n                }\n                hir::Look::WordAscii => {\n                    self.byte_classes.set_word_boundary();\n                    self.c_empty_look(prog::EmptyLook::WordBoundaryAscii)\n                }\n                hir::Look::WordAsciiNegate => {\n                    self.byte_classes.set_word_boundary();\n                    self.c_empty_look(prog::EmptyLook::NotWordBoundaryAscii)\n                }\n                hir::Look::WordUnicode => {\n                    if !cfg!(feature = \"unicode-perl\") {\n                        return Err(Error::Syntax(\n                            \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                                .to_string(),\n                        ));\n                    }\n                    self.compiled.has_unicode_word_boundary = true;\n                    self.byte_classes.set_word_boundary();\n                    // We also make sure that all ASCII bytes are in a different\n                    // class from non-ASCII bytes. Otherwise, it's possible for\n                    // ASCII bytes to get lumped into the same class as non-ASCII\n                    // bytes. This in turn may cause the lazy DFA to falsely start\n                    // when it sees an ASCII byte that maps to a byte class with\n                    // non-ASCII bytes. This ensures that never happens.\n                    self.byte_classes.set_range(0, 0x7F);\n                    self.c_empty_look(prog::EmptyLook::WordBoundary)\n                }\n                hir::Look::WordUnicodeNegate => {\n                    if !cfg!(feature = \"unicode-perl\") {\n                        return Err(Error::Syntax(\n                            \"Unicode word boundaries are unavailable when \\\n                         the unicode-perl feature is disabled\"\n                                .to_string(),\n                        ));\n                    }\n                    self.compiled.has_unicode_word_boundary = true;\n                    self.byte_classes.set_word_boundary();\n                    // See comments above for why we set the ASCII range here.\n                    self.byte_classes.set_range(0, 0x7F);\n                    self.c_empty_look(prog::EmptyLook::NotWordBoundary)\n                }\n            },\n            Capture(hir::Capture { index, ref name, ref sub }) => {\n                if index as usize >= self.compiled.captures.len() {\n                    let name = match *name {\n                        None => None,\n                        Some(ref boxed_str) => Some(boxed_str.to_string()),\n                    };\n                    self.compiled.captures.push(name.clone());\n                    if let Some(name) = name {\n                        self.capture_name_idx.insert(name, index as usize);\n                    }\n                }\n                self.c_capture(2 * index as usize, sub)\n            }\n            Concat(ref es) => {\n                if self.compiled.is_reverse {\n                    self.c_concat(es.iter().rev())\n                } else {\n                    self.c_concat(es)\n                }\n            }\n            Alternation(ref es) => self.c_alternate(&**es),\n            Repetition(ref rep) => self.c_repeat(rep),\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_alternate":["fn c_alternate(&mut self, exprs: &[Hir]) -> ResultOrEmpty{\n        debug_assert!(\n            exprs.len() >= 2,\n            \"alternates must have at least 2 exprs\"\n        );\n\n        // Initial entry point is always the first split.\n        let first_split_entry = self.insts.len();\n\n        // Save up all of the holes from each alternate. They will all get\n        // patched to point to the same location.\n        let mut holes = vec![];\n\n        // true indicates that the hole is a split where we want to fill\n        // the second branch.\n        let mut prev_hole = (Hole::None, false);\n        for e in &exprs[0..exprs.len() - 1] {\n            if prev_hole.1 {\n                let next = self.insts.len();\n                self.fill_split(prev_hole.0, None, Some(next));\n            } else {\n                self.fill_to_next(prev_hole.0);\n            }\n            let split = self.push_split_hole();\n            if let Some(Patch { hole, entry }) = self.c(e)? {\n                holes.push(hole);\n                prev_hole = (self.fill_split(split, Some(entry), None), false);\n            } else {\n                let (split1, split2) = split.dup_one();\n                holes.push(split1);\n                prev_hole = (split2, true);\n            }\n        }\n        if let Some(Patch { hole, entry }) = self.c(&exprs[exprs.len() - 1])? {\n            holes.push(hole);\n            if prev_hole.1 {\n                self.fill_split(prev_hole.0, None, Some(entry));\n            } else {\n                self.fill(prev_hole.0, entry);\n            }\n        } else {\n            // We ignore prev_hole.1. When it's true, it means we have two\n            // empty branches both pushing prev_hole.0 into holes, so both\n            // branches will go to the same place anyway.\n            holes.push(prev_hole.0);\n        }\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_byte":["fn c_byte(&mut self, b: u8) -> ResultOrEmpty{\n        self.c_class_bytes(&[hir::ClassBytesRange::new(b, b)])\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_capture":["fn c_capture(&mut self, first_slot: usize, expr: &Hir) -> ResultOrEmpty{\n        if self.num_exprs > 1 || self.compiled.is_dfa {\n            // Don't ever compile Save instructions for regex sets because\n            // they are never used. They are also never used in DFA programs\n            // because DFAs can't handle captures.\n            self.c(expr)\n        } else {\n            let entry = self.insts.len();\n            let hole = self.push_hole(InstHole::Save { slot: first_slot });\n            let patch = self.c(expr)?.unwrap_or_else(|| self.next_inst());\n            self.fill(hole, patch.entry);\n            self.fill_to_next(patch.hole);\n            let hole = self.push_hole(InstHole::Save { slot: first_slot + 1 });\n            Ok(Some(Patch { hole, entry }))\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_char":["fn c_char(&mut self, c: char) -> ResultOrEmpty{\n        if self.compiled.uses_bytes() {\n            if c.is_ascii() {\n                let b = c as u8;\n                let hole =\n                    self.push_hole(InstHole::Bytes { start: b, end: b });\n                self.byte_classes.set_range(b, b);\n                Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n            } else {\n                self.c_class(&[hir::ClassUnicodeRange::new(c, c)])\n            }\n        } else {\n            let hole = self.push_hole(InstHole::Char { c });\n            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_class":["fn c_class(&mut self, ranges: &[hir::ClassUnicodeRange]) -> ResultOrEmpty{\n        use std::mem::size_of;\n\n        if ranges.is_empty() {\n            return Err(Error::Syntax(\n                \"empty character classes are not allowed\".to_string(),\n            ));\n        }\n        if self.compiled.uses_bytes() {\n            Ok(Some(CompileClass { c: self, ranges }.compile()?))\n        } else {\n            let ranges: Vec<(char, char)> =\n                ranges.iter().map(|r| (r.start(), r.end())).collect();\n            let hole = if ranges.len() == 1 && ranges[0].0 == ranges[0].1 {\n                self.push_hole(InstHole::Char { c: ranges[0].0 })\n            } else {\n                self.extra_inst_bytes +=\n                    ranges.len() * (size_of::<char>() * 2);\n                self.push_hole(InstHole::Ranges { ranges })\n            };\n            Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_class_bytes":["fn c_class_bytes(\n        &mut self,\n        ranges: &[hir::ClassBytesRange],\n    ) -> ResultOrEmpty{\n        if ranges.is_empty() {\n            return Err(Error::Syntax(\n                \"empty character classes are not allowed\".to_string(),\n            ));\n        }\n\n        let first_split_entry = self.insts.len();\n        let mut holes = vec![];\n        let mut prev_hole = Hole::None;\n        for r in &ranges[0..ranges.len() - 1] {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let next = self.insts.len();\n            self.byte_classes.set_range(r.start(), r.end());\n            holes.push(self.push_hole(InstHole::Bytes {\n                start: r.start(),\n                end: r.end(),\n            }));\n            prev_hole = self.fill_split(split, Some(next), None);\n        }\n        let next = self.insts.len();\n        let r = &ranges[ranges.len() - 1];\n        self.byte_classes.set_range(r.start(), r.end());\n        holes.push(\n            self.push_hole(InstHole::Bytes { start: r.start(), end: r.end() }),\n        );\n        self.fill(prev_hole, next);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: first_split_entry }))\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_concat":["fn c_concat<'a, I>(&mut self, exprs: I) -> ResultOrEmpty\n    where\n        I: IntoIterator<Item = &'a Hir>,{\n        let mut exprs = exprs.into_iter();\n        let Patch { mut hole, entry } = loop {\n            match exprs.next() {\n                None => return self.c_empty(),\n                Some(e) => {\n                    if let Some(p) = self.c(e)? {\n                        break p;\n                    }\n                }\n            }\n        };\n        for e in exprs {\n            if let Some(p) = self.c(e)? {\n                self.fill(hole, p.entry);\n                hole = p.hole;\n            }\n        }\n        Ok(Some(Patch { hole, entry }))\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_dotstar":["fn c_dotstar(&mut self) -> Result{\n        let hir = if self.compiled.only_utf8() {\n            Hir::dot(hir::Dot::AnyChar)\n        } else {\n            Hir::dot(hir::Dot::AnyByte)\n        };\n        Ok(self\n            .c(&Hir::repetition(hir::Repetition {\n                min: 0,\n                max: None,\n                greedy: false,\n                sub: Box::new(hir),\n            }))?\n            .unwrap())\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_empty":["fn c_empty(&mut self) -> ResultOrEmpty{\n        // See: https://github.com/rust-lang/regex/security/advisories/GHSA-m5pq-gvj9-9vr8\n        // See: CVE-2022-24713\n        //\n        // Since 'empty' sub-expressions don't increase the size of\n        // the actual compiled object, we \"fake\" an increase in its\n        // size so that our 'check_size_limit' routine will eventually\n        // stop compilation if there are too many empty sub-expressions\n        // (e.g., via a large repetition).\n        self.extra_inst_bytes += std::mem::size_of::<Inst>();\n        Ok(None)\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_empty_look":["fn c_empty_look(&mut self, look: EmptyLook) -> ResultOrEmpty{\n        let hole = self.push_hole(InstHole::EmptyLook { look });\n        Ok(Some(Patch { hole, entry: self.insts.len() - 1 }))\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_literal":["fn c_literal(&mut self, bytes: &[u8]) -> ResultOrEmpty{\n        match core::str::from_utf8(bytes) {\n            Ok(string) => {\n                let mut it = string.chars();\n                let Patch { mut hole, entry } = loop {\n                    match it.next() {\n                        None => return self.c_empty(),\n                        Some(ch) => {\n                            if let Some(p) = self.c_char(ch)? {\n                                break p;\n                            }\n                        }\n                    }\n                };\n                for ch in it {\n                    if let Some(p) = self.c_char(ch)? {\n                        self.fill(hole, p.entry);\n                        hole = p.hole;\n                    }\n                }\n                Ok(Some(Patch { hole, entry }))\n            }\n            Err(_) => {\n                assert!(self.compiled.uses_bytes());\n                let mut it = bytes.iter().copied();\n                let Patch { mut hole, entry } = loop {\n                    match it.next() {\n                        None => return self.c_empty(),\n                        Some(byte) => {\n                            if let Some(p) = self.c_byte(byte)? {\n                                break p;\n                            }\n                        }\n                    }\n                };\n                for byte in it {\n                    if let Some(p) = self.c_byte(byte)? {\n                        self.fill(hole, p.entry);\n                        hole = p.hole;\n                    }\n                }\n                Ok(Some(Patch { hole, entry }))\n            }\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_repeat":["fn c_repeat(&mut self, rep: &hir::Repetition) -> ResultOrEmpty{\n        match (rep.min, rep.max) {\n            (0, Some(1)) => self.c_repeat_zero_or_one(&rep.sub, rep.greedy),\n            (0, None) => self.c_repeat_zero_or_more(&rep.sub, rep.greedy),\n            (1, None) => self.c_repeat_one_or_more(&rep.sub, rep.greedy),\n            (min, None) => {\n                self.c_repeat_range_min_or_more(&rep.sub, rep.greedy, min)\n            }\n            (min, Some(max)) => {\n                self.c_repeat_range(&rep.sub, rep.greedy, min, max)\n            }\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_repeat_one_or_more":["fn c_repeat_one_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty{\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return Ok(None),\n        };\n        self.fill_to_next(hole_rep);\n        let split = self.push_split_hole();\n\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: entry_rep }))\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_repeat_range":["fn c_repeat_range(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n        max: u32,\n    ) -> ResultOrEmpty{\n        let (min, max) = (u32_to_usize(min), u32_to_usize(max));\n        debug_assert!(min <= max);\n        let patch_concat = self.c_concat(iter::repeat(expr).take(min))?;\n        if min == max {\n            return Ok(patch_concat);\n        }\n        // Same reasoning as in c_repeat_range_min_or_more (we know that min <\n        // max at this point).\n        let patch_concat = patch_concat.unwrap_or_else(|| self.next_inst());\n        let initial_entry = patch_concat.entry;\n        // It is much simpler to compile, e.g., `a{2,5}` as:\n        //\n        //     aaa?a?a?\n        //\n        // But you end up with a sequence of instructions like this:\n        //\n        //     0: 'a'\n        //     1: 'a',\n        //     2: split(3, 4)\n        //     3: 'a'\n        //     4: split(5, 6)\n        //     5: 'a'\n        //     6: split(7, 8)\n        //     7: 'a'\n        //     8: MATCH\n        //\n        // This is *incredibly* inefficient because the splits end\n        // up forming a chain, which has to be resolved everything a\n        // transition is followed.\n        let mut holes = vec![];\n        let mut prev_hole = patch_concat.hole;\n        for _ in min..max {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } = match self.c(expr)? {\n                Some(p) => p,\n                None => return self.pop_split_hole(),\n            };\n            prev_hole = hole;\n            if greedy {\n                holes.push(self.fill_split(split, Some(entry), None));\n            } else {\n                holes.push(self.fill_split(split, None, Some(entry)));\n            }\n        }\n        holes.push(prev_hole);\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: initial_entry }))\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_repeat_range_min_or_more":["fn c_repeat_range_min_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n        min: u32,\n    ) -> ResultOrEmpty{\n        let min = u32_to_usize(min);\n        // Using next_inst() is ok, because we can't return it (concat would\n        // have to return Some(_) while c_repeat_range_min_or_more returns\n        // None).\n        let patch_concat = self\n            .c_concat(iter::repeat(expr).take(min))?\n            .unwrap_or_else(|| self.next_inst());\n        if let Some(patch_rep) = self.c_repeat_zero_or_more(expr, greedy)? {\n            self.fill(patch_concat.hole, patch_rep.entry);\n            Ok(Some(Patch { hole: patch_rep.hole, entry: patch_concat.entry }))\n        } else {\n            Ok(None)\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_repeat_zero_or_more":["fn c_repeat_zero_or_more(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty{\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n\n        self.fill(hole_rep, split_entry);\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        Ok(Some(Patch { hole: split_hole, entry: split_entry }))\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::c_repeat_zero_or_one":["fn c_repeat_zero_or_one(\n        &mut self,\n        expr: &Hir,\n        greedy: bool,\n    ) -> ResultOrEmpty{\n        let split_entry = self.insts.len();\n        let split = self.push_split_hole();\n        let Patch { hole: hole_rep, entry: entry_rep } = match self.c(expr)? {\n            Some(p) => p,\n            None => return self.pop_split_hole(),\n        };\n        let split_hole = if greedy {\n            self.fill_split(split, Some(entry_rep), None)\n        } else {\n            self.fill_split(split, None, Some(entry_rep))\n        };\n        let holes = vec![hole_rep, split_hole];\n        Ok(Some(Patch { hole: Hole::Many(holes), entry: split_entry }))\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::check_size":["fn check_size(&self) -> result::Result<(), Error>{\n        use std::mem::size_of;\n\n        let size =\n            self.extra_inst_bytes + (self.insts.len() * size_of::<Inst>());\n        if size > self.size_limit {\n            Err(Error::CompiledTooBig(self.size_limit))\n        } else {\n            Ok(())\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::compile":["/// Compile a regular expression given its AST.\n///\n/// The compiler is guaranteed to succeed unless the program exceeds the\n/// specified size limit. If the size limit is exceeded, then compilation\n/// stops and returns an error.\npub fn compile(mut self, exprs: &[Hir]) -> result::Result<Program, Error>{\n        debug_assert!(!exprs.is_empty());\n        self.num_exprs = exprs.len();\n        if exprs.len() == 1 {\n            self.compile_one(&exprs[0])\n        } else {\n            self.compile_many(exprs)\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::compile_finish":["fn compile_finish(mut self) -> result::Result<Program, Error>{\n        self.compiled.insts =\n            self.insts.into_iter().map(|inst| inst.unwrap()).collect();\n        self.compiled.byte_classes = self.byte_classes.byte_classes();\n        self.compiled.capture_name_idx = Arc::new(self.capture_name_idx);\n        Ok(self.compiled)\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::compile_many":["fn compile_many(\n        mut self,\n        exprs: &[Hir],\n    ) -> result::Result<Program, Error>{\n        debug_assert!(exprs.len() > 1);\n\n        self.compiled.is_anchored_start = exprs\n            .iter()\n            .all(|e| e.properties().look_set_prefix().contains(Look::Start));\n        self.compiled.is_anchored_end = exprs\n            .iter()\n            .all(|e| e.properties().look_set_suffix().contains(Look::End));\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        } else {\n            self.compiled.start = 0; // first instruction is always split\n        }\n        self.fill_to_next(dotstar_patch.hole);\n\n        let mut prev_hole = Hole::None;\n        for (i, expr) in exprs[0..exprs.len() - 1].iter().enumerate() {\n            self.fill_to_next(prev_hole);\n            let split = self.push_split_hole();\n            let Patch { hole, entry } =\n                self.c_capture(0, expr)?.unwrap_or_else(|| self.next_inst());\n            self.fill_to_next(hole);\n            self.compiled.matches.push(self.insts.len());\n            self.push_compiled(Inst::Match(i));\n            prev_hole = self.fill_split(split, Some(entry), None);\n        }\n        let i = exprs.len() - 1;\n        let Patch { hole, entry } =\n            self.c_capture(0, &exprs[i])?.unwrap_or_else(|| self.next_inst());\n        self.fill(prev_hole, entry);\n        self.fill_to_next(hole);\n        self.compiled.matches.push(self.insts.len());\n        self.push_compiled(Inst::Match(i));\n        self.compile_finish()\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::compile_one":["fn compile_one(mut self, expr: &Hir) -> result::Result<Program, Error>{\n        if self.compiled.only_utf8\n            && expr.properties().look_set().contains(Look::WordAsciiNegate)\n        {\n            return Err(Error::Syntax(\n                \"ASCII-only \\\\B is not allowed in Unicode regexes \\\n                 because it may result in invalid UTF-8 matches\"\n                    .to_string(),\n            ));\n        }\n        // If we're compiling a forward DFA and we aren't anchored, then\n        // add a `.*?` before the first capture group.\n        // Other matching engines handle this by baking the logic into the\n        // matching engine itself.\n        let mut dotstar_patch = Patch { hole: Hole::None, entry: 0 };\n        self.compiled.is_anchored_start =\n            expr.properties().look_set_prefix().contains(Look::Start);\n        self.compiled.is_anchored_end =\n            expr.properties().look_set_suffix().contains(Look::End);\n        if self.compiled.needs_dotstar() {\n            dotstar_patch = self.c_dotstar()?;\n            self.compiled.start = dotstar_patch.entry;\n        }\n        self.compiled.captures = vec![None];\n        let patch =\n            self.c_capture(0, expr)?.unwrap_or_else(|| self.next_inst());\n        if self.compiled.needs_dotstar() {\n            self.fill(dotstar_patch.hole, patch.entry);\n        } else {\n            self.compiled.start = patch.entry;\n        }\n        self.fill_to_next(patch.hole);\n        self.compiled.matches = vec![self.insts.len()];\n        self.push_compiled(Inst::Match(0));\n        self.compiled.static_captures_len =\n            expr.properties().static_explicit_captures_len();\n        self.compile_finish()\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::dfa":["/// When set, the machine returned is suitable for use in the DFA matching\n/// engine.\n///\n/// In particular, this ensures that if the regex is not anchored in the\n/// beginning, then a preceding `.*?` is included in the program. (The NFA\n/// based engines handle the preceding `.*?` explicitly, which is difficult\n/// or impossible in the DFA engine.)\npub fn dfa(mut self, yes: bool) -> Self{\n        self.compiled.is_dfa = yes;\n        self\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::fill":["fn fill(&mut self, hole: Hole, goto: InstPtr){\n        match hole {\n            Hole::None => {}\n            Hole::One(pc) => {\n                self.insts[pc].fill(goto);\n            }\n            Hole::Many(holes) => {\n                for hole in holes {\n                    self.fill(hole, goto);\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::fill_split":["fn fill_split(\n        &mut self,\n        hole: Hole,\n        goto1: Option<InstPtr>,\n        goto2: Option<InstPtr>,\n    ) -> Hole{\n        match hole {\n            Hole::None => Hole::None,\n            Hole::One(pc) => match (goto1, goto2) {\n                (Some(goto1), Some(goto2)) => {\n                    self.insts[pc].fill_split(goto1, goto2);\n                    Hole::None\n                }\n                (Some(goto1), None) => {\n                    self.insts[pc].half_fill_split_goto1(goto1);\n                    Hole::One(pc)\n                }\n                (None, Some(goto2)) => {\n                    self.insts[pc].half_fill_split_goto2(goto2);\n                    Hole::One(pc)\n                }\n                (None, None) => unreachable!(\n                    \"at least one of the split \\\n                     holes must be filled\"\n                ),\n            },\n            Hole::Many(holes) => {\n                let mut new_holes = vec![];\n                for hole in holes {\n                    new_holes.push(self.fill_split(hole, goto1, goto2));\n                }\n                if new_holes.is_empty() {\n                    Hole::None\n                } else if new_holes.len() == 1 {\n                    new_holes.pop().unwrap()\n                } else {\n                    Hole::Many(new_holes)\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::fill_to_next":["fn fill_to_next(&mut self, hole: Hole){\n        let next = self.insts.len();\n        self.fill(hole, next);\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::new":["/// Create a new regular expression compiler.\n///\n/// Various options can be set before calling `compile` on an expression.\npub fn new() -> Self{\n        Compiler {\n            insts: vec![],\n            compiled: Program::new(),\n            capture_name_idx: HashMap::new(),\n            num_exprs: 0,\n            size_limit: 10 * (1 << 20),\n            suffix_cache: SuffixCache::new(1000),\n            utf8_seqs: Some(Utf8Sequences::new('\\x00', '\\x00')),\n            byte_classes: ByteClassSet::new(),\n            extra_inst_bytes: 0,\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::next_inst":["/// Can be used as a default value for the c_* functions when the call to\n/// c_function is followed by inserting at least one instruction that is\n/// always executed after the ones written by the c* function.\nfn next_inst(&self) -> Patch{\n        Patch { hole: Hole::None, entry: self.insts.len() }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::only_utf8":["/// When disabled, the program compiled may match arbitrary bytes.\n///\n/// When enabled (the default), all compiled programs exclusively match\n/// valid UTF-8 bytes.\npub fn only_utf8(mut self, yes: bool) -> Self{\n        self.compiled.only_utf8 = yes;\n        self\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::pop_split_hole":["fn pop_split_hole(&mut self) -> ResultOrEmpty{\n        self.insts.pop();\n        Ok(None)\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::push_compiled":["fn push_compiled(&mut self, inst: Inst){\n        self.insts.push(MaybeInst::Compiled(inst));\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::push_hole":["fn push_hole(&mut self, inst: InstHole) -> Hole{\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Uncompiled(inst));\n        Hole::One(hole)\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::push_split_hole":["fn push_split_hole(&mut self) -> Hole{\n        let hole = self.insts.len();\n        self.insts.push(MaybeInst::Split);\n        Hole::One(hole)\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::reverse":["/// When set, the machine returned is suitable for matching text in\n/// reverse. In particular, all concatenations are flipped.\npub fn reverse(mut self, yes: bool) -> Self{\n        self.compiled.is_reverse = yes;\n        self\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Compiler::size_limit":["/// The size of the resulting program is limited by size_limit. If\n/// the program approximately exceeds the given size (in bytes), then\n/// compilation will stop and return an error.\npub fn size_limit(mut self, size_limit: usize) -> Self{\n        self.size_limit = size_limit;\n        self\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Hole":["enum Hole {\n    None,\n    One(InstPtr),\n    Many(Vec<Hole>),\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::Hole::dup_one":["fn dup_one(self) -> (Self, Self){\n        match self {\n            Hole::One(pc) => (Hole::One(pc), Hole::One(pc)),\n            Hole::None | Hole::Many(_) => {\n                unreachable!(\"must be called on single hole\")\n            }\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::InstHole":["enum InstHole {\n    Save { slot: usize },\n    EmptyLook { look: EmptyLook },\n    Char { c: char },\n    Ranges { ranges: Vec<(char, char)> },\n    Bytes { start: u8, end: u8 },\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::InstHole::fill":["fn fill(&self, goto: InstPtr) -> Inst{\n        match *self {\n            InstHole::Save { slot } => Inst::Save(InstSave { goto, slot }),\n            InstHole::EmptyLook { look } => {\n                Inst::EmptyLook(InstEmptyLook { goto, look })\n            }\n            InstHole::Char { c } => Inst::Char(InstChar { goto, c }),\n            InstHole::Ranges { ref ranges } => Inst::Ranges(InstRanges {\n                goto,\n                ranges: ranges.clone().into_boxed_slice(),\n            }),\n            InstHole::Bytes { start, end } => {\n                Inst::Bytes(InstBytes { goto, start, end })\n            }\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::MaybeInst":["enum MaybeInst {\n    Compiled(Inst),\n    Uncompiled(InstHole),\n    Split,\n    Split1(InstPtr),\n    Split2(InstPtr),\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::MaybeInst::fill":["fn fill(&mut self, goto: InstPtr){\n        let maybeinst = match *self {\n            MaybeInst::Split => MaybeInst::Split1(goto),\n            MaybeInst::Uncompiled(ref inst) => {\n                MaybeInst::Compiled(inst.fill(goto))\n            }\n            MaybeInst::Split1(goto1) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1,\n                    goto2: goto,\n                }))\n            }\n            MaybeInst::Split2(goto2) => {\n                MaybeInst::Compiled(Inst::Split(InstSplit {\n                    goto1: goto,\n                    goto2,\n                }))\n            }\n            _ => unreachable!(\n                \"not all instructions were compiled! \\\n                 found uncompiled instruction: {:?}\",\n                self\n            ),\n        };\n        *self = maybeinst;\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::MaybeInst::fill_split":["fn fill_split(&mut self, goto1: InstPtr, goto2: InstPtr){\n        let filled = match *self {\n            MaybeInst::Split => Inst::Split(InstSplit { goto1, goto2 }),\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Compiled(filled);\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::MaybeInst::half_fill_split_goto1":["fn half_fill_split_goto1(&mut self, goto1: InstPtr){\n        let half_filled = match *self {\n            MaybeInst::Split => goto1,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split1(half_filled);\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::MaybeInst::half_fill_split_goto2":["fn half_fill_split_goto2(&mut self, goto2: InstPtr){\n        let half_filled = match *self {\n            MaybeInst::Split => goto2,\n            _ => unreachable!(\n                \"must be called on Split instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        };\n        *self = MaybeInst::Split2(half_filled);\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::MaybeInst::unwrap":["fn unwrap(self) -> Inst{\n        match self {\n            MaybeInst::Compiled(inst) => inst,\n            _ => unreachable!(\n                \"must be called on a compiled instruction, \\\n                 instead it was called on: {:?}\",\n                self\n            ),\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::Patch":["struct Patch {\n    hole: Hole,\n    entry: InstPtr,\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::SuffixCache":["/// `SuffixCache` is a simple bounded hash map for caching suffix entries in\n/// UTF-8 automata. For example, consider the Unicode range \\u{0}-\\u{FFFF}.\n/// The set of byte ranges looks like this:\n///\n/// [0-7F]\n/// [C2-DF][80-BF]\n/// [E0][A0-BF][80-BF]\n/// [E1-EC][80-BF][80-BF]\n/// [ED][80-9F][80-BF]\n/// [EE-EF][80-BF][80-BF]\n///\n/// Each line above translates to one alternate in the compiled regex program.\n/// However, all but one of the alternates end in the same suffix, which is\n/// a waste of an instruction. The suffix cache facilitates reusing them across\n/// alternates.\n///\n/// Note that a HashMap could be trivially used for this, but we don't need its\n/// overhead. Some small bounded space (LRU style) is more than enough.\n///\n/// This uses similar idea to [`SparseSet`](../sparse/struct.SparseSet.html),\n/// except it uses hashes as original indices and then compares full keys for\n/// validation against `dense` array.\nstruct SuffixCache {\n    sparse: Box<[usize]>,\n    dense: Vec<SuffixCacheEntry>,\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::SuffixCache::clear":["fn clear(&mut self){\n        self.dense.clear();\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::SuffixCache::get":["fn get(&mut self, key: SuffixCacheKey, pc: InstPtr) -> Option<InstPtr>{\n        let hash = self.hash(&key);\n        let pos = &mut self.sparse[hash];\n        if let Some(entry) = self.dense.get(*pos) {\n            if entry.key == key {\n                return Some(entry.pc);\n            }\n        }\n        *pos = self.dense.len();\n        self.dense.push(SuffixCacheEntry { key, pc });\n        None\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::SuffixCache::hash":["fn hash(&self, suffix: &SuffixCacheKey) -> usize{\n        // Basic FNV-1a hash as described:\n        // https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n        const FNV_PRIME: u64 = 1_099_511_628_211;\n        let mut h = 14_695_981_039_346_656_037;\n        h = (h ^ (suffix.from_inst as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.start as u64)).wrapping_mul(FNV_PRIME);\n        h = (h ^ (suffix.end as u64)).wrapping_mul(FNV_PRIME);\n        (h as usize) % self.sparse.len()\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::SuffixCache::new":["fn new(size: usize) -> Self{\n        SuffixCache {\n            sparse: vec![0usize; size].into(),\n            dense: Vec::with_capacity(size),\n        }\n    }","Real(LocalPath(\"src/compile.rs\"))"],"compile::SuffixCacheEntry":["struct SuffixCacheEntry {\n    key: SuffixCacheKey,\n    pc: InstPtr,\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::SuffixCacheKey":["struct SuffixCacheKey {\n    from_inst: InstPtr,\n    start: u8,\n    end: u8,\n}","Real(LocalPath(\"src/compile.rs\"))"],"compile::u32_to_usize":["fn u32_to_usize(n: u32) -> usize{\n    // In case usize is less than 32 bits, we need to guard against overflow.\n    // On most platforms this compiles to nothing.\n    // TODO Use `std::convert::TryFrom` once it's stable.\n    if (n as u64) > (::std::usize::MAX as u64) {\n        panic!(\"BUG: {} is too big to be pointer sized\", n)\n    }\n    n as usize\n}","Real(LocalPath(\"src/compile.rs\"))"],"dfa::Byte":["/// Byte is a u8 in spirit, but a u16 in practice so that we can represent the\n/// special EOF sentinel value.\nstruct Byte(u16);","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Byte::as_byte":["fn as_byte(&self) -> Option<u8>{\n        if self.is_eof() {\n            None\n        } else {\n            Some(self.0 as u8)\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Byte::byte":["fn byte(b: u8) -> Self{\n        Byte(b as u16)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Byte::eof":["fn eof() -> Self{\n        Byte(256)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Byte::is_ascii_word":["fn is_ascii_word(&self) -> bool{\n        let b = match self.as_byte() {\n            None => return false,\n            Some(b) => b,\n        };\n        match b {\n            b'A'..=b'Z' | b'a'..=b'z' | b'0'..=b'9' | b'_' => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Byte::is_eof":["fn is_eof(&self) -> bool{\n        self.0 == 256\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Cache":["/// A reusable cache of DFA states.\n///\n/// This cache is reused between multiple invocations of the same regex\n/// program. (It is not shared simultaneously between threads. If there is\n/// contention, then new caches are created.)\npub struct Cache {\n    /// Group persistent DFA related cache state together. The sparse sets\n    /// listed below are used as scratch space while computing uncached states.\n    inner: CacheInner,\n    /// qcur and qnext are ordered sets with constant time\n    /// addition/membership/clearing-whole-set and linear time iteration. They\n    /// are used to manage the sets of NFA states in DFA states when computing\n    /// cached DFA states. In particular, the order of the NFA states matters\n    /// for leftmost-first style matching. Namely, when computing a cached\n    /// state, the set of NFA states stops growing as soon as the first Match\n    /// instruction is observed.\n    qcur: SparseSet,\n    qnext: SparseSet,\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Cache::new":["/// Create new empty cache for the DFA engine.\npub fn new(prog: &Program) -> Self{\n        // We add 1 to account for the special EOF byte.\n        let num_byte_classes = (prog.byte_classes[255] as usize + 1) + 1;\n        let starts = vec![STATE_UNKNOWN; 256];\n        let mut cache = Cache {\n            inner: CacheInner {\n                compiled: StateMap::new(num_byte_classes),\n                trans: Transitions::new(num_byte_classes),\n                start_states: starts,\n                stack: vec![],\n                flush_count: 0,\n                size: 0,\n                insts_scratch_space: vec![],\n            },\n            qcur: SparseSet::new(prog.insts.len()),\n            qnext: SparseSet::new(prog.insts.len()),\n        };\n        cache.inner.reset_size();\n        cache\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::CacheInner":["/// `CacheInner` is logically just a part of Cache, but groups together fields\n/// that aren't passed as function parameters throughout search. (This split\n/// is mostly an artifact of the borrow checker. It is happily paid.)\nstruct CacheInner {\n    /// A cache of pre-compiled DFA states, keyed by the set of NFA states\n    /// and the set of empty-width flags set at the byte in the input when the\n    /// state was observed.\n    ///\n    /// A StatePtr is effectively a `*State`, but to avoid various inconvenient\n    /// things, we just pass indexes around manually. The performance impact of\n    /// this is probably an instruction or two in the inner loop. However, on\n    /// 64 bit, each StatePtr is half the size of a *State.\n    compiled: StateMap,\n    /// The transition table.\n    ///\n    /// The transition table is laid out in row-major order, where states are\n    /// rows and the transitions for each state are columns. At a high level,\n    /// given state `s` and byte `b`, the next state can be found at index\n    /// `s * 256 + b`.\n    ///\n    /// This is, of course, a lie. A StatePtr is actually a pointer to the\n    /// *start* of a row in this table. When indexing in the DFA's inner loop,\n    /// this removes the need to multiply the StatePtr by the stride. Yes, it\n    /// matters. This reduces the number of states we can store, but: the\n    /// stride is rarely 256 since we define transitions in terms of\n    /// *equivalence classes* of bytes. Each class corresponds to a set of\n    /// bytes that never discriminate a distinct path through the DFA from each\n    /// other.\n    trans: Transitions,\n    /// A set of cached start states, which are limited to the number of\n    /// permutations of flags set just before the initial byte of input. (The\n    /// index into this vec is a `EmptyFlags`.)\n    ///\n    /// N.B. A start state can be \"dead\" (i.e., no possible match), so we\n    /// represent it with a StatePtr.\n    start_states: Vec<StatePtr>,\n    /// Stack scratch space used to follow epsilon transitions in the NFA.\n    /// (This permits us to avoid recursion.)\n    ///\n    /// The maximum stack size is the number of NFA states.\n    stack: Vec<InstPtr>,\n    /// The total number of times this cache has been flushed by the DFA\n    /// because of space constraints.\n    flush_count: u64,\n    /// The total heap size of the DFA's cache. We use this to determine when\n    /// we should flush the cache.\n    size: usize,\n    /// Scratch space used when building instruction pointer lists for new\n    /// states. This helps amortize allocation.\n    insts_scratch_space: Vec<u8>,\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::CacheInner::reset_size":["/// Resets the cache size to account for fixed costs, such as the program\n/// and stack sizes.\nfn reset_size(&mut self){\n        self.size = (self.start_states.len() * mem::size_of::<StatePtr>())\n            + (self.stack.len() * mem::size_of::<InstPtr>());\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::EmptyFlags":["/// A set of flags for zero-width assertions.\nstruct EmptyFlags {\n    start: bool,\n    end: bool,\n    start_line: bool,\n    end_line: bool,\n    word_boundary: bool,\n    not_word_boundary: bool,\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm":["/// Fsm encapsulates the actual execution of the DFA.\npub struct Fsm<'a> {\n    /// prog contains the NFA instruction opcodes. DFA execution uses either\n    /// the `dfa` instructions or the `dfa_reverse` instructions from\n    /// `exec::ExecReadOnly`. (It never uses `ExecReadOnly.nfa`, which may have\n    /// Unicode opcodes that cannot be executed by the DFA.)\n    prog: &'a Program,\n    /// The start state. We record it here because the pointer may change\n    /// when the cache is wiped.\n    start: StatePtr,\n    /// The current position in the input.\n    at: usize,\n    /// Should we quit after seeing the first match? e.g., When the caller\n    /// uses `is_match` or `shortest_match`.\n    quit_after_match: bool,\n    /// The last state that matched.\n    ///\n    /// When no match has occurred, this is set to STATE_UNKNOWN.\n    ///\n    /// This is only useful when matching regex sets. The last match state\n    /// is useful because it contains all of the match instructions seen,\n    /// thereby allowing us to enumerate which regexes in the set matched.\n    last_match_si: StatePtr,\n    /// The input position of the last cache flush. We use this to determine\n    /// if we're thrashing in the cache too often. If so, the DFA quits so\n    /// that we can fall back to the NFA algorithm.\n    last_cache_flush: usize,\n    /// All cached DFA information that is persisted between searches.\n    cache: &'a mut CacheInner,\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::add_state":["/// Adds the given state to the DFA.\n///\n/// This allocates room for transitions out of this state in\n/// self.cache.trans. The transitions can be set with the returned\n/// StatePtr.\n///\n/// If None is returned, then the state limit was reached and the DFA\n/// should quit.\nfn add_state(&mut self, state: State) -> Option<StatePtr>{\n        // This will fail if the next state pointer exceeds STATE_PTR. In\n        // practice, the cache limit will prevent us from ever getting here,\n        // but maybe callers will set the cache size to something ridiculous...\n        let si = match self.cache.trans.add() {\n            None => return None,\n            Some(si) => si,\n        };\n        // If the program has a Unicode word boundary, then set any transitions\n        // for non-ASCII bytes to STATE_QUIT. If the DFA stumbles over such a\n        // transition, then it will quit and an alternative matching engine\n        // will take over.\n        if self.prog.has_unicode_word_boundary {\n            for b in 128..256 {\n                let cls = self.byte_class(Byte::byte(b as u8));\n                self.cache.trans.set_next(si, cls, STATE_QUIT);\n            }\n        }\n        // Finally, put our actual state on to our heap of states and index it\n        // so we can find it later.\n        self.cache.size += self.cache.trans.state_heap_size()\n            + state.data.len()\n            + (2 * mem::size_of::<State>())\n            + mem::size_of::<StatePtr>();\n        self.cache.compiled.insert(state, si);\n        // Transition table and set of states and map should all be in sync.\n        debug_assert!(\n            self.cache.compiled.len() == self.cache.trans.num_states()\n        );\n        Some(si)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::approximate_size":["/// Approximate size returns the approximate heap space currently used by\n/// the DFA. It is used to determine whether the DFA's state cache needs to\n/// be wiped. Namely, it is possible that for certain regexes on certain\n/// inputs, a new state could be created for every byte of input. (This is\n/// bad for memory use, so we bound it with a cache.)\nfn approximate_size(&self) -> usize{\n        self.cache.size\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::byte_class":["/// Given an input byte or the special EOF sentinel, return its\n/// corresponding byte class.\ninline(always)\nfn byte_class(&self, b: Byte) -> usize{\n        match b.as_byte() {\n            None => self.num_byte_classes() - 1,\n            Some(b) => self.u8_class(b),\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::cached_state":["/// Find a previously computed state matching the given set of instructions\n/// and is_match bool.\n///\n/// The given set of instructions should represent a single state in the\n/// NFA along with all states reachable without consuming any input.\n///\n/// The is_match bool should be true if and only if the preceding DFA state\n/// contains an NFA matching state. The cached state produced here will\n/// then signify a match. (This enables us to delay a match by one byte,\n/// in order to account for the EOF sentinel byte.)\n///\n/// If the cache is full, then it is wiped before caching a new state.\n///\n/// The current state should be specified if it exists, since it will need\n/// to be preserved if the cache clears itself. (Start states are\n/// always saved, so they should not be passed here.) It takes a mutable\n/// pointer to the index because if the cache is cleared, the state's\n/// location may change.\nfn cached_state(\n        &mut self,\n        q: &SparseSet,\n        mut state_flags: StateFlags,\n        current_state: Option<&mut StatePtr>,\n    ) -> Option<StatePtr>{\n        // If we couldn't come up with a non-empty key to represent this state,\n        // then it is dead and can never lead to a match.\n        //\n        // Note that inst_flags represent the set of empty width assertions\n        // in q. We use this as an optimization in exec_byte to determine when\n        // we should follow epsilon transitions at the empty string preceding\n        // the current byte.\n        let key = match self.cached_state_key(q, &mut state_flags) {\n            None => return Some(STATE_DEAD),\n            Some(v) => v,\n        };\n        // In the cache? Cool. Done.\n        if let Some(si) = self.cache.compiled.get_ptr(&key) {\n            return Some(si);\n        }\n        // If the cache has gotten too big, wipe it.\n        if self.approximate_size() > self.prog.dfa_size_limit\n            && !self.clear_cache_and_save(current_state)\n        {\n            // Ooops. DFA is giving up.\n            return None;\n        }\n        // Allocate room for our state and add it.\n        self.add_state(key)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::cached_state_key":["/// Produces a key suitable for describing a state in the DFA cache.\n///\n/// The key invariant here is that equivalent keys are produced for any two\n/// sets of ordered NFA states (and toggling of whether the previous NFA\n/// states contain a match state) that do not discriminate a match for any\n/// input.\n///\n/// Specifically, q should be an ordered set of NFA states and is_match\n/// should be true if and only if the previous NFA states contained a match\n/// state.\nfn cached_state_key(\n        &mut self,\n        q: &SparseSet,\n        state_flags: &mut StateFlags,\n    ) -> Option<State>{\n        use crate::prog::Inst::*;\n\n        // We need to build up enough information to recognize pre-built states\n        // in the DFA. Generally speaking, this includes every instruction\n        // except for those which are purely epsilon transitions, e.g., the\n        // Save and Split instructions.\n        //\n        // Empty width assertions are also epsilon transitions, but since they\n        // are conditional, we need to make them part of a state's key in the\n        // cache.\n\n        let mut insts =\n            mem::replace(&mut self.cache.insts_scratch_space, vec![]);\n        insts.clear();\n        // Reserve 1 byte for flags.\n        insts.push(0);\n\n        let mut prev = 0;\n        for &ip in q {\n            let ip = usize_to_u32(ip);\n            match self.prog[ip as usize] {\n                Char(_) | Ranges(_) => unreachable!(),\n                Save(_) | Split(_) => {}\n                Bytes(_) => push_inst_ptr(&mut insts, &mut prev, ip),\n                EmptyLook(_) => {\n                    state_flags.set_empty();\n                    push_inst_ptr(&mut insts, &mut prev, ip)\n                }\n                Match(_) => {\n                    push_inst_ptr(&mut insts, &mut prev, ip);\n                    if !self.continue_past_first_match() {\n                        break;\n                    }\n                }\n            }\n        }\n        // If we couldn't transition to any other instructions and we didn't\n        // see a match when expanding NFA states previously, then this is a\n        // dead state and no amount of additional input can transition out\n        // of this state.\n        let opt_state = if insts.len() == 1 && !state_flags.is_match() {\n            None\n        } else {\n            let StateFlags(f) = *state_flags;\n            insts[0] = f;\n            Some(State { data: Arc::from(&*insts) })\n        };\n        self.cache.insts_scratch_space = insts;\n        opt_state\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::clear_cache":["/// Wipes the state cache, but saves and restores the current start state.\n///\n/// This returns false if the cache is not cleared and the DFA should\n/// give up.\nfn clear_cache(&mut self) -> bool{\n        // Bail out of the DFA if we're moving too \"slowly.\"\n        // A heuristic from RE2: assume the DFA is too slow if it is processing\n        // 10 or fewer bytes per state.\n        // Additionally, we permit the cache to be flushed a few times before\n        // caling it quits.\n        let nstates = self.cache.compiled.len();\n        if self.cache.flush_count >= 3\n            && self.at >= self.last_cache_flush\n            && (self.at - self.last_cache_flush) <= 10 * nstates\n        {\n            return false;\n        }\n        // Update statistics tracking cache flushes.\n        self.last_cache_flush = self.at;\n        self.cache.flush_count += 1;\n\n        // OK, actually flush the cache.\n        let start = self.state(self.start & !STATE_START).clone();\n        let last_match = if self.last_match_si <= STATE_MAX {\n            Some(self.state(self.last_match_si).clone())\n        } else {\n            None\n        };\n        self.cache.reset_size();\n        self.cache.trans.clear();\n        self.cache.compiled.clear();\n        for s in &mut self.cache.start_states {\n            *s = STATE_UNKNOWN;\n        }\n        // The unwraps are OK because we just cleared the cache and therefore\n        // know that the next state pointer won't exceed STATE_MAX.\n        let start_ptr = self.restore_state(start).unwrap();\n        self.start = self.start_ptr(start_ptr);\n        if let Some(last_match) = last_match {\n            self.last_match_si = self.restore_state(last_match).unwrap();\n        }\n        true\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::clear_cache_and_save":["/// Clears the cache, but saves and restores current_state if it is not\n/// none.\n///\n/// The current state must be provided here in case its location in the\n/// cache changes.\n///\n/// This returns false if the cache is not cleared and the DFA should\n/// give up.\nfn clear_cache_and_save(\n        &mut self,\n        current_state: Option<&mut StatePtr>,\n    ) -> bool{\n        if self.cache.compiled.is_empty() {\n            // Nothing to clear...\n            return true;\n        }\n        match current_state {\n            None => self.clear_cache(),\n            Some(si) => {\n                let cur = self.state(*si).clone();\n                if !self.clear_cache() {\n                    return false;\n                }\n                // The unwrap is OK because we just cleared the cache and\n                // therefore know that the next state pointer won't exceed\n                // STATE_MAX.\n                *si = self.restore_state(cur).unwrap();\n                true\n            }\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::continue_past_first_match":["/// Returns true if the DFA should continue searching past the first match.\n///\n/// Leftmost first semantics in the DFA are preserved by not following NFA\n/// transitions after the first match is seen.\n///\n/// On occasion, we want to avoid leftmost first semantics to find either\n/// the longest match (for reverse search) or all possible matches (for\n/// regex sets).\nfn continue_past_first_match(&self) -> bool{\n        self.prog.is_reverse || self.prog.matches.len() > 1\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::exec_at":["/// Executes the DFA on a forward NFA.\n///\n/// {qcur,qnext} are scratch ordered sets which may be non-empty.\ninline(always)\nfn exec_at(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        text: &[u8],\n    ) -> Result<usize>{\n        // For the most part, the DFA is basically:\n        //\n        //   last_match = null\n        //   while current_byte != EOF:\n        //     si = current_state.next[current_byte]\n        //     if si is match\n        //       last_match = si\n        //   return last_match\n        //\n        // However, we need to deal with a few things:\n        //\n        //   1. This is an *online* DFA, so the current state's next list\n        //      may not point to anywhere yet, so we must go out and compute\n        //      them. (They are then cached into the current state's next list\n        //      to avoid re-computation.)\n        //   2. If we come across a state that is known to be dead (i.e., never\n        //      leads to a match), then we can quit early.\n        //   3. If the caller just wants to know if a match occurs, then we\n        //      can quit as soon as we know we have a match. (Full leftmost\n        //      first semantics require continuing on.)\n        //   4. If we're in the start state, then we can use a pre-computed set\n        //      of prefix literals to skip quickly along the input.\n        //   5. After the input is exhausted, we run the DFA on one symbol\n        //      that stands for EOF. This is useful for handling empty width\n        //      assertions.\n        //   6. We can't actually do state.next[byte]. Instead, we have to do\n        //      state.next[byte_classes[byte]], which permits us to keep the\n        //      'next' list very small.\n        //\n        // Since there's a bunch of extra stuff we need to consider, we do some\n        // pretty hairy tricks to get the inner loop to run as fast as\n        // possible.\n        debug_assert!(!self.prog.is_reverse);\n\n        // The last match is the currently known ending match position. It is\n        // reported as an index to the most recent byte that resulted in a\n        // transition to a match state and is always stored in capture slot `1`\n        // when searching forwards. Its maximum value is `text.len()`.\n        let mut result = Result::NoMatch(self.at);\n        let (mut prev_si, mut next_si) = (self.start, self.start);\n        let mut at = self.at;\n        while at < text.len() {\n            // This is the real inner loop. We take advantage of special bits\n            // set in the state pointer to determine whether a state is in the\n            // \"common\" case or not. Specifically, the common case is a\n            // non-match non-start non-dead state that has already been\n            // computed. So long as we remain in the common case, this inner\n            // loop will chew through the input.\n            //\n            // We also unroll the loop 4 times to amortize the cost of checking\n            // whether we've consumed the entire input. We are also careful\n            // to make sure that `prev_si` always represents the previous state\n            // and `next_si` always represents the next state after the loop\n            // exits, even if it isn't always true inside the loop.\n            while next_si <= STATE_MAX && at < text.len() {\n                // Argument for safety is in the definition of next_si.\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                at += 1;\n                if prev_si > STATE_MAX || at + 2 >= text.len() {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                at += 1;\n                if next_si > STATE_MAX {\n                    break;\n                }\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                at += 1;\n                if prev_si > STATE_MAX {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                at += 1;\n            }\n            if next_si & STATE_MATCH > 0 {\n                // A match state is outside of the common case because it needs\n                // special case analysis. In particular, we need to record the\n                // last position as having matched and possibly quit the DFA if\n                // we don't need to keep matching.\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at - 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n                prev_si = next_si;\n\n                // This permits short-circuiting when matching a regex set.\n                // In particular, if this DFA state contains only match states,\n                // then it's impossible to extend the set of matches since\n                // match states are final. Therefore, we can quit.\n                if self.prog.matches.len() > 1 {\n                    let state = self.state(next_si);\n                    let just_matches =\n                        state.inst_ptrs().all(|ip| self.prog[ip].is_match());\n                    if just_matches {\n                        return result;\n                    }\n                }\n\n                // Another inner loop! If the DFA stays in this particular\n                // match state, then we can rip through all of the input\n                // very quickly, and only recording the match location once\n                // we've left this particular state.\n                let cur = at;\n                while (next_si & !STATE_MATCH) == prev_si\n                    && at + 2 < text.len()\n                {\n                    // Argument for safety is in the definition of next_si.\n                    next_si = unsafe {\n                        self.next_si(next_si & !STATE_MATCH, text, at)\n                    };\n                    at += 1;\n                }\n                if at > cur {\n                    result = Result::Match(at - 2);\n                }\n            } else if next_si & STATE_START > 0 {\n                // A start state isn't in the common case because we may\n                // want to do quick prefix scanning. If the program doesn't\n                // have a detected prefix, then start states are actually\n                // considered common and this case is never reached.\n                debug_assert!(self.has_prefix());\n                next_si &= !STATE_START;\n                prev_si = next_si;\n                at = match self.prefix_at(text, at) {\n                    None => return Result::NoMatch(text.len()),\n                    Some(i) => i,\n                };\n            } else if next_si >= STATE_UNKNOWN {\n                if next_si == STATE_QUIT {\n                    return Result::Quit;\n                }\n                // Finally, this corresponds to the case where the transition\n                // entered a state that can never lead to a match or a state\n                // that hasn't been computed yet. The latter being the \"slow\"\n                // path.\n                let byte = Byte::byte(text[at - 1]);\n                // We no longer care about the special bits in the state\n                // pointer.\n                prev_si &= STATE_MAX;\n                // Record where we are. This is used to track progress for\n                // determining whether we should quit if we've flushed the\n                // cache too much.\n                self.at = at;\n                next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                    None => return Result::Quit,\n                    Some(STATE_DEAD) => return result.set_non_match(at),\n                    Some(si) => si,\n                };\n                debug_assert!(next_si != STATE_UNKNOWN);\n                if next_si & STATE_MATCH > 0 {\n                    next_si &= !STATE_MATCH;\n                    result = Result::Match(at - 1);\n                    if self.quit_after_match {\n                        return result;\n                    }\n                    self.last_match_si = next_si;\n                }\n                prev_si = next_si;\n            } else {\n                prev_si = next_si;\n            }\n        }\n\n        // Run the DFA once more on the special EOF sentinel value.\n        // We don't care about the special bits in the state pointer any more,\n        // so get rid of them.\n        prev_si &= STATE_MAX;\n        prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n            None => return Result::Quit,\n            Some(STATE_DEAD) => return result.set_non_match(text.len()),\n            Some(si) => si & !STATE_START,\n        };\n        debug_assert!(prev_si != STATE_UNKNOWN);\n        if prev_si & STATE_MATCH > 0 {\n            prev_si &= !STATE_MATCH;\n            self.last_match_si = prev_si;\n            result = Result::Match(text.len());\n        }\n        result\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::exec_at_reverse":["/// Executes the DFA on a reverse NFA.\ninline(always)\nfn exec_at_reverse(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        text: &[u8],\n    ) -> Result<usize>{\n        // The comments in `exec_at` above mostly apply here too. The main\n        // difference is that we move backwards over the input and we look for\n        // the longest possible match instead of the leftmost-first match.\n        //\n        // N.B. The code duplication here is regrettable. Efforts to improve\n        // it without sacrificing performance are welcome. ---AG\n        debug_assert!(self.prog.is_reverse);\n        let mut result = Result::NoMatch(self.at);\n        let (mut prev_si, mut next_si) = (self.start, self.start);\n        let mut at = self.at;\n        while at > 0 {\n            while next_si <= STATE_MAX && at > 0 {\n                // Argument for safety is in the definition of next_si.\n                at -= 1;\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                if prev_si > STATE_MAX || at <= 4 {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                at -= 1;\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n                if next_si > STATE_MAX {\n                    break;\n                }\n                at -= 1;\n                prev_si = unsafe { self.next_si(next_si, text, at) };\n                if prev_si > STATE_MAX {\n                    mem::swap(&mut prev_si, &mut next_si);\n                    break;\n                }\n                at -= 1;\n                next_si = unsafe { self.next_si(prev_si, text, at) };\n            }\n            if next_si & STATE_MATCH > 0 {\n                next_si &= !STATE_MATCH;\n                result = Result::Match(at + 1);\n                if self.quit_after_match {\n                    return result;\n                }\n                self.last_match_si = next_si;\n                prev_si = next_si;\n                let cur = at;\n                while (next_si & !STATE_MATCH) == prev_si && at >= 2 {\n                    // Argument for safety is in the definition of next_si.\n                    at -= 1;\n                    next_si = unsafe {\n                        self.next_si(next_si & !STATE_MATCH, text, at)\n                    };\n                }\n                if at < cur {\n                    result = Result::Match(at + 2);\n                }\n            } else if next_si >= STATE_UNKNOWN {\n                if next_si == STATE_QUIT {\n                    return Result::Quit;\n                }\n                let byte = Byte::byte(text[at]);\n                prev_si &= STATE_MAX;\n                self.at = at;\n                next_si = match self.next_state(qcur, qnext, prev_si, byte) {\n                    None => return Result::Quit,\n                    Some(STATE_DEAD) => return result.set_non_match(at),\n                    Some(si) => si,\n                };\n                debug_assert!(next_si != STATE_UNKNOWN);\n                if next_si & STATE_MATCH > 0 {\n                    next_si &= !STATE_MATCH;\n                    result = Result::Match(at + 1);\n                    if self.quit_after_match {\n                        return result;\n                    }\n                    self.last_match_si = next_si;\n                }\n                prev_si = next_si;\n            } else {\n                prev_si = next_si;\n            }\n        }\n\n        // Run the DFA once more on the special EOF sentinel value.\n        prev_si = match self.next_state(qcur, qnext, prev_si, Byte::eof()) {\n            None => return Result::Quit,\n            Some(STATE_DEAD) => return result.set_non_match(0),\n            Some(si) => si,\n        };\n        debug_assert!(prev_si != STATE_UNKNOWN);\n        if prev_si & STATE_MATCH > 0 {\n            prev_si &= !STATE_MATCH;\n            self.last_match_si = prev_si;\n            result = Result::Match(0);\n        }\n        result\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::exec_byte":["/// Computes the next state given the current state and the current input\n/// byte (which may be EOF).\n///\n/// If STATE_DEAD is returned, then there is no valid state transition.\n/// This implies that no permutation of future input can lead to a match\n/// state.\n///\n/// STATE_UNKNOWN can never be returned.\nfn exec_byte(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        mut si: StatePtr,\n        b: Byte,\n    ) -> Option<StatePtr>{\n        use crate::prog::Inst::*;\n\n        // Initialize a queue with the current DFA state's NFA states.\n        qcur.clear();\n        for ip in self.state(si).inst_ptrs() {\n            qcur.insert(ip);\n        }\n\n        // Before inspecting the current byte, we may need to also inspect\n        // whether the position immediately preceding the current byte\n        // satisfies the empty assertions found in the current state.\n        //\n        // We only need to do this step if there are any empty assertions in\n        // the current state.\n        let is_word_last = self.state(si).flags().is_word();\n        let is_word = b.is_ascii_word();\n        if self.state(si).flags().has_empty() {\n            // Compute the flags immediately preceding the current byte.\n            // This means we only care about the \"end\" or \"end line\" flags.\n            // (The \"start\" flags are computed immediately following the\n            // current byte and are handled below.)\n            let mut flags = EmptyFlags::default();\n            if b.is_eof() {\n                flags.end = true;\n                flags.end_line = true;\n            } else if b.as_byte().map_or(false, |b| b == b'\\n') {\n                flags.end_line = true;\n            }\n            if is_word_last == is_word {\n                flags.not_word_boundary = true;\n            } else {\n                flags.word_boundary = true;\n            }\n            // Now follow epsilon transitions from every NFA state, but make\n            // sure we only follow transitions that satisfy our flags.\n            qnext.clear();\n            for &ip in &*qcur {\n                self.follow_epsilons(usize_to_u32(ip), qnext, flags);\n            }\n            mem::swap(qcur, qnext);\n        }\n\n        // Now we set flags for immediately after the current byte. Since start\n        // states are processed separately, and are the only states that can\n        // have the StartText flag set, we therefore only need to worry about\n        // the StartLine flag here.\n        //\n        // We do also keep track of whether this DFA state contains a NFA state\n        // that is a matching state. This is precisely how we delay the DFA\n        // matching by one byte in order to process the special EOF sentinel\n        // byte. Namely, if this DFA state containing a matching NFA state,\n        // then it is the *next* DFA state that is marked as a match.\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start_line = b.as_byte().map_or(false, |b| b == b'\\n');\n        if b.is_ascii_word() {\n            state_flags.set_word();\n        }\n        // Now follow all epsilon transitions again, but only after consuming\n        // the current byte.\n        qnext.clear();\n        for &ip in &*qcur {\n            match self.prog[ip as usize] {\n                // These states never happen in a byte-based program.\n                Char(_) | Ranges(_) => unreachable!(),\n                // These states are handled when following epsilon transitions.\n                Save(_) | Split(_) | EmptyLook(_) => {}\n                Match(_) => {\n                    state_flags.set_match();\n                    if !self.continue_past_first_match() {\n                        break;\n                    } else if self.prog.matches.len() > 1\n                        && !qnext.contains(ip as usize)\n                    {\n                        // If we are continuing on to find other matches,\n                        // then keep a record of the match states we've seen.\n                        qnext.insert(ip);\n                    }\n                }\n                Bytes(ref inst) => {\n                    if b.as_byte().map_or(false, |b| inst.matches(b)) {\n                        self.follow_epsilons(\n                            inst.goto as InstPtr,\n                            qnext,\n                            empty_flags,\n                        );\n                    }\n                }\n            }\n        }\n\n        let cache = if b.is_eof() && self.prog.matches.len() > 1 {\n            // If we're processing the last byte of the input and we're\n            // matching a regex set, then make the next state contain the\n            // previous states transitions. We do this so that the main\n            // matching loop can extract all of the match instructions.\n            mem::swap(qcur, qnext);\n            // And don't cache this state because it's totally bunk.\n            false\n        } else {\n            true\n        };\n\n        // We've now built up the set of NFA states that ought to comprise the\n        // next DFA state, so try to find it in the cache, and if it doesn't\n        // exist, cache it.\n        //\n        // N.B. We pass `&mut si` here because the cache may clear itself if\n        // it has gotten too full. When that happens, the location of the\n        // current state may change.\n        let mut next =\n            match self.cached_state(qnext, state_flags, Some(&mut si)) {\n                None => return None,\n                Some(next) => next,\n            };\n        if (self.start & !STATE_START) == next {\n            // Start states can never be match states since all matches are\n            // delayed by one byte.\n            debug_assert!(!self.state(next).flags().is_match());\n            next = self.start_ptr(next);\n        }\n        if next <= STATE_MAX && self.state(next).flags().is_match() {\n            next |= STATE_MATCH;\n        }\n        debug_assert!(next != STATE_UNKNOWN);\n        // And now store our state in the current state's next list.\n        if cache {\n            let cls = self.byte_class(b);\n            self.cache.trans.set_next(si, cls, next);\n        }\n        Some(next)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::follow_epsilons":["/// Follows the epsilon transitions starting at (and including) `ip`. The\n/// resulting states are inserted into the ordered set `q`.\n///\n/// Conditional epsilon transitions (i.e., empty width assertions) are only\n/// followed if they are satisfied by the given flags, which should\n/// represent the flags set at the current location in the input.\n///\n/// If the current location corresponds to the empty string, then only the\n/// end line and/or end text flags may be set. If the current location\n/// corresponds to a real byte in the input, then only the start line\n/// and/or start text flags may be set.\n///\n/// As an exception to the above, when finding the initial state, any of\n/// the above flags may be set:\n///\n/// If matching starts at the beginning of the input, then start text and\n/// start line should be set. If the input is empty, then end text and end\n/// line should also be set.\n///\n/// If matching starts after the beginning of the input, then only start\n/// line should be set if the preceding byte is `\\n`. End line should never\n/// be set in this case. (Even if the following byte is a `\\n`, it will\n/// be handled in a subsequent DFA state.)\nfn follow_epsilons(\n        &mut self,\n        ip: InstPtr,\n        q: &mut SparseSet,\n        flags: EmptyFlags,\n    ){\n        use crate::prog::EmptyLook::*;\n        use crate::prog::Inst::*;\n\n        // We need to traverse the NFA to follow epsilon transitions, so avoid\n        // recursion with an explicit stack.\n        self.cache.stack.push(ip);\n        while let Some(mut ip) = self.cache.stack.pop() {\n            // Try to munch through as many states as possible without\n            // pushes/pops to the stack.\n            loop {\n                // Don't visit states we've already added.\n                if q.contains(ip as usize) {\n                    break;\n                }\n                q.insert(ip as usize);\n                match self.prog[ip as usize] {\n                    Char(_) | Ranges(_) => unreachable!(),\n                    Match(_) | Bytes(_) => {\n                        break;\n                    }\n                    EmptyLook(ref inst) => {\n                        // Only follow empty assertion states if our flags\n                        // satisfy the assertion.\n                        match inst.look {\n                            StartLine if flags.start_line => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            EndLine if flags.end_line => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            StartText if flags.start => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            EndText if flags.end => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            WordBoundaryAscii if flags.word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            NotWordBoundaryAscii\n                                if flags.not_word_boundary =>\n                            {\n                                ip = inst.goto as InstPtr;\n                            }\n                            WordBoundary if flags.word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            NotWordBoundary if flags.not_word_boundary => {\n                                ip = inst.goto as InstPtr;\n                            }\n                            StartLine | EndLine | StartText | EndText\n                            | WordBoundaryAscii | NotWordBoundaryAscii\n                            | WordBoundary | NotWordBoundary => {\n                                break;\n                            }\n                        }\n                    }\n                    Save(ref inst) => {\n                        ip = inst.goto as InstPtr;\n                    }\n                    Split(ref inst) => {\n                        self.cache.stack.push(inst.goto2 as InstPtr);\n                        ip = inst.goto1 as InstPtr;\n                    }\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::forward":["inline(always)\npub fn forward(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        quit_after_match: bool,\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize>{\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa;\n        let mut dfa = Fsm {\n            prog,\n            start: 0, // filled in below\n            at,\n            quit_after_match,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::forward_many":["inline(always)\npub fn forward_many(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        matches: &mut [bool],\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize>{\n        debug_assert!(matches.len() == prog.matches.len());\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa;\n        let mut dfa = Fsm {\n            prog,\n            start: 0, // filled in below\n            at,\n            quit_after_match: false,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        let result = dfa.exec_at(&mut cache.qcur, &mut cache.qnext, text);\n        if result.is_match() {\n            if matches.len() == 1 {\n                matches[0] = true;\n            } else {\n                debug_assert!(dfa.last_match_si != STATE_UNKNOWN);\n                debug_assert!(dfa.last_match_si != STATE_DEAD);\n                for ip in dfa.state(dfa.last_match_si).inst_ptrs() {\n                    if let Inst::Match(slot) = dfa.prog[ip] {\n                        matches[slot] = true;\n                    }\n                }\n            }\n        }\n        result\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::has_prefix":["/// Returns true if there is a prefix we can quickly search for.\nfn has_prefix(&self) -> bool{\n        !self.prog.is_reverse\n            && !self.prog.prefixes.is_empty()\n            && !self.prog.is_anchored_start\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::next_si":["/// next_si transitions to the next state, where the transition input\n/// corresponds to text[i].\n///\n/// This elides bounds checks, and is therefore not safe.\ninline(always)\nunsafe fn next_si(&self, si: StatePtr, text: &[u8], i: usize) -> StatePtr{\n        // What is the argument for safety here?\n        // We have three unchecked accesses that could possibly violate safety:\n        //\n        //   1. The given byte of input (`text[i]`).\n        //   2. The class of the byte of input (`classes[text[i]]`).\n        //   3. The transition for the class (`trans[si + cls]`).\n        //\n        // (1) is only safe when calling next_si is guarded by\n        // `i < text.len()`.\n        //\n        // (2) is the easiest case to guarantee since `text[i]` is always a\n        // `u8` and `self.prog.byte_classes` always has length `u8::MAX`.\n        // (See `ByteClassSet.byte_classes` in `compile.rs`.)\n        //\n        // (3) is only safe if (1)+(2) are safe. Namely, the transitions\n        // of every state are defined to have length equal to the number of\n        // byte classes in the program. Therefore, a valid class leads to a\n        // valid transition. (All possible transitions are valid lookups, even\n        // if it points to a state that hasn't been computed yet.) (3) also\n        // relies on `si` being correct, but StatePtrs should only ever be\n        // retrieved from the transition table, which ensures they are correct.\n        debug_assert!(i < text.len());\n        let b = *text.get_unchecked(i);\n        debug_assert!((b as usize) < self.prog.byte_classes.len());\n        let cls = *self.prog.byte_classes.get_unchecked(b as usize);\n        self.cache.trans.next_unchecked(si, cls as usize)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::next_state":["/// Returns the next state given the current state si and current byte\n/// b. {qcur,qnext} are used as scratch space for storing ordered NFA\n/// states.\n///\n/// This tries to fetch the next state from the cache, but if that fails,\n/// it computes the next state, caches it and returns a pointer to it.\n///\n/// The pointer can be to a real state, or it can be STATE_DEAD.\n/// STATE_UNKNOWN cannot be returned.\n///\n/// None is returned if a new state could not be allocated (i.e., the DFA\n/// ran out of space and thinks it's running too slowly).\nfn next_state(\n        &mut self,\n        qcur: &mut SparseSet,\n        qnext: &mut SparseSet,\n        si: StatePtr,\n        b: Byte,\n    ) -> Option<StatePtr>{\n        if si == STATE_DEAD {\n            return Some(STATE_DEAD);\n        }\n        match self.cache.trans.next(si, self.byte_class(b)) {\n            STATE_UNKNOWN => self.exec_byte(qcur, qnext, si, b),\n            STATE_QUIT => None,\n            nsi => Some(nsi),\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::num_byte_classes":["/// Returns the number of byte classes required to discriminate transitions\n/// in each state.\n///\n/// invariant: num_byte_classes() == len(State.next)\nfn num_byte_classes(&self) -> usize{\n        // We add 1 to account for the special EOF byte.\n        (self.prog.byte_classes[255] as usize + 1) + 1\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::prefix_at":["/// Quickly finds the next occurrence of any literal prefixes in the regex.\n/// If there are no literal prefixes, then the current position is\n/// returned. If there are literal prefixes and one could not be found,\n/// then None is returned.\n///\n/// This should only be called when the DFA is in a start state.\nfn prefix_at(&self, text: &[u8], at: usize) -> Option<usize>{\n        self.prog.prefixes.find(&text[at..]).map(|(s, _)| at + s)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::restore_state":["/// Restores the given state back into the cache, and returns a pointer\n/// to it.\nfn restore_state(&mut self, state: State) -> Option<StatePtr>{\n        // If we've already stored this state, just return a pointer to it.\n        // None will be the wiser.\n        if let Some(si) = self.cache.compiled.get_ptr(&state) {\n            return Some(si);\n        }\n        self.add_state(state)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::reverse":["inline(always)\npub fn reverse(\n        prog: &'a Program,\n        cache: &ProgramCache,\n        quit_after_match: bool,\n        text: &[u8],\n        at: usize,\n    ) -> Result<usize>{\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.dfa_reverse;\n        let mut dfa = Fsm {\n            prog,\n            start: 0, // filled in below\n            at,\n            quit_after_match,\n            last_match_si: STATE_UNKNOWN,\n            last_cache_flush: at,\n            cache: &mut cache.inner,\n        };\n        let (empty_flags, state_flags) = dfa.start_flags_reverse(text, at);\n        dfa.start =\n            match dfa.start_state(&mut cache.qcur, empty_flags, state_flags) {\n                None => return Result::Quit,\n                Some(STATE_DEAD) => return Result::NoMatch(at),\n                Some(si) => si,\n            };\n        debug_assert!(dfa.start != STATE_UNKNOWN);\n        dfa.exec_at_reverse(&mut cache.qcur, &mut cache.qnext, text)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::start_flags":["/// Computes the set of starting flags for the given position in text.\n///\n/// This should only be used when executing the DFA forwards over the\n/// input.\nfn start_flags(&self, text: &[u8], at: usize) -> (EmptyFlags, StateFlags){\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start = at == 0;\n        empty_flags.end = text.is_empty();\n        empty_flags.start_line = at == 0 || text[at - 1] == b'\\n';\n        empty_flags.end_line = text.is_empty();\n\n        let is_word_last = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n        let is_word = at < text.len() && Byte::byte(text[at]).is_ascii_word();\n        if is_word_last {\n            state_flags.set_word();\n        }\n        if is_word == is_word_last {\n            empty_flags.not_word_boundary = true;\n        } else {\n            empty_flags.word_boundary = true;\n        }\n        (empty_flags, state_flags)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::start_flags_reverse":["/// Computes the set of starting flags for the given position in text.\n///\n/// This should only be used when executing the DFA in reverse over the\n/// input.\nfn start_flags_reverse(\n        &self,\n        text: &[u8],\n        at: usize,\n    ) -> (EmptyFlags, StateFlags){\n        let mut empty_flags = EmptyFlags::default();\n        let mut state_flags = StateFlags::default();\n        empty_flags.start = at == text.len();\n        empty_flags.end = text.is_empty();\n        empty_flags.start_line = at == text.len() || text[at] == b'\\n';\n        empty_flags.end_line = text.is_empty();\n\n        let is_word_last =\n            at < text.len() && Byte::byte(text[at]).is_ascii_word();\n        let is_word = at > 0 && Byte::byte(text[at - 1]).is_ascii_word();\n        if is_word_last {\n            state_flags.set_word();\n        }\n        if is_word == is_word_last {\n            empty_flags.not_word_boundary = true;\n        } else {\n            empty_flags.word_boundary = true;\n        }\n        (empty_flags, state_flags)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::start_ptr":["/// Sets the STATE_START bit in the given state pointer if and only if\n/// we have a prefix to scan for.\n///\n/// If there's no prefix, then it's a waste to treat the start state\n/// specially.\nfn start_ptr(&self, si: StatePtr) -> StatePtr{\n        if self.has_prefix() {\n            si | STATE_START\n        } else {\n            si\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::start_state":["/// Computes and returns the start state, where searching begins at\n/// position `at` in `text`. If the state has already been computed,\n/// then it is pulled from the cache. If the state hasn't been cached,\n/// then it is computed, cached and a pointer to it is returned.\n///\n/// This may return STATE_DEAD but never STATE_UNKNOWN.\ninline(always)\nfn start_state(\n        &mut self,\n        q: &mut SparseSet,\n        empty_flags: EmptyFlags,\n        state_flags: StateFlags,\n    ) -> Option<StatePtr>{\n        // Compute an index into our cache of start states based on the set\n        // of empty/state flags set at the current position in the input. We\n        // don't use every flag since not all flags matter. For example, since\n        // matches are delayed by one byte, start states can never be match\n        // states.\n        let flagi = {\n            (((empty_flags.start as u8) << 0)\n                | ((empty_flags.end as u8) << 1)\n                | ((empty_flags.start_line as u8) << 2)\n                | ((empty_flags.end_line as u8) << 3)\n                | ((empty_flags.word_boundary as u8) << 4)\n                | ((empty_flags.not_word_boundary as u8) << 5)\n                | ((state_flags.is_word() as u8) << 6)) as usize\n        };\n        match self.cache.start_states[flagi] {\n            STATE_UNKNOWN => {}\n            si => return Some(si),\n        }\n        q.clear();\n        let start = usize_to_u32(self.prog.start);\n        self.follow_epsilons(start, q, empty_flags);\n        // Start states can never be match states because we delay every match\n        // by one byte. Given an empty string and an empty match, the match\n        // won't actually occur until the DFA processes the special EOF\n        // sentinel byte.\n        let sp = match self.cached_state(q, state_flags, None) {\n            None => return None,\n            Some(sp) => self.start_ptr(sp),\n        };\n        self.cache.start_states[flagi] = sp;\n        Some(sp)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::state":["/// Returns a reference to a State given a pointer to it.\nfn state(&self, si: StatePtr) -> &State{\n        self.cache.compiled.get_state(si).unwrap()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Fsm::<'a>::u8_class":["/// Like byte_class, but explicitly for u8s.\ninline(always)\nfn u8_class(&self, b: u8) -> usize{\n        self.prog.byte_classes[b as usize] as usize\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::InstPtrs":["struct InstPtrs<'a> {\n    base: usize,\n    data: &'a [u8],\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Result":["/// The result of running the DFA.\n///\n/// Generally, the result is either a match or not a match, but sometimes the\n/// DFA runs too slowly because the cache size is too small. In that case, it\n/// gives up with the intent of falling back to the NFA algorithm.\n///\n/// The DFA can also give up if it runs out of room to create new states, or if\n/// it sees non-ASCII bytes in the presence of a Unicode word boundary.\npub enum Result<T> {\n    Match(T),\n    NoMatch(usize),\n    Quit,\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Result::<T>::is_match":["/// Returns true if this result corresponds to a match.\npub fn is_match(&self) -> bool{\n        match *self {\n            Result::Match(_) => true,\n            Result::NoMatch(_) | Result::Quit => false,\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Result::<T>::map":["/// Maps the given function onto T and returns the result.\n///\n/// If this isn't a match, then this is a no-op.\n#[cfg(feature = \"perf-literal\")]\npub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> Result<U>{\n        match self {\n            Result::Match(t) => Result::Match(f(t)),\n            Result::NoMatch(x) => Result::NoMatch(x),\n            Result::Quit => Result::Quit,\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Result::<T>::set_non_match":["/// Sets the non-match position.\n///\n/// If this isn't a non-match, then this is a no-op.\nfn set_non_match(self, at: usize) -> Result<T>{\n        match self {\n            Result::NoMatch(_) => Result::NoMatch(at),\n            r => r,\n        }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::State":["/// `State` is a DFA state. It contains an ordered set of NFA states (not\n/// necessarily complete) and a smattering of flags.\n///\n/// The flags are packed into the first byte of data.\n///\n/// States don't carry their transitions. Instead, transitions are stored in\n/// a single row-major table.\n///\n/// Delta encoding is used to store the instruction pointers.\n/// The first instruction pointer is stored directly starting\n/// at data[1], and each following pointer is stored as an offset\n/// to the previous one. If a delta is in the range -127..127,\n/// it is packed into a single byte; Otherwise the byte 128 (-128 as an i8)\n/// is coded as a flag, followed by 4 bytes encoding the delta.\nstruct State {\n    data: Arc<[u8]>,\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::State::flags":["fn flags(&self) -> StateFlags{\n        StateFlags(self.data[0])\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::State::inst_ptrs":["fn inst_ptrs(&self) -> InstPtrs<'_>{\n        InstPtrs { base: 0, data: &self.data[1..] }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateFlags":["/// A set of flags describing various configurations of a DFA state. This is\n/// represented by a `u8` so that it is compact.\nstruct StateFlags(u8);","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateFlags::has_empty":["fn has_empty(&self) -> bool{\n        self.0 & 0b0000_0100 > 0\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateFlags::is_match":["fn is_match(&self) -> bool{\n        self.0 & 0b0000_0001 > 0\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateFlags::is_word":["fn is_word(&self) -> bool{\n        self.0 & 0b0000_0010 > 0\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateFlags::set_empty":["fn set_empty(&mut self){\n        self.0 |= 0b0000_0100;\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateFlags::set_match":["fn set_match(&mut self){\n        self.0 |= 0b0000_0001;\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateFlags::set_word":["fn set_word(&mut self){\n        self.0 |= 0b0000_0010;\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateMap":["/// An abstraction for representing a map of states. The map supports two\n/// different ways of state lookup. One is fast constant time access via a\n/// state pointer. The other is a hashmap lookup based on the DFA's\n/// constituent NFA states.\n///\n/// A DFA state internally uses an Arc such that we only need to store the\n/// set of NFA states on the heap once, even though we support looking up\n/// states by two different means. A more natural way to express this might\n/// use raw pointers, but an Arc is safe and effectively achieves the same\n/// thing.\nstruct StateMap {\n    /// The keys are not actually static but rely on always pointing to a\n    /// buffer in `states` which will never be moved except when clearing\n    /// the map or on drop, in which case the keys of this map will be\n    /// removed before\n    map: HashMap<State, StatePtr>,\n    /// Our set of states. Note that `StatePtr / num_byte_classes` indexes\n    /// this Vec rather than just a `StatePtr`.\n    states: Vec<State>,\n    /// The number of byte classes in the DFA. Used to index `states`.\n    num_byte_classes: usize,\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateMap::clear":["fn clear(&mut self){\n        self.map.clear();\n        self.states.clear();\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateMap::get_ptr":["fn get_ptr(&self, state: &State) -> Option<StatePtr>{\n        self.map.get(state).cloned()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateMap::get_state":["fn get_state(&self, si: StatePtr) -> Option<&State>{\n        self.states.get(si as usize / self.num_byte_classes)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateMap::insert":["fn insert(&mut self, state: State, si: StatePtr){\n        self.map.insert(state.clone(), si);\n        self.states.push(state);\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateMap::is_empty":["fn is_empty(&self) -> bool{\n        self.states.is_empty()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateMap::len":["fn len(&self) -> usize{\n        self.states.len()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::StateMap::new":["fn new(num_byte_classes: usize) -> StateMap{\n        StateMap { map: HashMap::new(), states: vec![], num_byte_classes }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions":["/// The transition table.\n///\n/// It is laid out in row-major order, with states as rows and byte class\n/// transitions as columns.\n///\n/// The transition table is responsible for producing valid `StatePtrs`. A\n/// `StatePtr` points to the start of a particular row in this table. When\n/// indexing to find the next state this allows us to avoid a multiplication\n/// when computing an index into the table.\nstruct Transitions {\n    /// The table.\n    table: Vec<StatePtr>,\n    /// The stride.\n    num_byte_classes: usize,\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions::add":["/// Allocates room for one additional state and returns a pointer to it.\n///\n/// If there's no more room, None is returned.\nfn add(&mut self) -> Option<StatePtr>{\n        let si = self.table.len();\n        if si > STATE_MAX as usize {\n            return None;\n        }\n        self.table.extend(repeat(STATE_UNKNOWN).take(self.num_byte_classes));\n        Some(usize_to_u32(si))\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions::clear":["/// Clears the table of all states.\nfn clear(&mut self){\n        self.table.clear();\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions::new":["/// Create a new transition table.\n///\n/// The number of byte classes corresponds to the stride. Every state will\n/// have `num_byte_classes` slots for transitions.\nfn new(num_byte_classes: usize) -> Transitions{\n        Transitions { table: vec![], num_byte_classes }\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions::next":["/// Returns the transition corresponding to (si, cls).\nfn next(&self, si: StatePtr, cls: usize) -> StatePtr{\n        self.table[si as usize + cls]\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions::next_unchecked":["/// Like `next`, but uses unchecked access and is therefore not safe.\nunsafe fn next_unchecked(&self, si: StatePtr, cls: usize) -> StatePtr{\n        debug_assert!((si as usize) < self.table.len());\n        debug_assert!(cls < self.num_byte_classes);\n        *self.table.get_unchecked(si as usize + cls)\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions::num_states":["/// Returns the total number of states currently in this table.\nfn num_states(&self) -> usize{\n        self.table.len() / self.num_byte_classes\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions::set_next":["/// Sets the transition from (si, cls) to next.\nfn set_next(&mut self, si: StatePtr, cls: usize, next: StatePtr){\n        self.table[si as usize + cls] = next;\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::Transitions::state_heap_size":["/// The heap size, in bytes, of a single state in the transition table.\nfn state_heap_size(&self) -> usize{\n        self.num_byte_classes * mem::size_of::<StatePtr>()\n    }","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::TransitionsRow":["struct TransitionsRow<'a>(&'a [StatePtr]);","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::can_exec":["/// Return true if and only if the given program can be executed by a DFA.\n///\n/// Generally, a DFA is always possible. A pathological case where it is not\n/// possible is if the number of NFA states exceeds `u32::MAX`, in which case,\n/// this function will return false.\n///\n/// This function will also return false if the given program has any Unicode\n/// instructions (Char or Ranges) since the DFA operates on bytes only.\npub fn can_exec(insts: &Program) -> bool{\n    use crate::prog::Inst::*;\n    // If for some reason we manage to allocate a regex program with more\n    // than i32::MAX instructions, then we can't execute the DFA because we\n    // use 32 bit instruction pointer deltas for memory savings.\n    // If i32::MAX is the largest positive delta,\n    // then -i32::MAX == i32::MIN + 1 is the largest negative delta,\n    // and we are OK to use 32 bits.\n    if insts.dfa_size_limit == 0 || insts.len() > ::std::i32::MAX as usize {\n        return false;\n    }\n    for inst in insts {\n        match *inst {\n            Char(_) | Ranges(_) => return false,\n            EmptyLook(_) | Match(_) | Save(_) | Split(_) | Bytes(_) => {}\n        }\n    }\n    true\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::push_inst_ptr":["/// Adds ip to data using delta encoding with respect to prev.\n///\n/// After completion, `data` will contain `ip` and `prev` will be set to `ip`.\nfn push_inst_ptr(data: &mut Vec<u8>, prev: &mut InstPtr, ip: InstPtr){\n    let delta = (ip as i32) - (*prev as i32);\n    write_vari32(data, delta);\n    *prev = ip;\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::read_vari32":["/// https://developers.google.com/protocol-buffers/docs/encoding#varints\nfn read_vari32(data: &[u8]) -> (i32, usize){\n    let (un, i) = read_varu32(data);\n    let mut n = (un >> 1) as i32;\n    if un & 1 != 0 {\n        n = !n;\n    }\n    (n, i)\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::read_varu32":["/// https://developers.google.com/protocol-buffers/docs/encoding#varints\nfn read_varu32(data: &[u8]) -> (u32, usize){\n    let mut n: u32 = 0;\n    let mut shift: u32 = 0;\n    for (i, &b) in data.iter().enumerate() {\n        if b < 0b1000_0000 {\n            return (n | ((b as u32) << shift), i + 1);\n        }\n        n |= ((b as u32) & 0b0111_1111) << shift;\n        shift += 7;\n    }\n    (0, 0)\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::show_state_ptr":["#[allow(dead_code)]\nfn show_state_ptr(si: StatePtr) -> String{\n    let mut s = format!(\"{:?}\", si & STATE_MAX);\n    if si == STATE_UNKNOWN {\n        s = format!(\"{} (unknown)\", s);\n    }\n    if si == STATE_DEAD {\n        s = format!(\"{} (dead)\", s);\n    }\n    if si == STATE_QUIT {\n        s = format!(\"{} (quit)\", s);\n    }\n    if si & STATE_START > 0 {\n        s = format!(\"{} (start)\", s);\n    }\n    if si & STATE_MATCH > 0 {\n        s = format!(\"{} (match)\", s);\n    }\n    s\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::usize_to_u32":["fn usize_to_u32(n: usize) -> u32{\n    if (n as u64) > (::std::u32::MAX as u64) {\n        panic!(\"BUG: {} is too big to fit into u32\", n)\n    }\n    n as u32\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::vb":["/// Helper function for formatting a byte as a nice-to-read escaped string.\nfn vb(b: usize) -> String{\n    use std::ascii::escape_default;\n\n    if b > ::std::u8::MAX as usize {\n        \"EOF\".to_owned()\n    } else {\n        let escaped = escape_default(b as u8).collect::<Vec<u8>>();\n        String::from_utf8_lossy(&escaped).into_owned()\n    }\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::write_vari32":["/// https://developers.google.com/protocol-buffers/docs/encoding#varints\nfn write_vari32(data: &mut Vec<u8>, n: i32){\n    let mut un = (n as u32) << 1;\n    if n < 0 {\n        un = !un;\n    }\n    write_varu32(data, un)\n}","Real(LocalPath(\"src/dfa.rs\"))"],"dfa::write_varu32":["/// https://developers.google.com/protocol-buffers/docs/encoding#varints\nfn write_varu32(data: &mut Vec<u8>, mut n: u32){\n    while n >= 0b1000_0000 {\n        data.push((n as u8) | 0b1000_0000);\n        n >>= 7;\n    }\n    data.push(n as u8);\n}","Real(LocalPath(\"src/dfa.rs\"))"],"error::Error":["/// An error that occurred during parsing or compiling a regular expression.\npub enum Error {\n    /// A syntax error.\n    Syntax(String),\n    /// The compiled program exceeded the set size\n    /// limit. The argument is the size limit imposed by\n    /// [`RegexBuilder::size_limit`](crate::RegexBuilder::size_limit). Even\n    /// when not configured explicitly, it defaults to a reasonable limit.\n    ///\n    /// If you're getting this error, it occurred because your regex has been\n    /// compiled to an intermediate state that is too big. It is important to\n    /// note that exceeding this limit does _not_ mean the regex is too big to\n    /// _work_, but rather, the regex is big enough that it may wind up being\n    /// surprisingly slow when used in a search. In other words, this error is\n    /// meant to be a practical heuristic for avoiding a performance footgun,\n    /// and especially so for the case where the regex pattern is coming from\n    /// an untrusted source.\n    ///\n    /// There are generally two ways to move forward if you hit this error.\n    /// The first is to find some way to use a smaller regex. The second is to\n    /// increase the size limit via `RegexBuilder::size_limit`. However, if\n    /// your regex pattern is not from a trusted source, then neither of these\n    /// approaches may be appropriate. Instead, you'll have to determine just\n    /// how big of a regex you want to allow.\n    CompiledTooBig(usize),\n    /// Hints that destructuring should not be exhaustive.\n    ///\n    /// This enum may grow additional variants, so this makes sure clients\n    /// don't count on exhaustive matching. (Otherwise, adding a new variant\n    /// could break existing code.)\n    #[doc(hidden)]\n    __Nonexhaustive,\n}","Real(LocalPath(\"src/error.rs\"))"],"exec::Exec":["/// `Exec` manages the execution of a regular expression.\n///\n/// In particular, this manages the various compiled forms of a single regular\n/// expression and the choice of which matching engine to use to execute a\n/// regular expression.\npub struct Exec {\n    /// All read only state.\n    ro: Arc<ExecReadOnly>,\n    /// A pool of reusable values for the various matching engines.\n    ///\n    /// Note that boxing this value is not strictly necessary, but it is an\n    /// easy way to ensure that T does not bloat the stack sized used by a pool\n    /// in the case where T is big. And this turns out to be the case at the\n    /// time of writing for regex's use of this pool. At the time of writing,\n    /// the size of a Regex on the stack is 856 bytes. Boxing this value\n    /// reduces that size to 16 bytes.\n    pool: Box<Pool<ProgramCache>>,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::capture_name_idx":["/// Return a reference to named groups mapping (from group name to\n/// group position).\npub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>>{\n        &self.ro.nfa.capture_name_idx\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::capture_names":["/// Return a slice of capture names.\n///\n/// Any capture that isn't named is None.\npub fn capture_names(&self) -> &[Option<String>]{\n        &self.ro.nfa.captures\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::into_byte_regex":["/// Build a Regex from this executor that can match arbitrary bytes.\npub fn into_byte_regex(self) -> re_bytes::Regex{\n        re_bytes::Regex::from(self)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::into_byte_regex_set":["/// Build a RegexSet from this executor that can match arbitrary bytes.\npub fn into_byte_regex_set(self) -> re_set::bytes::RegexSet{\n        re_set::bytes::RegexSet::from(self)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::into_regex":["/// Build a Regex from this executor.\npub fn into_regex(self) -> re_unicode::Regex{\n        re_unicode::Regex::from(self)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::into_regex_set":["/// Build a RegexSet from this executor.\npub fn into_regex_set(self) -> re_set::unicode::RegexSet{\n        re_set::unicode::RegexSet::from(self)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::regex_strings":["/// The original regular expressions given by the caller that were\n/// compiled.\npub fn regex_strings(&self) -> &[String]{\n        &self.ro.res\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::searcher":["/// Get a searcher that isn't Sync.\ninline(always)\npub fn searcher(&self) -> ExecNoSync<'_>{\n        ExecNoSync {\n            ro: &self.ro, // a clone is too expensive here! (and not needed)\n            cache: self.pool.get(),\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::searcher_str":["/// Get a searcher that isn't Sync and can match on &str.\ninline(always)\npub fn searcher_str(&self) -> ExecNoSyncStr<'_>{\n        ExecNoSyncStr(self.searcher())\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::Exec::static_captures_len":["/// If the number of capture groups in every match is always the same, then\n/// return that number. Otherwise return `None`.\npub fn static_captures_len(&self) -> Option<usize>{\n        self.ro.nfa.static_captures_len\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder":["/// Facilitates the construction of an executor by exposing various knobs\n/// to control how a regex is executed and what kinds of resources it's\n/// permitted to use.\n#[allow(missing_debug_implementations)]\npub struct ExecBuilder {\n    options: RegexOptions,\n    match_type: Option<MatchType>,\n    bytes: bool,\n    only_utf8: bool,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::automatic":["/// Set the matching engine to be automatically determined.\n///\n/// This is the default state and will apply whatever optimizations are\n/// possible, such as running a DFA.\n///\n/// This overrides whatever was previously set via the `nfa` or\n/// `bounded_backtracking` methods.\npub fn automatic(mut self) -> Self{\n        self.match_type = None;\n        self\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::bounded_backtracking":["/// Sets the matching engine to use a bounded backtracking engine no\n/// matter what optimizations are possible.\n///\n/// One must use this with care, since the bounded backtracking engine\n/// uses memory proportion to `len(regex) * len(text)`.\n///\n/// This overrides whatever was previously set via the `automatic` or\n/// `nfa` methods.\npub fn bounded_backtracking(mut self) -> Self{\n        self.match_type = Some(MatchType::Nfa(MatchNfaType::Backtrack));\n        self\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::build":["/// Build an executor that can run a regular expression.\npub fn build(self) -> Result<Exec, Error>{\n        // Special case when we have no patterns to compile.\n        // This can happen when compiling a regex set.\n        if self.options.pats.is_empty() {\n            let ro = Arc::new(ExecReadOnly {\n                res: vec![],\n                nfa: Program::new(),\n                dfa: Program::new(),\n                dfa_reverse: Program::new(),\n                suffixes: LiteralSearcher::empty(),\n                #[cfg(feature = \"perf-literal\")]\n                ac: None,\n                match_type: MatchType::Nothing,\n            });\n            let pool = ExecReadOnly::new_pool(&ro);\n            return Ok(Exec { ro, pool });\n        }\n        let parsed = self.parse()?;\n        let mut nfa = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .bytes(self.bytes || parsed.bytes)\n            .only_utf8(self.only_utf8)\n            .compile(&parsed.exprs)?;\n        let mut dfa = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .dfa(true)\n            .only_utf8(self.only_utf8)\n            .compile(&parsed.exprs)?;\n        let mut dfa_reverse = Compiler::new()\n            .size_limit(self.options.size_limit)\n            .dfa(true)\n            .only_utf8(self.only_utf8)\n            .reverse(true)\n            .compile(&parsed.exprs)?;\n\n        #[cfg(feature = \"perf-literal\")]\n        let ac = self.build_aho_corasick(&parsed);\n        nfa.prefixes = LiteralSearcher::prefixes(parsed.prefixes);\n        dfa.prefixes = nfa.prefixes.clone();\n        dfa.dfa_size_limit = self.options.dfa_size_limit;\n        dfa_reverse.dfa_size_limit = self.options.dfa_size_limit;\n\n        let mut ro = ExecReadOnly {\n            res: self.options.pats,\n            nfa,\n            dfa,\n            dfa_reverse,\n            suffixes: LiteralSearcher::suffixes(parsed.suffixes),\n            #[cfg(feature = \"perf-literal\")]\n            ac,\n            match_type: MatchType::Nothing,\n        };\n        ro.match_type = ro.choose_match_type(self.match_type);\n\n        let ro = Arc::new(ro);\n        let pool = ExecReadOnly::new_pool(&ro);\n        Ok(Exec { ro, pool })\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::build_aho_corasick":["#[cfg(feature = \"perf-literal\")]\nfn build_aho_corasick(&self, parsed: &Parsed) -> Option<AhoCorasick>{\n        if parsed.exprs.len() != 1 {\n            return None;\n        }\n        let lits = match alternation_literals(&parsed.exprs[0]) {\n            None => return None,\n            Some(lits) => lits,\n        };\n        // If we have a small number of literals, then let Teddy handle\n        // things (see literal/mod.rs).\n        if lits.len() <= 32 {\n            return None;\n        }\n        Some(\n            AhoCorasick::builder()\n                .match_kind(MatchKind::LeftmostFirst)\n                .build(&lits)\n                // This should never happen because we'd long exceed the\n                // compilation limit for regexes first.\n                .expect(\"AC automaton too big\"),\n        )\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::bytes":["/// Compiles byte based programs for use with the NFA matching engines.\n///\n/// By default, the NFA engines match on Unicode scalar values. They can\n/// be made to use byte based programs instead. In general, the byte based\n/// programs are slower because of a less efficient encoding of character\n/// classes.\n///\n/// Note that this does not impact DFA matching engines, which always\n/// execute on bytes.\npub fn bytes(mut self, yes: bool) -> Self{\n        self.bytes = yes;\n        self\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::new":["/// Create a regex execution builder.\n///\n/// This uses default settings for everything except the regex itself,\n/// which must be provided. Further knobs can be set by calling methods,\n/// and then finally, `build` to actually create the executor.\npub fn new(re: &str) -> Self{\n        Self::new_many(&[re])\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::new_many":["/// Like new, but compiles the union of the given regular expressions.\n///\n/// Note that when compiling 2 or more regular expressions, capture groups\n/// are completely unsupported. (This means both `find` and `captures`\n/// won't work.)\npub fn new_many<I, S>(res: I) -> Self\n    where\n        S: AsRef<str>,\n        I: IntoIterator<Item = S>,{\n        let mut opts = RegexOptions::default();\n        opts.pats = res.into_iter().map(|s| s.as_ref().to_owned()).collect();\n        Self::new_options(opts)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::new_options":["/// Create a regex execution builder.\npub fn new_options(opts: RegexOptions) -> Self{\n        ExecBuilder {\n            options: opts,\n            match_type: None,\n            bytes: false,\n            only_utf8: true,\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::nfa":["/// Sets the matching engine to use the NFA algorithm no matter what\n/// optimizations are possible.\n///\n/// This overrides whatever was previously set via the `automatic` or\n/// `bounded_backtracking` methods.\npub fn nfa(mut self) -> Self{\n        self.match_type = Some(MatchType::Nfa(MatchNfaType::PikeVM));\n        self\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::only_utf8":["/// When disabled, the program compiled may match arbitrary bytes.\n///\n/// When enabled (the default), all compiled programs exclusively match\n/// valid UTF-8 bytes.\npub fn only_utf8(mut self, yes: bool) -> Self{\n        self.only_utf8 = yes;\n        self\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::parse":["/// Parse the current set of patterns into their AST and extract literals.\nfn parse(&self) -> Result<Parsed, Error>{\n        let mut exprs = Vec::with_capacity(self.options.pats.len());\n        let mut prefixes = Some(literal::Seq::empty());\n        let mut suffixes = Some(literal::Seq::empty());\n        let mut bytes = false;\n        let is_set = self.options.pats.len() > 1;\n        // If we're compiling a regex set and that set has any anchored\n        // expressions, then disable all literal optimizations.\n        for pat in &self.options.pats {\n            let mut parser = ParserBuilder::new()\n                .octal(self.options.octal)\n                .case_insensitive(self.options.case_insensitive)\n                .multi_line(self.options.multi_line)\n                .dot_matches_new_line(self.options.dot_matches_new_line)\n                .swap_greed(self.options.swap_greed)\n                .ignore_whitespace(self.options.ignore_whitespace)\n                .unicode(self.options.unicode)\n                .utf8(self.only_utf8)\n                .nest_limit(self.options.nest_limit)\n                .build();\n            let expr =\n                parser.parse(pat).map_err(|e| Error::Syntax(e.to_string()))?;\n            let props = expr.properties();\n            // This used to just check whether the HIR matched valid UTF-8\n            // or not, but in regex-syntax 0.7, we changed our definition of\n            // \"matches valid UTF-8\" to exclude zero-width matches. And in\n            // particular, previously, we considered WordAsciiNegate (that\n            // is '(?-u:\\B)') to be capable of matching invalid UTF-8. Our\n            // matcher engines were built under this assumption and fixing\n            // them is not worth it with the imminent plan to switch over to\n            // regex-automata. So for now, we retain the previous behavior by\n            // just explicitly treating the presence of a negated ASCII word\n            // boundary as forcing use to use a byte oriented automaton.\n            bytes = bytes\n                || !props.is_utf8()\n                || props.look_set().contains(Look::WordAsciiNegate);\n\n            if cfg!(feature = \"perf-literal\") {\n                if !props.look_set_prefix().contains(Look::Start)\n                    && props.look_set().contains(Look::Start)\n                {\n                    // Partial anchors unfortunately make it hard to use\n                    // prefixes, so disable them.\n                    prefixes = None;\n                } else if is_set\n                    && props.look_set_prefix_any().contains(Look::Start)\n                {\n                    // Regex sets with anchors do not go well with literal\n                    // optimizations.\n                    prefixes = None;\n                } else if props.look_set_prefix_any().contains_word() {\n                    // The new literal extractor ignores look-around while\n                    // the old one refused to extract prefixes from regexes\n                    // that began with a \\b. These old creaky regex internals\n                    // can't deal with it, so we drop it.\n                    prefixes = None;\n                } else if props.look_set_prefix_any().contains(Look::StartLF) {\n                    // Similar to the reasoning for word boundaries, this old\n                    // regex engine can't handle literal prefixes with '(?m:^)'\n                    // at the beginning of a regex.\n                    prefixes = None;\n                }\n\n                if !props.look_set_suffix().contains(Look::End)\n                    && props.look_set().contains(Look::End)\n                {\n                    // Partial anchors unfortunately make it hard to use\n                    // suffixes, so disable them.\n                    suffixes = None;\n                } else if is_set\n                    && props.look_set_suffix_any().contains(Look::End)\n                {\n                    // Regex sets with anchors do not go well with literal\n                    // optimizations.\n                    suffixes = None;\n                } else if props.look_set_suffix_any().contains_word() {\n                    // See the prefix case for reasoning here.\n                    suffixes = None;\n                } else if props.look_set_suffix_any().contains(Look::EndLF) {\n                    // See the prefix case for reasoning here.\n                    suffixes = None;\n                }\n\n                let (mut pres, mut suffs) =\n                    if prefixes.is_none() && suffixes.is_none() {\n                        (literal::Seq::infinite(), literal::Seq::infinite())\n                    } else {\n                        literal_analysis(&expr)\n                    };\n                // These old creaky regex internals can't handle cases where\n                // the literal sequences are exact but there are look-around\n                // assertions. So we make sure the sequences are inexact if\n                // there are look-around assertions anywhere. This forces the\n                // regex engines to run instead of assuming that a literal\n                // match implies an overall match.\n                if !props.look_set().is_empty() {\n                    pres.make_inexact();\n                    suffs.make_inexact();\n                }\n                prefixes = prefixes.and_then(|mut prefixes| {\n                    prefixes.union(&mut pres);\n                    Some(prefixes)\n                });\n                suffixes = suffixes.and_then(|mut suffixes| {\n                    suffixes.union(&mut suffs);\n                    Some(suffixes)\n                });\n            }\n            exprs.push(expr);\n        }\n        Ok(Parsed {\n            exprs,\n            prefixes: prefixes.unwrap_or_else(literal::Seq::empty),\n            suffixes: suffixes.unwrap_or_else(literal::Seq::empty),\n            bytes,\n        })\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecBuilder::unicode":["/// Set the Unicode flag.\npub fn unicode(mut self, yes: bool) -> Self{\n        self.options.unicode = yes;\n        self\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync":["/// `ExecNoSync` is like `Exec`, except it embeds a reference to a cache. This\n/// means it is no longer Sync, but we can now avoid the overhead of\n/// synchronization to fetch the cache.\npub struct ExecNoSync<'c> {\n    /// All read only state.\n    ro: &'c Arc<ExecReadOnly>,\n    /// Caches for the various matching engines.\n    cache: PoolGuard<'c, ProgramCache>,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::capture_name_idx":["pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>>{\n        &self.ro.nfa.capture_name_idx\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::captures_nfa":["/// Like find_nfa, but fills in captures.\n///\n/// `slots` should have length equal to `2 * nfa.captures.len()`.\n#[cfg(feature = \"perf-dfa\")]\nfn captures_nfa(\n        &self,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)>{\n        self.captures_nfa_type(\n            MatchNfaType::Auto,\n            slots,\n            text,\n            start,\n            text.len(),\n        )\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::captures_nfa_type":["/// Like captures_nfa, but allows specification of type of NFA engine.\nfn captures_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> Option<(usize, usize)>{\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            slots,\n            false,\n            false,\n            text,\n            start,\n            end,\n        ) {\n            match (slots[0], slots[1]) {\n                (Some(s), Some(e)) => Some((s, e)),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::exec_backtrack":["/// Always runs the NFA using bounded backtracking.\nfn exec_backtrack(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool{\n        if self.ro.nfa.uses_bytes() {\n            backtrack::Bounded::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                ByteInput::new(text, self.ro.nfa.only_utf8),\n                start,\n                end,\n            )\n        } else {\n            backtrack::Bounded::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                CharInput::new(text),\n                start,\n                end,\n            )\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix":["/// Finds the end of the shortest match using only the DFA by scanning for\n/// suffix literals. It also reports the start of the match.\n///\n/// Note that if None is returned, then the optimization gave up to avoid\n/// worst case quadratic behavior. A forward scanning DFA should be tried\n/// next.\n///\n/// If a match is returned and the full leftmost-first match is desired,\n/// then a forward scan starting from the beginning of the match must be\n/// done.\n///\n/// If the result returned indicates that the DFA quit, then another\n/// matching engine should be used.\n#[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\ninline(always)\nfn exec_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        original_start: usize,\n    ) -> Option<dfa::Result<(usize, usize)>>{\n        use crate::dfa::Result::*;\n\n        let lcs = self.ro.suffixes.lcs();\n        debug_assert!(lcs.len() >= 1);\n        let mut start = original_start;\n        let mut end = start;\n        let mut last_literal = start;\n        while end <= text.len() {\n            last_literal += match lcs.find(&text[last_literal..]) {\n                None => return Some(NoMatch(text.len())),\n                Some(i) => i,\n            };\n            end = last_literal + lcs.len();\n            match dfa::Fsm::reverse(\n                &self.ro.dfa_reverse,\n                self.cache.value(),\n                false,\n                &text[start..end],\n                end - start,\n            ) {\n                Match(0) | NoMatch(0) => return None,\n                Match(i) => return Some(Match((start + i, end))),\n                NoMatch(i) => {\n                    start += i;\n                    last_literal += 1;\n                    continue;\n                }\n                Quit => return Some(Quit),\n            };\n        }\n        Some(NoMatch(text.len()))\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::exec_nfa":["fn exec_nfa(\n        &self,\n        mut ty: MatchNfaType,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        quit_after_match_with_pos: bool,\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool{\n        use self::MatchNfaType::*;\n        if let Auto = ty {\n            if backtrack::should_exec(self.ro.nfa.len(), text.len()) {\n                ty = Backtrack;\n            } else {\n                ty = PikeVM;\n            }\n        }\n        // The backtracker can't return the shortest match position as it is\n        // implemented today. So if someone calls `shortest_match` and we need\n        // to run an NFA, then use the PikeVM.\n        if quit_after_match_with_pos || ty == PikeVM {\n            self.exec_pikevm(\n                matches,\n                slots,\n                quit_after_match,\n                text,\n                start,\n                end,\n            )\n        } else {\n            self.exec_backtrack(matches, slots, text, start, end)\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::exec_pikevm":["/// Always run the NFA algorithm.\nfn exec_pikevm(\n        &self,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        text: &[u8],\n        start: usize,\n        end: usize,\n    ) -> bool{\n        if self.ro.nfa.uses_bytes() {\n            pikevm::Fsm::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                quit_after_match,\n                ByteInput::new(text, self.ro.nfa.only_utf8),\n                start,\n                end,\n            )\n        } else {\n            pikevm::Fsm::exec(\n                &self.ro.nfa,\n                self.cache.value(),\n                matches,\n                slots,\n                quit_after_match,\n                CharInput::new(text),\n                start,\n                end,\n            )\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::find_dfa_anchored_reverse":["/// Finds the leftmost-first match (start and end) using only the DFA,\n/// but assumes the regex is anchored at the end and therefore starts at\n/// the end of the regex and matches in reverse.\n///\n/// If the result returned indicates that the DFA quit, then another\n/// matching engine should be used.\n#[cfg(feature = \"perf-dfa\")]\ninline(always)\nfn find_dfa_anchored_reverse(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)>{\n        use crate::dfa::Result::*;\n        match dfa::Fsm::reverse(\n            &self.ro.dfa_reverse,\n            self.cache.value(),\n            false,\n            &text[start..],\n            text.len() - start,\n        ) {\n            Match(s) => Match((start + s, text.len())),\n            NoMatch(i) => NoMatch(i),\n            Quit => Quit,\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::find_dfa_forward":["/// Finds the leftmost-first match (start and end) using only the DFA.\n///\n/// If the result returned indicates that the DFA quit, then another\n/// matching engine should be used.\n#[cfg(feature = \"perf-dfa\")]\ninline(always)\nfn find_dfa_forward(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)>{\n        use crate::dfa::Result::*;\n        let end = match dfa::Fsm::forward(\n            &self.ro.dfa,\n            self.cache.value(),\n            false,\n            text,\n            start,\n        ) {\n            NoMatch(i) => return NoMatch(i),\n            Quit => return Quit,\n            Match(end) if start == end => return Match((start, start)),\n            Match(end) => end,\n        };\n        // Now run the DFA in reverse to find the start of the match.\n        match dfa::Fsm::reverse(\n            &self.ro.dfa_reverse,\n            self.cache.value(),\n            false,\n            &text[start..],\n            end - start,\n        ) {\n            Match(s) => Match((start + s, end)),\n            NoMatch(i) => NoMatch(i),\n            Quit => Quit,\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::find_dfa_reverse_suffix":["/// Finds the leftmost-first match (start and end) using only the DFA\n/// by scanning for suffix literals.\n///\n/// If the result returned indicates that the DFA quit, then another\n/// matching engine should be used.\n#[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\ninline(always)\nfn find_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<(usize, usize)>{\n        use crate::dfa::Result::*;\n\n        let match_start = match self.exec_dfa_reverse_suffix(text, start) {\n            None => return self.find_dfa_forward(text, start),\n            Some(Match((start, _))) => start,\n            Some(r) => return r,\n        };\n        // At this point, we've found a match. The only way to quit now\n        // without a match is if the DFA gives up (seems unlikely).\n        //\n        // Now run the DFA forwards to find the proper end of the match.\n        // (The suffix literal match can only indicate the earliest\n        // possible end location, which may appear before the end of the\n        // leftmost-first match.)\n        match dfa::Fsm::forward(\n            &self.ro.dfa,\n            self.cache.value(),\n            false,\n            text,\n            match_start,\n        ) {\n            NoMatch(_) => panic!(\"BUG: reverse match implies forward match\"),\n            Quit => Quit,\n            Match(e) => Match((match_start, e)),\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::find_literals":["/// Finds the leftmost-first match using only literal search.\n#[cfg(feature = \"perf-literal\")]\ninline(always)\nfn find_literals(\n        &self,\n        ty: MatchLiteralType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)>{\n        use self::MatchLiteralType::*;\n        match ty {\n            Unanchored => {\n                let lits = &self.ro.nfa.prefixes;\n                lits.find(&text[start..]).map(|(s, e)| (start + s, start + e))\n            }\n            AnchoredStart => {\n                let lits = &self.ro.nfa.prefixes;\n                if start == 0 || !self.ro.nfa.is_anchored_start {\n                    lits.find_start(&text[start..])\n                        .map(|(s, e)| (start + s, start + e))\n                } else {\n                    None\n                }\n            }\n            AnchoredEnd => {\n                let lits = &self.ro.suffixes;\n                lits.find_end(&text[start..])\n                    .map(|(s, e)| (start + s, start + e))\n            }\n            AhoCorasick => self\n                .ro\n                .ac\n                .as_ref()\n                .unwrap()\n                .find(&text[start..])\n                .map(|m| (start + m.start(), start + m.end())),\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::find_nfa":["/// Like find, but executes an NFA engine.\nfn find_nfa(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<(usize, usize)>{\n        let mut slots = [None, None];\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut slots,\n            false,\n            false,\n            text,\n            start,\n            text.len(),\n        ) {\n            match (slots[0], slots[1]) {\n                (Some(s), Some(e)) => Some((s, e)),\n                _ => None,\n            }\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::is_anchor_end_match":["inline(always)\nfn is_anchor_end_match(&self, text: &[u8]) -> bool{\n        #[cfg(not(feature = \"perf-literal\"))]\n        fn imp(_: &ExecReadOnly, _: &[u8]) -> bool {\n            true\n        }\n\n        #[cfg(feature = \"perf-literal\")]\n        fn imp(ro: &ExecReadOnly, text: &[u8]) -> bool {\n            // Only do this check if the haystack is big (>1MB).\n            if text.len() > (1 << 20) && ro.nfa.is_anchored_end {\n                let lcs = ro.suffixes.lcs();\n                if lcs.len() >= 1 && !lcs.is_suffix(text) {\n                    return false;\n                }\n            }\n            true\n        }\n\n        imp(&self.ro, text)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::is_anchor_end_match::imp":["#[cfg(feature = \"perf-literal\")]\nfn imp(ro: &ExecReadOnly, text: &[u8]) -> bool{\n            // Only do this check if the haystack is big (>1MB).\n            if text.len() > (1 << 20) && ro.nfa.is_anchored_end {\n                let lcs = ro.suffixes.lcs();\n                if lcs.len() >= 1 && !lcs.is_suffix(text) {\n                    return false;\n                }\n            }\n            true\n        }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::many_matches_at":["/// Finds which regular expressions match the given text.\n///\n/// `matches` should have length equal to the number of regexes being\n/// searched.\n///\n/// This is only useful when one wants to know which regexes in a set\n/// match some text.\npub fn many_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: &[u8],\n        start: usize,\n    ) -> bool{\n        use self::MatchType::*;\n        if !self.is_anchor_end_match(text) {\n            return false;\n        }\n        match self.ro.match_type {\n            #[cfg(feature = \"perf-literal\")]\n            Literal(ty) => {\n                debug_assert_eq!(matches.len(), 1);\n                matches[0] = self.find_literals(ty, text, start).is_some();\n                matches[0]\n            }\n            #[cfg(feature = \"perf-dfa\")]\n            Dfa | DfaAnchoredReverse | DfaMany => {\n                match dfa::Fsm::forward_many(\n                    &self.ro.dfa,\n                    self.cache.value(),\n                    matches,\n                    text,\n                    start,\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.exec_nfa(\n                        MatchNfaType::Auto,\n                        matches,\n                        &mut [],\n                        false,\n                        false,\n                        text,\n                        start,\n                        text.len(),\n                    ),\n                }\n            }\n            #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n            DfaSuffix => {\n                match dfa::Fsm::forward_many(\n                    &self.ro.dfa,\n                    self.cache.value(),\n                    matches,\n                    text,\n                    start,\n                ) {\n                    dfa::Result::Match(_) => true,\n                    dfa::Result::NoMatch(_) => false,\n                    dfa::Result::Quit => self.exec_nfa(\n                        MatchNfaType::Auto,\n                        matches,\n                        &mut [],\n                        false,\n                        false,\n                        text,\n                        start,\n                        text.len(),\n                    ),\n                }\n            }\n            Nfa(ty) => self.exec_nfa(\n                ty,\n                matches,\n                &mut [],\n                false,\n                false,\n                text,\n                start,\n                text.len(),\n            ),\n            Nothing => false,\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::match_nfa":["/// Executes the NFA engine to return whether there is a match or not.\n///\n/// Ideally, we could use shortest_nfa(...).is_some() and get the same\n/// performance characteristics, but regex sets don't have captures, which\n/// shortest_nfa depends on.\n#[cfg(feature = \"perf-dfa\")]\nfn match_nfa(&self, text: &[u8], start: usize) -> bool{\n        self.match_nfa_type(MatchNfaType::Auto, text, start)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::match_nfa_type":["/// Like match_nfa, but allows specification of the type of NFA engine.\nfn match_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> bool{\n        self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut [],\n            true,\n            false,\n            text,\n            start,\n            text.len(),\n        )\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::shortest_dfa":["/// Finds the end of the shortest match using only the DFA.\n#[cfg(feature = \"perf-dfa\")]\ninline(always)\nfn shortest_dfa(&self, text: &[u8], start: usize) -> dfa::Result<usize>{\n        dfa::Fsm::forward(&self.ro.dfa, self.cache.value(), true, text, start)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix":["/// Finds the end of the shortest match using only the DFA by scanning for\n/// suffix literals.\n#[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\ninline(always)\nfn shortest_dfa_reverse_suffix(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> dfa::Result<usize>{\n        match self.exec_dfa_reverse_suffix(text, start) {\n            None => self.shortest_dfa(text, start),\n            Some(r) => r.map(|(_, end)| end),\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::shortest_nfa":["/// Finds the shortest match using an NFA.\n#[cfg(feature = \"perf-dfa\")]\nfn shortest_nfa(&self, text: &[u8], start: usize) -> Option<usize>{\n        self.shortest_nfa_type(MatchNfaType::Auto, text, start)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSync::<'c>::shortest_nfa_type":["/// Like shortest_nfa, but allows specification of the type of NFA engine.\nfn shortest_nfa_type(\n        &self,\n        ty: MatchNfaType,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize>{\n        let mut slots = [None, None];\n        if self.exec_nfa(\n            ty,\n            &mut [false],\n            &mut slots,\n            true,\n            true,\n            text,\n            start,\n            text.len(),\n        ) {\n            slots[1]\n        } else {\n            None\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSyncStr":["/// `ExecNoSyncStr` is like `ExecNoSync`, but matches on &str instead of &[u8].\npub struct ExecNoSyncStr<'c>(ExecNoSync<'c>);","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecNoSyncStr::<'c>::capture_name_idx":["pub fn capture_name_idx(&self) -> &Arc<HashMap<String, usize>>{\n        self.0.capture_name_idx()\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecReadOnly":["/// `ExecReadOnly` comprises all read only state for a regex. Namely, all such\n/// state is determined at compile time and never changes during search.\nstruct ExecReadOnly {\n    /// The original regular expressions given by the caller to compile.\n    res: Vec<String>,\n    /// A compiled program that is used in the NFA simulation and backtracking.\n    /// It can be byte-based or Unicode codepoint based.\n    ///\n    /// N.B. It is not possibly to make this byte-based from the public API.\n    /// It is only used for testing byte based programs in the NFA simulations.\n    nfa: Program,\n    /// A compiled byte based program for DFA execution. This is only used\n    /// if a DFA can be executed. (Currently, only word boundary assertions are\n    /// not supported.) Note that this program contains an embedded `.*?`\n    /// preceding the first capture group, unless the regex is anchored at the\n    /// beginning.\n    #[allow(dead_code)]\n    dfa: Program,\n    /// The same as above, except the program is reversed (and there is no\n    /// preceding `.*?`). This is used by the DFA to find the starting location\n    /// of matches.\n    #[allow(dead_code)]\n    dfa_reverse: Program,\n    /// A set of suffix literals extracted from the regex.\n    ///\n    /// Prefix literals are stored on the `Program`, since they are used inside\n    /// the matching engines.\n    #[allow(dead_code)]\n    suffixes: LiteralSearcher,\n    /// An Aho-Corasick automaton with leftmost-first match semantics.\n    ///\n    /// This is only set when the entire regex is a simple unanchored\n    /// alternation of literals. We could probably use it more circumstances,\n    /// but this is already hacky enough in this architecture.\n    ///\n    /// N.B. We use u32 as a state ID representation under the assumption that\n    /// if we were to exhaust the ID space, we probably would have long\n    /// surpassed the compilation size limit.\n    #[cfg(feature = \"perf-literal\")]\n    ac: Option<AhoCorasick>,\n    /// match_type encodes as much upfront knowledge about how we're going to\n    /// execute a search as possible.\n    match_type: MatchType,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecReadOnly::choose_dfa_match_type":["/// If a DFA scan can be used, then choose the appropriate DFA strategy.\nfn choose_dfa_match_type(&self) -> Option<MatchType>{\n        #[cfg(not(feature = \"perf-dfa\"))]\n        fn imp(_: &ExecReadOnly) -> Option<MatchType> {\n            None\n        }\n\n        #[cfg(feature = \"perf-dfa\")]\n        fn imp(ro: &ExecReadOnly) -> Option<MatchType> {\n            if !dfa::can_exec(&ro.dfa) {\n                return None;\n            }\n            // Regex sets require a slightly specialized path.\n            if ro.res.len() >= 2 {\n                return Some(MatchType::DfaMany);\n            }\n            // If the regex is anchored at the end but not the start, then\n            // just match in reverse from the end of the haystack.\n            if !ro.nfa.is_anchored_start && ro.nfa.is_anchored_end {\n                return Some(MatchType::DfaAnchoredReverse);\n            }\n            #[cfg(feature = \"perf-literal\")]\n            {\n                // If there's a longish suffix literal, then it might be faster\n                // to look for that first.\n                if ro.should_suffix_scan() {\n                    return Some(MatchType::DfaSuffix);\n                }\n            }\n            // Fall back to your garden variety forward searching lazy DFA.\n            Some(MatchType::Dfa)\n        }\n\n        imp(self)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecReadOnly::choose_dfa_match_type::imp":["#[cfg(feature = \"perf-dfa\")]\nfn imp(ro: &ExecReadOnly) -> Option<MatchType>{\n            if !dfa::can_exec(&ro.dfa) {\n                return None;\n            }\n            // Regex sets require a slightly specialized path.\n            if ro.res.len() >= 2 {\n                return Some(MatchType::DfaMany);\n            }\n            // If the regex is anchored at the end but not the start, then\n            // just match in reverse from the end of the haystack.\n            if !ro.nfa.is_anchored_start && ro.nfa.is_anchored_end {\n                return Some(MatchType::DfaAnchoredReverse);\n            }\n            #[cfg(feature = \"perf-literal\")]\n            {\n                // If there's a longish suffix literal, then it might be faster\n                // to look for that first.\n                if ro.should_suffix_scan() {\n                    return Some(MatchType::DfaSuffix);\n                }\n            }\n            // Fall back to your garden variety forward searching lazy DFA.\n            Some(MatchType::Dfa)\n        }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecReadOnly::choose_literal_match_type":["/// If a plain literal scan can be used, then a corresponding literal\n/// search type is returned.\nfn choose_literal_match_type(&self) -> Option<MatchType>{\n        #[cfg(not(feature = \"perf-literal\"))]\n        fn imp(_: &ExecReadOnly) -> Option<MatchType> {\n            None\n        }\n\n        #[cfg(feature = \"perf-literal\")]\n        fn imp(ro: &ExecReadOnly) -> Option<MatchType> {\n            // If our set of prefixes is complete, then we can use it to find\n            // a match in lieu of a regex engine. This doesn't quite work well\n            // in the presence of multiple regexes, so only do it when there's\n            // one.\n            //\n            // TODO(burntsushi): Also, don't try to match literals if the regex\n            // is partially anchored. We could technically do it, but we'd need\n            // to create two sets of literals: all of them and then the subset\n            // that aren't anchored. We would then only search for all of them\n            // when at the beginning of the input and use the subset in all\n            // other cases.\n            if ro.res.len() != 1 {\n                return None;\n            }\n            if ro.ac.is_some() {\n                return Some(MatchType::Literal(\n                    MatchLiteralType::AhoCorasick,\n                ));\n            }\n            if ro.nfa.prefixes.complete() {\n                return if ro.nfa.is_anchored_start {\n                    Some(MatchType::Literal(MatchLiteralType::AnchoredStart))\n                } else {\n                    Some(MatchType::Literal(MatchLiteralType::Unanchored))\n                };\n            }\n            if ro.suffixes.complete() {\n                return if ro.nfa.is_anchored_end {\n                    Some(MatchType::Literal(MatchLiteralType::AnchoredEnd))\n                } else {\n                    // This case shouldn't happen. When the regex isn't\n                    // anchored, then complete prefixes should imply complete\n                    // suffixes.\n                    //\n                    // The above is wrong! This case can happen. While\n                    // complete prefixes should imply complete suffixes\n                    // here, that doesn't necessarily mean we have a useful\n                    // prefix matcher! It could be the case that the literal\n                    // searcher decided the prefixes---even though they are\n                    // \"complete\"---weren't good enough and thus created an\n                    // empty matcher. If that happens and we return Unanchored\n                    // here, then we'll end up using that matcher, which is\n                    // very bad because it matches at every position. So...\n                    // return None.\n                    None\n                };\n            }\n            None\n        }\n\n        imp(self)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecReadOnly::choose_literal_match_type::imp":["#[cfg(feature = \"perf-literal\")]\nfn imp(ro: &ExecReadOnly) -> Option<MatchType>{\n            // If our set of prefixes is complete, then we can use it to find\n            // a match in lieu of a regex engine. This doesn't quite work well\n            // in the presence of multiple regexes, so only do it when there's\n            // one.\n            //\n            // TODO(burntsushi): Also, don't try to match literals if the regex\n            // is partially anchored. We could technically do it, but we'd need\n            // to create two sets of literals: all of them and then the subset\n            // that aren't anchored. We would then only search for all of them\n            // when at the beginning of the input and use the subset in all\n            // other cases.\n            if ro.res.len() != 1 {\n                return None;\n            }\n            if ro.ac.is_some() {\n                return Some(MatchType::Literal(\n                    MatchLiteralType::AhoCorasick,\n                ));\n            }\n            if ro.nfa.prefixes.complete() {\n                return if ro.nfa.is_anchored_start {\n                    Some(MatchType::Literal(MatchLiteralType::AnchoredStart))\n                } else {\n                    Some(MatchType::Literal(MatchLiteralType::Unanchored))\n                };\n            }\n            if ro.suffixes.complete() {\n                return if ro.nfa.is_anchored_end {\n                    Some(MatchType::Literal(MatchLiteralType::AnchoredEnd))\n                } else {\n                    // This case shouldn't happen. When the regex isn't\n                    // anchored, then complete prefixes should imply complete\n                    // suffixes.\n                    //\n                    // The above is wrong! This case can happen. While\n                    // complete prefixes should imply complete suffixes\n                    // here, that doesn't necessarily mean we have a useful\n                    // prefix matcher! It could be the case that the literal\n                    // searcher decided the prefixes---even though they are\n                    // \"complete\"---weren't good enough and thus created an\n                    // empty matcher. If that happens and we return Unanchored\n                    // here, then we'll end up using that matcher, which is\n                    // very bad because it matches at every position. So...\n                    // return None.\n                    None\n                };\n            }\n            None\n        }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecReadOnly::choose_match_type":["fn choose_match_type(&self, hint: Option<MatchType>) -> MatchType{\n        if let Some(MatchType::Nfa(_)) = hint {\n            return hint.unwrap();\n        }\n        // If the NFA is empty, then we'll never match anything.\n        if self.nfa.insts.is_empty() {\n            return MatchType::Nothing;\n        }\n        if let Some(literalty) = self.choose_literal_match_type() {\n            return literalty;\n        }\n        if let Some(dfaty) = self.choose_dfa_match_type() {\n            return dfaty;\n        }\n        // We're so totally hosed.\n        MatchType::Nfa(MatchNfaType::Auto)\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecReadOnly::new_pool":["fn new_pool(ro: &Arc<ExecReadOnly>) -> Box<Pool<ProgramCache>>{\n        let ro = ro.clone();\n        Box::new(Pool::new(Box::new(move || {\n            AssertUnwindSafe(RefCell::new(ProgramCacheInner::new(&ro)))\n        })))\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::ExecReadOnly::should_suffix_scan":["/// Returns true if the program is amenable to suffix scanning.\n///\n/// When this is true, as a heuristic, we assume it is OK to quickly scan\n/// for suffix literals and then do a *reverse* DFA match from any matches\n/// produced by the literal scan. (And then followed by a forward DFA\n/// search, since the previously found suffix literal maybe not actually be\n/// the end of a match.)\n///\n/// This is a bit of a specialized optimization, but can result in pretty\n/// big performance wins if 1) there are no prefix literals and 2) the\n/// suffix literals are pretty rare in the text. (1) is obviously easy to\n/// account for but (2) is harder. As a proxy, we assume that longer\n/// strings are generally rarer, so we only enable this optimization when\n/// we have a meaty suffix.\n#[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\nfn should_suffix_scan(&self) -> bool{\n        if self.suffixes.is_empty() {\n            return false;\n        }\n        let lcs_len = self.suffixes.lcs().char_len();\n        lcs_len >= 3 && lcs_len > self.dfa.prefixes.lcp().char_len()\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::MatchLiteralType":["#[cfg(feature = \"perf-literal\")]\nenum MatchLiteralType {\n    /// Match literals anywhere in text.\n    Unanchored,\n    /// Match literals only at the start of text.\n    AnchoredStart,\n    /// Match literals only at the end of text.\n    AnchoredEnd,\n    /// Use an Aho-Corasick automaton. This requires `ac` to be Some on\n    /// ExecReadOnly.\n    AhoCorasick,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::MatchNfaType":["enum MatchNfaType {\n    /// Choose between Backtrack and PikeVM.\n    Auto,\n    /// NFA bounded backtracking.\n    ///\n    /// (This is only set by tests, since it never makes sense to always want\n    /// backtracking.)\n    Backtrack,\n    /// The Pike VM.\n    ///\n    /// (This is only set by tests, since it never makes sense to always want\n    /// the Pike VM.)\n    PikeVM,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::MatchType":["enum MatchType {\n    /// A single or multiple literal search. This is only used when the regex\n    /// can be decomposed into a literal search.\n    #[cfg(feature = \"perf-literal\")]\n    Literal(MatchLiteralType),\n    /// A normal DFA search.\n    #[cfg(feature = \"perf-dfa\")]\n    Dfa,\n    /// A reverse DFA search starting from the end of a haystack.\n    #[cfg(feature = \"perf-dfa\")]\n    DfaAnchoredReverse,\n    /// A reverse DFA search with suffix literal scanning.\n    #[cfg(all(feature = \"perf-dfa\", feature = \"perf-literal\"))]\n    DfaSuffix,\n    /// Use the DFA on two or more regular expressions.\n    #[cfg(feature = \"perf-dfa\")]\n    DfaMany,\n    /// An NFA variant.\n    Nfa(MatchNfaType),\n    /// No match is ever possible, so don't ever try to search.\n    Nothing,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::Parsed":["/// Parsed represents a set of parsed regular expressions and their detected\n/// literals.\nstruct Parsed {\n    exprs: Vec<Hir>,\n    prefixes: literal::Seq,\n    suffixes: literal::Seq,\n    bytes: bool,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::ProgramCacheInner":["pub struct ProgramCacheInner {\n    pub pikevm: pikevm::Cache,\n    pub backtrack: backtrack::Cache,\n    #[cfg(feature = \"perf-dfa\")]\n    pub dfa: dfa::Cache,\n    #[cfg(feature = \"perf-dfa\")]\n    pub dfa_reverse: dfa::Cache,\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::ProgramCacheInner::new":["fn new(ro: &ExecReadOnly) -> Self{\n        ProgramCacheInner {\n            pikevm: pikevm::Cache::new(&ro.nfa),\n            backtrack: backtrack::Cache::new(&ro.nfa),\n            #[cfg(feature = \"perf-dfa\")]\n            dfa: dfa::Cache::new(&ro.dfa),\n            #[cfg(feature = \"perf-dfa\")]\n            dfa_reverse: dfa::Cache::new(&ro.dfa_reverse),\n        }\n    }","Real(LocalPath(\"src/exec.rs\"))"],"exec::alternation_literals":["/// Alternation literals checks if the given HIR is a simple alternation of\n/// literals, and if so, returns them. Otherwise, this returns None.\n#[cfg(feature = \"perf-literal\")]\nfn alternation_literals(expr: &Hir) -> Option<Vec<Vec<u8>>>{\n    use regex_syntax::hir::{HirKind, Literal};\n\n    // This is pretty hacky, but basically, if `is_alternation_literal` is\n    // true, then we can make several assumptions about the structure of our\n    // HIR. This is what justifies the `unreachable!` statements below.\n    //\n    // This code should be refactored once we overhaul this crate's\n    // optimization pipeline, because this is a terribly inflexible way to go\n    // about things.\n\n    if !expr.properties().is_alternation_literal() {\n        return None;\n    }\n    let alts = match *expr.kind() {\n        HirKind::Alternation(ref alts) => alts,\n        _ => return None, // one literal isn't worth it\n    };\n\n    let mut lits = vec![];\n    for alt in alts {\n        let mut lit = vec![];\n        match *alt.kind() {\n            HirKind::Literal(Literal(ref bytes)) => {\n                lit.extend_from_slice(bytes)\n            }\n            HirKind::Concat(ref exprs) => {\n                for e in exprs {\n                    match *e.kind() {\n                        HirKind::Literal(Literal(ref bytes)) => {\n                            lit.extend_from_slice(bytes);\n                        }\n                        _ => unreachable!(\"expected literal, got {:?}\", e),\n                    }\n                }\n            }\n            _ => unreachable!(\"expected literal or concat, got {:?}\", alt),\n        }\n        lits.push(lit);\n    }\n    Some(lits)\n}","Real(LocalPath(\"src/exec.rs\"))"],"exec::literal_analysis":["#[cfg(feature = \"perf-literal\")]\nfn literal_analysis(expr: &Hir) -> (literal::Seq, literal::Seq){\n    const ATTEMPTS: [(usize, usize); 3] = [(5, 50), (4, 30), (3, 20)];\n\n    let mut prefixes = literal::Extractor::new()\n        .kind(literal::ExtractKind::Prefix)\n        .extract(expr);\n    for (keep, limit) in ATTEMPTS {\n        let len = match prefixes.len() {\n            None => break,\n            Some(len) => len,\n        };\n        if len <= limit {\n            break;\n        }\n        prefixes.keep_first_bytes(keep);\n        prefixes.minimize_by_preference();\n    }\n\n    let mut suffixes = literal::Extractor::new()\n        .kind(literal::ExtractKind::Suffix)\n        .extract(expr);\n    for (keep, limit) in ATTEMPTS {\n        let len = match suffixes.len() {\n            None => break,\n            Some(len) => len,\n        };\n        if len <= limit {\n            break;\n        }\n        suffixes.keep_last_bytes(keep);\n        suffixes.minimize_by_preference();\n    }\n\n    (prefixes, suffixes)\n}","Real(LocalPath(\"src/exec.rs\"))"],"expand::CaptureRef":["/// `CaptureRef` represents a reference to a capture group inside some text.\n/// The reference is either a capture group name or a number.\n///\n/// It is also tagged with the position in the text following the\n/// capture reference.\nstruct CaptureRef<'a> {\n    cap: Ref<'a>,\n    end: usize,\n}","Real(LocalPath(\"src/expand.rs\"))"],"expand::Ref":["/// A reference to a capture group in some text.\n///\n/// e.g., `$2`, `$foo`, `${foo}`.\nenum Ref<'a> {\n    Named(&'a str),\n    Number(usize),\n}","Real(LocalPath(\"src/expand.rs\"))"],"expand::expand_bytes":["pub fn expand_bytes(\n    caps: &re_bytes::Captures<'_>,\n    mut replacement: &[u8],\n    dst: &mut Vec<u8>,\n){\n    while !replacement.is_empty() {\n        match find_byte(b'$', replacement) {\n            None => break,\n            Some(i) => {\n                dst.extend(&replacement[..i]);\n                replacement = &replacement[i..];\n            }\n        }\n        if replacement.get(1).map_or(false, |&b| b == b'$') {\n            dst.push(b'$');\n            replacement = &replacement[2..];\n            continue;\n        }\n        debug_assert!(!replacement.is_empty());\n        let cap_ref = match find_cap_ref(replacement) {\n            Some(cap_ref) => cap_ref,\n            None => {\n                dst.push(b'$');\n                replacement = &replacement[1..];\n                continue;\n            }\n        };\n        replacement = &replacement[cap_ref.end..];\n        match cap_ref.cap {\n            Ref::Number(i) => {\n                dst.extend(caps.get(i).map(|m| m.as_bytes()).unwrap_or(b\"\"));\n            }\n            Ref::Named(name) => {\n                dst.extend(\n                    caps.name(name).map(|m| m.as_bytes()).unwrap_or(b\"\"),\n                );\n            }\n        }\n    }\n    dst.extend(replacement);\n}","Real(LocalPath(\"src/expand.rs\"))"],"expand::expand_str":["pub fn expand_str(\n    caps: &re_unicode::Captures<'_>,\n    mut replacement: &str,\n    dst: &mut String,\n){\n    while !replacement.is_empty() {\n        match find_byte(b'$', replacement.as_bytes()) {\n            None => break,\n            Some(i) => {\n                dst.push_str(&replacement[..i]);\n                replacement = &replacement[i..];\n            }\n        }\n        if replacement.as_bytes().get(1).map_or(false, |&b| b == b'$') {\n            dst.push_str(\"$\");\n            replacement = &replacement[2..];\n            continue;\n        }\n        debug_assert!(!replacement.is_empty());\n        let cap_ref = match find_cap_ref(replacement.as_bytes()) {\n            Some(cap_ref) => cap_ref,\n            None => {\n                dst.push_str(\"$\");\n                replacement = &replacement[1..];\n                continue;\n            }\n        };\n        replacement = &replacement[cap_ref.end..];\n        match cap_ref.cap {\n            Ref::Number(i) => {\n                dst.push_str(caps.get(i).map(|m| m.as_str()).unwrap_or(\"\"));\n            }\n            Ref::Named(name) => {\n                dst.push_str(\n                    caps.name(name).map(|m| m.as_str()).unwrap_or(\"\"),\n                );\n            }\n        }\n    }\n    dst.push_str(replacement);\n}","Real(LocalPath(\"src/expand.rs\"))"],"expand::find_cap_ref":["/// Parses a possible reference to a capture group name in the given text,\n/// starting at the beginning of `replacement`.\n///\n/// If no such valid reference could be found, None is returned.\nfn find_cap_ref(replacement: &[u8]) -> Option<CaptureRef<'_>>{\n    let mut i = 0;\n    let rep: &[u8] = replacement;\n    if rep.len() <= 1 || rep[0] != b'$' {\n        return None;\n    }\n    i += 1;\n    if rep[i] == b'{' {\n        return find_cap_ref_braced(rep, i + 1);\n    }\n    let mut cap_end = i;\n    while rep.get(cap_end).copied().map_or(false, is_valid_cap_letter) {\n        cap_end += 1;\n    }\n    if cap_end == i {\n        return None;\n    }\n    // We just verified that the range 0..cap_end is valid ASCII, so it must\n    // therefore be valid UTF-8. If we really cared, we could avoid this UTF-8\n    // check via an unchecked conversion or by parsing the number straight from\n    // &[u8].\n    let cap =\n        str::from_utf8(&rep[i..cap_end]).expect(\"valid UTF-8 capture name\");\n    Some(CaptureRef {\n        cap: match cap.parse::<u32>() {\n            Ok(i) => Ref::Number(i as usize),\n            Err(_) => Ref::Named(cap),\n        },\n        end: cap_end,\n    })\n}","Real(LocalPath(\"src/expand.rs\"))"],"expand::find_cap_ref_braced":["fn find_cap_ref_braced(rep: &[u8], mut i: usize) -> Option<CaptureRef<'_>>{\n    let start = i;\n    while rep.get(i).map_or(false, |&b| b != b'}') {\n        i += 1;\n    }\n    if !rep.get(i).map_or(false, |&b| b == b'}') {\n        return None;\n    }\n    // When looking at braced names, we don't put any restrictions on the name,\n    // so it's possible it could be invalid UTF-8. But a capture group name\n    // can never be invalid UTF-8, so if we have invalid UTF-8, then we can\n    // safely return None.\n    let cap = match str::from_utf8(&rep[start..i]) {\n        Err(_) => return None,\n        Ok(cap) => cap,\n    };\n    Some(CaptureRef {\n        cap: match cap.parse::<u32>() {\n            Ok(i) => Ref::Number(i as usize),\n            Err(_) => Ref::Named(cap),\n        },\n        end: i + 1,\n    })\n}","Real(LocalPath(\"src/expand.rs\"))"],"expand::is_valid_cap_letter":["/// Returns true if and only if the given byte is allowed in a capture name\n/// written in non-brace form.\nfn is_valid_cap_letter(b: u8) -> bool{\n    match b {\n        b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' | b'_' => true,\n        _ => false,\n    }\n}","Real(LocalPath(\"src/expand.rs\"))"],"find_byte::find_byte":["/// Searches for the given needle in the given haystack.\n///\n/// If the perf-literal feature is enabled, then this uses the super optimized\n/// memchr crate. Otherwise, it uses the naive byte-at-a-time implementation.\npub fn find_byte(needle: u8, haystack: &[u8]) -> Option<usize>{\n    #[cfg(not(feature = \"perf-literal\"))]\n    fn imp(needle: u8, haystack: &[u8]) -> Option<usize> {\n        haystack.iter().position(|&b| b == needle)\n    }\n\n    #[cfg(feature = \"perf-literal\")]\n    fn imp(needle: u8, haystack: &[u8]) -> Option<usize> {\n        use memchr::memchr;\n        memchr(needle, haystack)\n    }\n\n    imp(needle, haystack)\n}","Real(LocalPath(\"src/find_byte.rs\"))"],"find_byte::find_byte::imp":["#[cfg(feature = \"perf-literal\")]\nfn imp(needle: u8, haystack: &[u8]) -> Option<usize>{\n        use memchr::memchr;\n        memchr(needle, haystack)\n    }","Real(LocalPath(\"src/find_byte.rs\"))"],"input::<impl std::cmp::PartialEq<input::Char> for char>::eq":["#[inline]\nfn eq(&self, other: &Char) -> bool{\n        *self as u32 == other.0\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp":["#[inline]\nfn partial_cmp(&self, other: &Char) -> Option<Ordering>{\n        (*self as u32).partial_cmp(&other.0)\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::ByteInput":["/// An input reader over bytes.\npub struct ByteInput<'t> {\n    text: &'t [u8],\n    only_utf8: bool,\n}","Real(LocalPath(\"src/input.rs\"))"],"input::ByteInput::<'t>::new":["/// Return a new byte-based input reader for the given string.\npub fn new(text: &'t [u8], only_utf8: bool) -> ByteInput<'t>{\n        ByteInput { text, only_utf8 }\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::Char":["/// An inline representation of `Option<char>`.\n///\n/// This eliminates the need to do case analysis on `Option<char>` to determine\n/// ordinality with other characters.\n///\n/// (The `Option<char>` is not related to encoding. Instead, it is used in the\n/// matching engines to represent the beginning and ending boundaries of the\n/// search text.)\npub struct Char(u32);","Real(LocalPath(\"src/input.rs\"))"],"input::Char::is_none":["/// Returns true iff the character is absent.\n#[inline]\npub fn is_none(self) -> bool{\n        self.0 == u32::MAX\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::Char::is_word_byte":["/// Returns true iff the byte is a word byte.\n///\n/// If the byte is absent, then false is returned.\npub fn is_word_byte(self) -> bool{\n        match char::from_u32(self.0) {\n            Some(c) if c <= '\\u{7F}' => regex_syntax::is_word_byte(c as u8),\n            None | Some(_) => false,\n        }\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::Char::is_word_char":["/// Returns true iff the character is a word character.\n///\n/// If the character is absent, then false is returned.\npub fn is_word_char(self) -> bool{\n        // is_word_character can panic if the Unicode data for \\w isn't\n        // available. However, our compiler ensures that if a Unicode word\n        // boundary is used, then the data must also be available. If it isn't,\n        // then the compiler returns an error.\n        char::from_u32(self.0).map_or(false, regex_syntax::is_word_character)\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::Char::len_utf8":["/// Returns the length of the character's UTF-8 encoding.\n///\n/// If the character is absent, then `1` is returned.\n#[inline]\npub fn len_utf8(self) -> usize{\n        char::from_u32(self.0).map_or(1, |c| c.len_utf8())\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::CharInput":["/// An input reader over characters.\npub struct CharInput<'t>(&'t [u8]);","Real(LocalPath(\"src/input.rs\"))"],"input::CharInput::<'t>::new":["/// Return a new character input reader for the given string.\npub fn new(s: &'t [u8]) -> CharInput<'t>{\n        CharInput(s)\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::Input":["/// An abstraction over input used in the matching engines.\npub trait Input: fmt::Debug {\n    /// Return an encoding of the position at byte offset `i`.\n    fn at(&self, i: usize) -> InputAt;\n\n    /// Return the Unicode character occurring next to `at`.\n    ///\n    /// If no such character could be decoded, then `Char` is absent.\n    fn next_char(&self, at: InputAt) -> Char;\n\n    /// Return the Unicode character occurring previous to `at`.\n    ///\n    /// If no such character could be decoded, then `Char` is absent.\n    fn previous_char(&self, at: InputAt) -> Char;\n\n    /// Return true if the given empty width instruction matches at the\n    /// input position given.\n    fn is_empty_match(&self, at: InputAt, empty: &InstEmptyLook) -> bool;\n\n    /// Scan the input for a matching prefix.\n    fn prefix_at(\n        &self,\n        prefixes: &LiteralSearcher,\n        at: InputAt,\n    ) -> Option<InputAt>;\n\n    /// The number of bytes in the input.\n    fn len(&self) -> usize;\n\n    /// Whether the input is empty.\n    fn is_empty(&self) -> bool {\n        self.len() == 0\n    }\n\n    /// Return the given input as a sequence of bytes.\n    fn as_bytes(&self) -> &[u8];\n}","Real(LocalPath(\"src/input.rs\"))"],"input::Input::is_empty":["/// Whether the input is empty.\nfn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt":["/// Represents a location in the input.\npub struct InputAt {\n    pos: usize,\n    c: Char,\n    byte: Option<u8>,\n    len: usize,\n}","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt::byte":["/// Returns the byte at this position.\npub fn byte(&self) -> Option<u8>{\n        self.byte\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt::char":["/// Returns the character at this position.\n///\n/// If this position is just before or after the input, then an absent\n/// character is returned.\npub fn char(&self) -> Char{\n        self.c\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt::is_empty":["/// Returns whether the UTF-8 width of the character at this position\n/// is zero.\npub fn is_empty(&self) -> bool{\n        self.len == 0\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt::is_end":["/// Returns true iff this position is past the end of the input.\npub fn is_end(&self) -> bool{\n        self.c.is_none() && self.byte.is_none()\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt::is_start":["/// Returns true iff this position is at the beginning of the input.\npub fn is_start(&self) -> bool{\n        self.pos == 0\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt::len":["/// Returns the UTF-8 width of the character at this position.\npub fn len(&self) -> usize{\n        self.len\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt::next_pos":["/// Returns the byte offset of the next position in the input.\npub fn next_pos(&self) -> usize{\n        self.pos + self.len\n    }","Real(LocalPath(\"src/input.rs\"))"],"input::InputAt::pos":["/// Returns the byte offset of this position.\npub fn pos(&self) -> usize{\n        self.pos\n    }","Real(LocalPath(\"src/input.rs\"))"],"literal::imp::LiteralIter":["pub enum LiteralIter<'a> {\n    Empty,\n    Bytes(&'a [u8]),\n    Single(&'a [u8]),\n    AC(&'a [Literal]),\n    Packed(&'a [Literal]),\n}","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher":["/// A prefix extracted from a compiled regular expression.\n///\n/// A regex prefix is a set of literal strings that *must* be matched at the\n/// beginning of a regex in order for the entire regex to match. Similarly\n/// for a regex suffix.\npub struct LiteralSearcher {\n    complete: bool,\n    lcp: Memmem,\n    lcs: Memmem,\n    matcher: Matcher,\n}","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::approximate_size":["/// Return the approximate heap usage of literals in bytes.\npub fn approximate_size(&self) -> usize{\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => 0,\n            Bytes(ref sset) => sset.approximate_size(),\n            Memmem(ref single) => single.approximate_size(),\n            AC { ref ac, .. } => ac.memory_usage(),\n            Packed { ref s, .. } => s.memory_usage(),\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::complete":["/// Returns true if all matches comprise the entire regular expression.\n///\n/// This does not necessarily mean that a literal match implies a match\n/// of the regular expression. For example, the regular expression `^a`\n/// is comprised of a single complete literal `a`, but the regular\n/// expression demands that it only match at the beginning of a string.\npub fn complete(&self) -> bool{\n        self.complete && !self.is_empty()\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::empty":["/// Returns a matcher that never matches and never advances the input.\npub fn empty() -> Self{\n        Self::new(Seq::infinite(), Matcher::Empty)\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::find":["/// Find the position of a literal in `haystack` if it exists.\ninline(always)\npub fn find(&self, haystack: &[u8]) -> Option<(usize, usize)>{\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => Some((0, 0)),\n            Bytes(ref sset) => sset.find(haystack).map(|i| (i, i + 1)),\n            Memmem(ref s) => s.find(haystack).map(|i| (i, i + s.len())),\n            AC { ref ac, .. } => {\n                ac.find(haystack).map(|m| (m.start(), m.end()))\n            }\n            Packed { ref s, .. } => {\n                s.find(haystack).map(|m| (m.start(), m.end()))\n            }\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::find_end":["/// Like find, except matches must end at index `haystack.len()`.\npub fn find_end(&self, haystack: &[u8]) -> Option<(usize, usize)>{\n        for lit in self.iter() {\n            if lit.len() > haystack.len() {\n                continue;\n            }\n            if lit == &haystack[haystack.len() - lit.len()..] {\n                return Some((haystack.len() - lit.len(), haystack.len()));\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::find_start":["/// Like find, except matches must start at index `0`.\npub fn find_start(&self, haystack: &[u8]) -> Option<(usize, usize)>{\n        for lit in self.iter() {\n            if lit.len() > haystack.len() {\n                continue;\n            }\n            if lit == &haystack[0..lit.len()] {\n                return Some((0, lit.len()));\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::is_empty":["/// Returns true iff this prefix is empty.\npub fn is_empty(&self) -> bool{\n        self.len() == 0\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::iter":["/// Returns an iterator over all literals to be matched.\npub fn iter(&self) -> LiteralIter<'_>{\n        match self.matcher {\n            Matcher::Empty => LiteralIter::Empty,\n            Matcher::Bytes(ref sset) => LiteralIter::Bytes(&sset.dense),\n            Matcher::Memmem(ref s) => LiteralIter::Single(&s.finder.needle()),\n            Matcher::AC { ref lits, .. } => LiteralIter::AC(lits),\n            Matcher::Packed { ref lits, .. } => LiteralIter::Packed(lits),\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::lcp":["/// Returns a matcher for the longest common prefix of this matcher.\npub fn lcp(&self) -> &Memmem{\n        &self.lcp\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::lcs":["/// Returns a matcher for the longest common suffix of this matcher.\npub fn lcs(&self) -> &Memmem{\n        &self.lcs\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::len":["/// Returns the number of prefixes in this machine.\npub fn len(&self) -> usize{\n        use self::Matcher::*;\n        match self.matcher {\n            Empty => 0,\n            Bytes(ref sset) => sset.dense.len(),\n            Memmem(_) => 1,\n            AC { ref ac, .. } => ac.patterns_len(),\n            Packed { ref lits, .. } => lits.len(),\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::new":["fn new(lits: Seq, matcher: Matcher) -> Self{\n        LiteralSearcher {\n            complete: lits.is_exact(),\n            lcp: Memmem::new(lits.longest_common_prefix().unwrap_or(b\"\")),\n            lcs: Memmem::new(lits.longest_common_suffix().unwrap_or(b\"\")),\n            matcher,\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::prefixes":["/// Returns a matcher for literal prefixes from the given set.\npub fn prefixes(lits: Seq) -> Self{\n        let matcher = Matcher::prefixes(&lits);\n        Self::new(lits, matcher)\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::LiteralSearcher::suffixes":["/// Returns a matcher for literal suffixes from the given set.\npub fn suffixes(lits: Seq) -> Self{\n        let matcher = Matcher::suffixes(&lits);\n        Self::new(lits, matcher)\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Matcher":["enum Matcher {\n    /// No literals. (Never advances through the input.)\n    Empty,\n    /// A set of four or more single byte literals.\n    Bytes(SingleByteSet),\n    /// A single substring, using vector accelerated routines when available.\n    Memmem(Memmem),\n    /// An Aho-Corasick automaton.\n    AC { ac: AhoCorasick, lits: Vec<Literal> },\n    /// A packed multiple substring searcher, using SIMD.\n    ///\n    /// Note that Aho-Corasick will actually use this packed searcher\n    /// internally automatically, however, there is some overhead associated\n    /// with going through the Aho-Corasick machinery. So using the packed\n    /// searcher directly results in some gains.\n    Packed { s: packed::Searcher, lits: Vec<Literal> },\n}","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Matcher::new":["fn new(lits: &Seq, sset: SingleByteSet) -> Self{\n        if lits.is_empty() || lits.min_literal_len() == Some(0) {\n            return Matcher::Empty;\n        }\n        let lits = match lits.literals() {\n            None => return Matcher::Empty,\n            Some(members) => members,\n        };\n        if sset.dense.len() >= 26 {\n            // Avoid trying to match a large number of single bytes.\n            // This is *very* sensitive to a frequency analysis comparison\n            // between the bytes in sset and the composition of the haystack.\n            // No matter the size of sset, if its members all are rare in the\n            // haystack, then it'd be worth using it. How to tune this... IDK.\n            // ---AG\n            return Matcher::Empty;\n        }\n        if sset.complete {\n            return Matcher::Bytes(sset);\n        }\n        if lits.len() == 1 {\n            return Matcher::Memmem(Memmem::new(lits[0].as_bytes()));\n        }\n\n        let pats: Vec<&[u8]> = lits.iter().map(|lit| lit.as_bytes()).collect();\n        let is_aho_corasick_fast = sset.dense.len() <= 1 && sset.all_ascii;\n        if lits.len() <= 100 && !is_aho_corasick_fast {\n            let mut builder = packed::Config::new()\n                .match_kind(packed::MatchKind::LeftmostFirst)\n                .builder();\n            if let Some(s) = builder.extend(&pats).build() {\n                return Matcher::Packed { s, lits: lits.to_owned() };\n            }\n        }\n        let ac = AhoCorasick::builder()\n            .match_kind(aho_corasick::MatchKind::LeftmostFirst)\n            .kind(Some(aho_corasick::AhoCorasickKind::DFA))\n            .build(&pats)\n            .unwrap();\n        Matcher::AC { ac, lits: lits.to_owned() }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Matcher::prefixes":["fn prefixes(lits: &Seq) -> Self{\n        let sset = SingleByteSet::prefixes(lits);\n        Matcher::new(lits, sset)\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Matcher::suffixes":["fn suffixes(lits: &Seq) -> Self{\n        let sset = SingleByteSet::suffixes(lits);\n        Matcher::new(lits, sset)\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Memmem":["/// A simple wrapper around the memchr crate's memmem implementation.\n///\n/// The API this exposes mirrors the API of previous substring searchers that\n/// this supplanted.\npub struct Memmem {\n    finder: memmem::Finder<'static>,\n    char_len: usize,\n}","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Memmem::approximate_size":["fn approximate_size(&self) -> usize{\n        self.finder.needle().len() * mem::size_of::<u8>()\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Memmem::char_len":["pub fn char_len(&self) -> usize{\n        self.char_len\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Memmem::find":["inline(always)\npub fn find(&self, haystack: &[u8]) -> Option<usize>{\n        self.finder.find(haystack)\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Memmem::is_suffix":["inline(always)\npub fn is_suffix(&self, text: &[u8]) -> bool{\n        if text.len() < self.len() {\n            return false;\n        }\n        &text[text.len() - self.len()..] == self.finder.needle()\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Memmem::len":["pub fn len(&self) -> usize{\n        self.finder.needle().len()\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::Memmem::new":["fn new(pat: &[u8]) -> Memmem{\n        Memmem {\n            finder: memmem::Finder::new(pat).into_owned(),\n            char_len: char_len_lossy(pat),\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::SingleByteSet":["struct SingleByteSet {\n    sparse: Vec<bool>,\n    dense: Vec<u8>,\n    complete: bool,\n    all_ascii: bool,\n}","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::SingleByteSet::_find":["/// Generic find that works on any sized set.\nfn _find(&self, haystack: &[u8]) -> Option<usize>{\n        for (i, &b) in haystack.iter().enumerate() {\n            if self.sparse[b as usize] {\n                return Some(i);\n            }\n        }\n        None\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::SingleByteSet::approximate_size":["fn approximate_size(&self) -> usize{\n        (self.dense.len() * mem::size_of::<u8>())\n            + (self.sparse.len() * mem::size_of::<bool>())\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::SingleByteSet::find":["/// Faster find that special cases certain sizes to use memchr.\ninline(always)\nfn find(&self, text: &[u8]) -> Option<usize>{\n        match self.dense.len() {\n            0 => None,\n            1 => memchr(self.dense[0], text),\n            2 => memchr2(self.dense[0], self.dense[1], text),\n            3 => memchr3(self.dense[0], self.dense[1], self.dense[2], text),\n            _ => self._find(text),\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::SingleByteSet::new":["fn new() -> SingleByteSet{\n        SingleByteSet {\n            sparse: vec![false; 256],\n            dense: vec![],\n            complete: true,\n            all_ascii: true,\n        }\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::SingleByteSet::prefixes":["fn prefixes(lits: &Seq) -> SingleByteSet{\n        let mut sset = SingleByteSet::new();\n        let lits = match lits.literals() {\n            None => return sset,\n            Some(lits) => lits,\n        };\n        for lit in lits.iter() {\n            sset.complete = sset.complete && lit.len() == 1;\n            if let Some(&b) = lit.as_bytes().get(0) {\n                if !sset.sparse[b as usize] {\n                    if b > 0x7F {\n                        sset.all_ascii = false;\n                    }\n                    sset.dense.push(b);\n                    sset.sparse[b as usize] = true;\n                }\n            }\n        }\n        sset\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::SingleByteSet::suffixes":["fn suffixes(lits: &Seq) -> SingleByteSet{\n        let mut sset = SingleByteSet::new();\n        let lits = match lits.literals() {\n            None => return sset,\n            Some(lits) => lits,\n        };\n        for lit in lits.iter() {\n            sset.complete = sset.complete && lit.len() == 1;\n            if let Some(&b) = lit.as_bytes().last() {\n                if !sset.sparse[b as usize] {\n                    if b > 0x7F {\n                        sset.all_ascii = false;\n                    }\n                    sset.dense.push(b);\n                    sset.sparse[b as usize] = true;\n                }\n            }\n        }\n        sset\n    }","Real(LocalPath(\"src/literal/imp.rs\"))"],"literal::imp::char_len_lossy":["fn char_len_lossy(bytes: &[u8]) -> usize{\n    String::from_utf8_lossy(bytes).chars().count()\n}","Real(LocalPath(\"src/literal/imp.rs\"))"],"pikevm::Cache":["/// A cached allocation that can be reused on each execution.\npub struct Cache {\n    /// A pair of ordered sets for tracking NFA states.\n    clist: Threads,\n    nlist: Threads,\n    /// An explicit stack used for following epsilon transitions.\n    stack: Vec<FollowEpsilon>,\n}","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Cache::new":["/// Create a new allocation used by the NFA machine to record execution\n/// and captures.\npub fn new(_prog: &Program) -> Self{\n        Cache { clist: Threads::new(), nlist: Threads::new(), stack: vec![] }\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::FollowEpsilon":["/// A representation of an explicit stack frame when following epsilon\n/// transitions. This is used to avoid recursion.\nenum FollowEpsilon {\n    /// Follow transitions at the given instruction pointer.\n    IP(InstPtr),\n    /// Restore the capture slot with the given position in the input.\n    Capture { slot: usize, pos: Slot },\n}","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Fsm":["/// An NFA simulation matching engine.\npub struct Fsm<'r, I> {\n    /// The sequence of opcodes (among other things) that is actually executed.\n    ///\n    /// The program may be byte oriented or Unicode codepoint oriented.\n    prog: &'r Program,\n    /// An explicit stack used for following epsilon transitions. (This is\n    /// borrowed from the cache.)\n    stack: &'r mut Vec<FollowEpsilon>,\n    /// The input to search.\n    input: I,\n}","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Fsm::<'r, I>::add":["/// Follows epsilon transitions and adds them for processing to nlist,\n/// starting at and including ip.\nfn add(\n        &mut self,\n        nlist: &mut Threads,\n        thread_caps: &mut [Option<usize>],\n        ip: usize,\n        at: InputAt,\n    ){\n        self.stack.push(FollowEpsilon::IP(ip));\n        while let Some(frame) = self.stack.pop() {\n            match frame {\n                FollowEpsilon::IP(ip) => {\n                    self.add_step(nlist, thread_caps, ip, at);\n                }\n                FollowEpsilon::Capture { slot, pos } => {\n                    thread_caps[slot] = pos;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Fsm::<'r, I>::add_step":["/// A helper function for add that avoids excessive pushing to the stack.\nfn add_step(\n        &mut self,\n        nlist: &mut Threads,\n        thread_caps: &mut [Option<usize>],\n        mut ip: usize,\n        at: InputAt,\n    ){\n        // Instead of pushing and popping to the stack, we mutate ip as we\n        // traverse the set of states. We only push to the stack when we\n        // absolutely need recursion (restoring captures or following a\n        // branch).\n        use crate::prog::Inst::*;\n        loop {\n            // Don't visit states we've already added.\n            if nlist.set.contains(ip) {\n                return;\n            }\n            nlist.set.insert(ip);\n            match self.prog[ip] {\n                EmptyLook(ref inst) => {\n                    if self.input.is_empty_match(at, inst) {\n                        ip = inst.goto;\n                    }\n                }\n                Save(ref inst) => {\n                    if inst.slot < thread_caps.len() {\n                        self.stack.push(FollowEpsilon::Capture {\n                            slot: inst.slot,\n                            pos: thread_caps[inst.slot],\n                        });\n                        thread_caps[inst.slot] = Some(at.pos());\n                    }\n                    ip = inst.goto;\n                }\n                Split(ref inst) => {\n                    self.stack.push(FollowEpsilon::IP(inst.goto2));\n                    ip = inst.goto1;\n                }\n                Match(_) | Char(_) | Ranges(_) | Bytes(_) => {\n                    let t = &mut nlist.caps(ip);\n                    for (slot, val) in t.iter_mut().zip(thread_caps.iter()) {\n                        *slot = *val;\n                    }\n                    return;\n                }\n            }\n        }\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Fsm::<'r, I>::exec":["/// Execute the NFA matching engine.\n///\n/// If there's a match, `exec` returns `true` and populates the given\n/// captures accordingly.\npub fn exec(\n        prog: &'r Program,\n        cache: &ProgramCache,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        input: I,\n        start: usize,\n        end: usize,\n    ) -> bool{\n        let mut cache = cache.borrow_mut();\n        let cache = &mut cache.pikevm;\n        cache.clist.resize(prog.len(), prog.captures.len());\n        cache.nlist.resize(prog.len(), prog.captures.len());\n        let at = input.at(start);\n        Fsm { prog, stack: &mut cache.stack, input }.exec_(\n            &mut cache.clist,\n            &mut cache.nlist,\n            matches,\n            slots,\n            quit_after_match,\n            at,\n            end,\n        )\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Fsm::<'r, I>::exec_":["fn exec_(\n        &mut self,\n        mut clist: &mut Threads,\n        mut nlist: &mut Threads,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        quit_after_match: bool,\n        mut at: InputAt,\n        end: usize,\n    ) -> bool{\n        let mut matched = false;\n        let mut all_matched = false;\n        clist.set.clear();\n        nlist.set.clear();\n        'LOOP: loop {\n            if clist.set.is_empty() {\n                // Three ways to bail out when our current set of threads is\n                // empty.\n                //\n                // 1. We have a match---so we're done exploring any possible\n                //    alternatives. Time to quit. (We can't do this if we're\n                //    looking for matches for multiple regexes, unless we know\n                //    they all matched.)\n                //\n                // 2. If the expression starts with a '^' we can terminate as\n                //    soon as the last thread dies.\n                if (matched && matches.len() <= 1)\n                    || all_matched\n                    || (!at.is_start() && self.prog.is_anchored_start)\n                {\n                    break;\n                }\n\n                // 3. If there's a literal prefix for the program, try to\n                //    jump ahead quickly. If it can't be found, then we can\n                //    bail out early.\n                if !self.prog.prefixes.is_empty() {\n                    at = match self.input.prefix_at(&self.prog.prefixes, at) {\n                        None => break,\n                        Some(at) => at,\n                    };\n                }\n            }\n\n            // This simulates a preceding '.*?' for every regex by adding\n            // a state starting at the current position in the input for the\n            // beginning of the program only if we don't already have a match.\n            if clist.set.is_empty()\n                || (!self.prog.is_anchored_start && !all_matched)\n            {\n                self.add(&mut clist, slots, 0, at);\n            }\n            // The previous call to \"add\" actually inspects the position just\n            // before the current character. For stepping through the machine,\n            // we can to look at the current character, so we advance the\n            // input.\n            let at_next = self.input.at(at.next_pos());\n            for i in 0..clist.set.len() {\n                let ip = clist.set[i];\n                if self.step(\n                    &mut nlist,\n                    matches,\n                    slots,\n                    clist.caps(ip),\n                    ip,\n                    at,\n                    at_next,\n                ) {\n                    matched = true;\n                    all_matched = all_matched || matches.iter().all(|&b| b);\n                    if quit_after_match {\n                        // If we only care if a match occurs (not its\n                        // position), then we can quit right now.\n                        break 'LOOP;\n                    }\n                    if self.prog.matches.len() == 1 {\n                        // We don't need to check the rest of the threads\n                        // in this set because we've matched something\n                        // (\"leftmost-first\"). However, we still need to check\n                        // threads in the next set to support things like\n                        // greedy matching.\n                        //\n                        // This is only true on normal regexes. For regex sets,\n                        // we need to mush on to observe other matches.\n                        break;\n                    }\n                }\n            }\n            if at.pos() >= end {\n                break;\n            }\n            at = at_next;\n            mem::swap(clist, nlist);\n            nlist.set.clear();\n        }\n        matched\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Fsm::<'r, I>::step":["/// Step through the input, one token (byte or codepoint) at a time.\n///\n/// nlist is the set of states that will be processed on the next token\n/// in the input.\n///\n/// caps is the set of captures passed by the caller of the NFA. They are\n/// written to only when a match state is visited.\n///\n/// thread_caps is the set of captures set for the current NFA state, ip.\n///\n/// at and at_next are the current and next positions in the input. at or\n/// at_next may be EOF.\nfn step(\n        &mut self,\n        nlist: &mut Threads,\n        matches: &mut [bool],\n        slots: &mut [Slot],\n        thread_caps: &mut [Option<usize>],\n        ip: usize,\n        at: InputAt,\n        at_next: InputAt,\n    ) -> bool{\n        use crate::prog::Inst::*;\n        match self.prog[ip] {\n            Match(match_slot) => {\n                if match_slot < matches.len() {\n                    matches[match_slot] = true;\n                }\n                for (slot, val) in slots.iter_mut().zip(thread_caps.iter()) {\n                    *slot = *val;\n                }\n                true\n            }\n            Char(ref inst) => {\n                if inst.c == at.char() {\n                    self.add(nlist, thread_caps, inst.goto, at_next);\n                }\n                false\n            }\n            Ranges(ref inst) => {\n                if inst.matches(at.char()) {\n                    self.add(nlist, thread_caps, inst.goto, at_next);\n                }\n                false\n            }\n            Bytes(ref inst) => {\n                if let Some(b) = at.byte() {\n                    if inst.matches(b) {\n                        self.add(nlist, thread_caps, inst.goto, at_next);\n                    }\n                }\n                false\n            }\n            EmptyLook(_) | Save(_) | Split(_) => false,\n        }\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Threads":["/// An ordered set of NFA states and their captures.\nstruct Threads {\n    /// An ordered set of opcodes (each opcode is an NFA state).\n    set: SparseSet,\n    /// Captures for every NFA state.\n    ///\n    /// It is stored in row-major order, where the columns are the capture\n    /// slots and the rows are the states.\n    caps: Vec<Slot>,\n    /// The number of capture slots stored per thread. (Every capture has\n    /// two slots.)\n    slots_per_thread: usize,\n}","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Threads::caps":["fn caps(&mut self, pc: usize) -> &mut [Option<usize>]{\n        let i = pc * self.slots_per_thread;\n        &mut self.caps[i..i + self.slots_per_thread]\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Threads::new":["fn new() -> Self{\n        Threads { set: SparseSet::new(0), caps: vec![], slots_per_thread: 0 }\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pikevm::Threads::resize":["fn resize(&mut self, num_insts: usize, ncaps: usize){\n        if num_insts == self.set.capacity() {\n            return;\n        }\n        self.slots_per_thread = ncaps * 2;\n        self.set = SparseSet::new(num_insts);\n        self.caps = vec![None; self.slots_per_thread * num_insts];\n    }","Real(LocalPath(\"src/pikevm.rs\"))"],"pool::Pool":["/// A simple thread safe pool for reusing values.\n///\n/// Getting a value out comes with a guard. When that guard is dropped, the\n/// value is automatically put back in the pool.\n///\n/// A Pool<T> impls Sync when T is Send (even if it's not Sync). This means\n/// that T can use interior mutability. This is possible because a pool is\n/// guaranteed to provide a value to exactly one thread at any time.\n///\n/// Currently, a pool never contracts in size. Its size is proportional to the\n/// number of simultaneous uses.\npub struct Pool<T> {\n    /// A stack of T values to hand out. These are used when a Pool is\n    /// accessed by a thread that didn't create it.\n    stack: Mutex<Vec<Box<T>>>,\n    /// A function to create more T values when stack is empty and a caller\n    /// has requested a T.\n    create: CreateFn<T>,\n    /// The ID of the thread that owns this pool. The owner is the thread\n    /// that makes the first call to 'get'. When the owner calls 'get', it\n    /// gets 'owner_val' directly instead of returning a T from 'stack'.\n    /// See comments elsewhere for details, but this is intended to be an\n    /// optimization for the common case that makes getting a T faster.\n    ///\n    /// It is initialized to a value of zero (an impossible thread ID) as a\n    /// sentinel to indicate that it is unowned.\n    owner: AtomicUsize,\n    /// A value to return when the caller is in the same thread that created\n    /// the Pool.\n    owner_val: T,\n}","Real(LocalPath(\"src/pool.rs\"))"],"pool::Pool::<T>::get":["/// Get a value from the pool. The caller is guaranteed to have exclusive\n/// access to the given value.\n///\n/// Note that there is no guarantee provided about which value in the\n/// pool is returned. That is, calling get, dropping the guard (causing\n/// the value to go back into the pool) and then calling get again is NOT\n/// guaranteed to return the same value received in the first get call.\ninline(always)\npub fn get(&self) -> PoolGuard<'_, T>{\n        // Our fast path checks if the caller is the thread that \"owns\" this\n        // pool. Or stated differently, whether it is the first thread that\n        // tried to extract a value from the pool. If it is, then we can return\n        // a T to the caller without going through a mutex.\n        //\n        // SAFETY: We must guarantee that only one thread gets access to this\n        // value. Since a thread is uniquely identified by the THREAD_ID thread\n        // local, it follows that is the caller's thread ID is equal to the\n        // owner, then only one thread may receive this value.\n        let caller = THREAD_ID.with(|id| *id);\n        let owner = self.owner.load(Ordering::Relaxed);\n        if caller == owner {\n            return self.guard_owned();\n        }\n        self.get_slow(caller, owner)\n    }","Real(LocalPath(\"src/pool.rs\"))"],"pool::Pool::<T>::get_slow":["/// This is the \"slow\" version that goes through a mutex to pop an\n/// allocated value off a stack to return to the caller. (Or, if the stack\n/// is empty, a new value is created.)\n///\n/// If the pool has no owner, then this will set the owner.\n#[cold]\nfn get_slow(&self, caller: usize, owner: usize) -> PoolGuard<'_, T>{\n        use std::sync::atomic::Ordering::Relaxed;\n\n        if owner == 0 {\n            // The sentinel 0 value means this pool is not yet owned. We\n            // try to atomically set the owner. If we do, then this thread\n            // becomes the owner and we can return a guard that represents\n            // the special T for the owner.\n            let res = self.owner.compare_exchange(0, caller, Relaxed, Relaxed);\n            if res.is_ok() {\n                return self.guard_owned();\n            }\n        }\n        let mut stack = self.stack.lock().unwrap();\n        let value = match stack.pop() {\n            None => Box::new((self.create)()),\n            Some(value) => value,\n        };\n        self.guard_stack(value)\n    }","Real(LocalPath(\"src/pool.rs\"))"],"pool::Pool::<T>::guard_owned":["/// Create a guard that represents the special owned T.\nfn guard_owned(&self) -> PoolGuard<'_, T>{\n        PoolGuard { pool: self, value: None }\n    }","Real(LocalPath(\"src/pool.rs\"))"],"pool::Pool::<T>::guard_stack":["/// Create a guard that contains a value from the pool's stack.\nfn guard_stack(&self, value: Box<T>) -> PoolGuard<'_, T>{\n        PoolGuard { pool: self, value: Some(value) }\n    }","Real(LocalPath(\"src/pool.rs\"))"],"pool::Pool::<T>::new":["/// Create a new pool. The given closure is used to create values in the\n/// pool when necessary.\npub fn new(create: CreateFn<T>) -> Pool<T>{\n        let owner = AtomicUsize::new(0);\n        let owner_val = create();\n        Pool { stack: Mutex::new(vec![]), create, owner, owner_val }\n    }","Real(LocalPath(\"src/pool.rs\"))"],"pool::Pool::<T>::put":["/// Puts a value back into the pool. Callers don't need to call this. Once\n/// the guard that's returned by 'get' is dropped, it is put back into the\n/// pool automatically.\nfn put(&self, value: Box<T>){\n        let mut stack = self.stack.lock().unwrap();\n        stack.push(value);\n    }","Real(LocalPath(\"src/pool.rs\"))"],"pool::PoolGuard":["/// A guard that is returned when a caller requests a value from the pool.\n///\n/// The purpose of the guard is to use RAII to automatically put the value back\n/// in the pool once it's dropped.\npub struct PoolGuard<'a, T: Send> {\n    /// The pool that this guard is attached to.\n    pool: &'a Pool<T>,\n    /// This is None when the guard represents the special \"owned\" value. In\n    /// which case, the value is retrieved from 'pool.owner_val'.\n    value: Option<Box<T>>,\n}","Real(LocalPath(\"src/pool.rs\"))"],"pool::PoolGuard::<'a, T>::value":["/// Return the underlying value.\npub fn value(&self) -> &T{\n        match self.value {\n            None => &self.pool.owner_val,\n            Some(ref v) => &**v,\n        }\n    }","Real(LocalPath(\"src/pool.rs\"))"],"pool::THREAD_ID::__init":["#[inline]\nfn __init() -> $t{\n            $init\n        }","Real(Remapped { local_path: Some(\"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/mod.rs\"), virtual_name: \"/rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/sys/thread_local/native/mod.rs\" })"],"prog::EmptyLook":["/// The set of zero-width match instructions.\npub enum EmptyLook {\n    /// Start of line or input.\n    StartLine,\n    /// End of line or input.\n    EndLine,\n    /// Start of input.\n    StartText,\n    /// End of input.\n    EndText,\n    /// Word character on one side and non-word character on other.\n    WordBoundary,\n    /// Word character on both sides or non-word character on both sides.\n    NotWordBoundary,\n    /// ASCII word boundary.\n    WordBoundaryAscii,\n    /// Not ASCII word boundary.\n    NotWordBoundaryAscii,\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::Inst":["/// Inst is an instruction code in a Regex program.\n///\n/// Regrettably, a regex program either contains Unicode codepoint\n/// instructions (Char and Ranges) or it contains byte instructions (Bytes).\n/// A regex program can never contain both.\n///\n/// It would be worth investigating splitting this into two distinct types and\n/// then figuring out how to make the matching engines polymorphic over those\n/// types without sacrificing performance.\n///\n/// Other than the benefit of moving invariants into the type system, another\n/// benefit is the decreased size. If we remove the `Char` and `Ranges`\n/// instructions from the `Inst` enum, then its size shrinks from 32 bytes to\n/// 24 bytes. (This is because of the removal of a `Box<[]>` in the `Ranges`\n/// variant.) Given that byte based machines are typically much bigger than\n/// their Unicode analogues (because they can decode UTF-8 directly), this ends\n/// up being a pretty significant savings.\npub enum Inst {\n    /// Match indicates that the program has reached a match state.\n    ///\n    /// The number in the match corresponds to the Nth logical regular\n    /// expression in this program. This index is always 0 for normal regex\n    /// programs. Values greater than 0 appear when compiling regex sets, and\n    /// each match instruction gets its own unique value. The value corresponds\n    /// to the Nth regex in the set.\n    Match(usize),\n    /// Save causes the program to save the current location of the input in\n    /// the slot indicated by InstSave.\n    Save(InstSave),\n    /// Split causes the program to diverge to one of two paths in the\n    /// program, preferring goto1 in InstSplit.\n    Split(InstSplit),\n    /// EmptyLook represents a zero-width assertion in a regex program. A\n    /// zero-width assertion does not consume any of the input text.\n    EmptyLook(InstEmptyLook),\n    /// Char requires the regex program to match the character in InstChar at\n    /// the current position in the input.\n    Char(InstChar),\n    /// Ranges requires the regex program to match the character at the current\n    /// position in the input with one of the ranges specified in InstRanges.\n    Ranges(InstRanges),\n    /// Bytes is like Ranges, except it expresses a single byte range. It is\n    /// used in conjunction with Split instructions to implement multi-byte\n    /// character classes.\n    Bytes(InstBytes),\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::Inst::is_match":["/// Returns true if and only if this is a match instruction.\npub fn is_match(&self) -> bool{\n        match *self {\n            Inst::Match(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstBytes":["/// Representation of the Bytes instruction.\npub struct InstBytes {\n    /// The next location to execute in the program if this instruction\n    /// succeeds.\n    pub goto: InstPtr,\n    /// The start (inclusive) of this byte range.\n    pub start: u8,\n    /// The end (inclusive) of this byte range.\n    pub end: u8,\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstBytes::matches":["/// Returns true if and only if the given byte is in this range.\npub fn matches(&self, byte: u8) -> bool{\n        self.start <= byte && byte <= self.end\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstChar":["/// Representation of the Char instruction.\npub struct InstChar {\n    /// The next location to execute in the program if this instruction\n    /// succeeds.\n    pub goto: InstPtr,\n    /// The character to test.\n    pub c: char,\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstEmptyLook":["/// Representation of the `EmptyLook` instruction.\npub struct InstEmptyLook {\n    /// The next location to execute in the program if this instruction\n    /// succeeds.\n    pub goto: InstPtr,\n    /// The type of zero-width assertion to check.\n    pub look: EmptyLook,\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstRanges":["/// Representation of the Ranges instruction.\npub struct InstRanges {\n    /// The next location to execute in the program if this instruction\n    /// succeeds.\n    pub goto: InstPtr,\n    /// The set of Unicode scalar value ranges to test.\n    pub ranges: Box<[(char, char)]>,\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstRanges::matches":["/// Tests whether the given input character matches this instruction.\npub fn matches(&self, c: Char) -> bool{\n        // This speeds up the `match_class_unicode` benchmark by checking\n        // some common cases quickly without binary search. e.g., Matching\n        // a Unicode class on predominantly ASCII text.\n        for r in self.ranges.iter().take(4) {\n            if c < r.0 {\n                return false;\n            }\n            if c <= r.1 {\n                return true;\n            }\n        }\n        self.ranges\n            .binary_search_by(|r| {\n                if r.1 < c {\n                    Ordering::Less\n                } else if r.0 > c {\n                    Ordering::Greater\n                } else {\n                    Ordering::Equal\n                }\n            })\n            .is_ok()\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstRanges::num_chars":["/// Return the number of distinct characters represented by all of the\n/// ranges.\npub fn num_chars(&self) -> usize{\n        self.ranges\n            .iter()\n            .map(|&(s, e)| 1 + (e as u32) - (s as u32))\n            .sum::<u32>() as usize\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstSave":["/// Representation of the Save instruction.\npub struct InstSave {\n    /// The next location to execute in the program.\n    pub goto: InstPtr,\n    /// The capture slot (there are two slots for every capture in a regex,\n    /// including the zeroth capture for the entire match).\n    pub slot: usize,\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::InstSplit":["/// Representation of the Split instruction.\npub struct InstSplit {\n    /// The first instruction to try. A match resulting from following goto1\n    /// has precedence over a match resulting from following goto2.\n    pub goto1: InstPtr,\n    /// The second instruction to try. A match resulting from following goto1\n    /// has precedence over a match resulting from following goto2.\n    pub goto2: InstPtr,\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::Program":["/// Program is a sequence of instructions and various facts about thos\n/// instructions.\npub struct Program {\n    /// A sequence of instructions that represents an NFA.\n    pub insts: Vec<Inst>,\n    /// Pointers to each Match instruction in the sequence.\n    ///\n    /// This is always length 1 unless this program represents a regex set.\n    pub matches: Vec<InstPtr>,\n    /// The ordered sequence of all capture groups extracted from the AST.\n    /// Unnamed groups are `None`.\n    pub captures: Vec<Option<String>>,\n    /// Pointers to all named capture groups into `captures`.\n    pub capture_name_idx: Arc<HashMap<String, usize>>,\n    /// If the number of capture groups is the same for all possible matches,\n    /// then this is that number.\n    pub static_captures_len: Option<usize>,\n    /// A pointer to the start instruction. This can vary depending on how\n    /// the program was compiled. For example, programs for use with the DFA\n    /// engine have a `.*?` inserted at the beginning of unanchored regular\n    /// expressions. The actual starting point of the program is after the\n    /// `.*?`.\n    pub start: InstPtr,\n    /// A set of equivalence classes for discriminating bytes in the compiled\n    /// program.\n    pub byte_classes: Vec<u8>,\n    /// When true, this program can only match valid UTF-8.\n    pub only_utf8: bool,\n    /// When true, this program uses byte range instructions instead of Unicode\n    /// range instructions.\n    pub is_bytes: bool,\n    /// When true, the program is compiled for DFA matching. For example, this\n    /// implies `is_bytes` and also inserts a preceding `.*?` for unanchored\n    /// regexes.\n    pub is_dfa: bool,\n    /// When true, the program matches text in reverse (for use only in the\n    /// DFA).\n    pub is_reverse: bool,\n    /// Whether the regex must match from the start of the input.\n    pub is_anchored_start: bool,\n    /// Whether the regex must match at the end of the input.\n    pub is_anchored_end: bool,\n    /// Whether this program contains a Unicode word boundary instruction.\n    pub has_unicode_word_boundary: bool,\n    /// A possibly empty machine for very quickly matching prefix literals.\n    pub prefixes: LiteralSearcher,\n    /// A limit on the size of the cache that the DFA is allowed to use while\n    /// matching.\n    ///\n    /// The cache limit specifies approximately how much space we're willing to\n    /// give to the state cache. Once the state cache exceeds the size, it is\n    /// wiped and all states must be re-computed.\n    ///\n    /// Note that this value does not impact correctness. It can be set to 0\n    /// and the DFA will run just fine. (It will only ever store exactly one\n    /// state in the cache, and will likely run very slowly, but it will work.)\n    ///\n    /// Also note that this limit is *per thread of execution*. That is,\n    /// if the same regex is used to search text across multiple threads\n    /// simultaneously, then the DFA cache is not shared. Instead, copies are\n    /// made.\n    pub dfa_size_limit: usize,\n}","Real(LocalPath(\"src/prog.rs\"))"],"prog::Program::approximate_size":["/// Return the approximate heap usage of this instruction sequence in\n/// bytes.\npub fn approximate_size(&self) -> usize{\n        // The only instruction that uses heap space is Ranges (for\n        // Unicode codepoint programs) to store non-overlapping codepoint\n        // ranges. To keep this operation constant time, we ignore them.\n        (self.len() * mem::size_of::<Inst>())\n            + (self.matches.len() * mem::size_of::<InstPtr>())\n            + (self.captures.len() * mem::size_of::<Option<String>>())\n            + (self.capture_name_idx.len()\n                * (mem::size_of::<String>() + mem::size_of::<usize>()))\n            + (self.byte_classes.len() * mem::size_of::<u8>())\n            + self.prefixes.approximate_size()\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::Program::leads_to_match":["/// Return true if and only if an execution engine at instruction `pc` will\n/// always lead to a match.\npub fn leads_to_match(&self, pc: usize) -> bool{\n        if self.matches.len() > 1 {\n            // If we have a regex set, then we have more than one ending\n            // state, so leading to one of those states is generally\n            // meaningless.\n            return false;\n        }\n        match self[self.skip(pc)] {\n            Inst::Match(_) => true,\n            _ => false,\n        }\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::Program::needs_dotstar":["/// Returns true if the current configuration demands that an implicit\n/// `.*?` be prepended to the instruction sequence.\npub fn needs_dotstar(&self) -> bool{\n        self.is_dfa && !self.is_reverse && !self.is_anchored_start\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::Program::new":["/// Creates an empty instruction sequence. Fields are given default\n/// values.\npub fn new() -> Self{\n        Program {\n            insts: vec![],\n            matches: vec![],\n            captures: vec![],\n            capture_name_idx: Arc::new(HashMap::new()),\n            static_captures_len: None,\n            start: 0,\n            byte_classes: vec![0; 256],\n            only_utf8: true,\n            is_bytes: false,\n            is_dfa: false,\n            is_reverse: false,\n            is_anchored_start: false,\n            is_anchored_end: false,\n            has_unicode_word_boundary: false,\n            prefixes: LiteralSearcher::empty(),\n            dfa_size_limit: 2 * (1 << 20),\n        }\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::Program::only_utf8":["/// Returns true if this program exclusively matches valid UTF-8 bytes.\n///\n/// That is, if an invalid UTF-8 byte is seen, then no match is possible.\npub fn only_utf8(&self) -> bool{\n        self.only_utf8\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::Program::skip":["/// If pc is an index to a no-op instruction (like Save), then return the\n/// next pc that is not a no-op instruction.\npub fn skip(&self, mut pc: usize) -> usize{\n        loop {\n            match self[pc] {\n                Inst::Save(ref i) => pc = i.goto,\n                _ => return pc,\n            }\n        }\n    }","Real(LocalPath(\"src/prog.rs\"))"],"prog::Program::uses_bytes":["/// Returns true if this program uses Byte instructions instead of\n/// Char/Range instructions.\npub fn uses_bytes(&self) -> bool{\n        self.is_bytes || self.is_dfa\n    }","Real(LocalPath(\"src/prog.rs\"))"],"re_builder::RegexOptions":["/// The set of user configurable options for compiling zero or more regexes.\n#[allow(missing_docs)]\npub struct RegexOptions {\n    pub pats: Vec<String>,\n    pub size_limit: usize,\n    pub dfa_size_limit: usize,\n    pub nest_limit: u32,\n    pub case_insensitive: bool,\n    pub multi_line: bool,\n    pub dot_matches_new_line: bool,\n    pub swap_greed: bool,\n    pub ignore_whitespace: bool,\n    pub unicode: bool,\n    pub octal: bool,\n}","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder":["/// A configurable builder for a regular expression.\n///\n/// A builder can be used to configure how the regex is built, for example, by\n/// setting the default flags (which can be overridden in the expression\n/// itself) or setting various limits.\npub struct RegexBuilder(RegexOptions);","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::build":["/// Consume the builder and compile the regular expression.\n///\n/// Note that calling `as_str` on the resulting `Regex` will produce the\n/// pattern given to `new` verbatim. Notably, it will not incorporate any\n/// of the flags set on this builder.\npub fn build(&self) -> Result<Regex, Error>{\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(Regex::from)\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::case_insensitive":["/// Set the value for the case insensitive (`i`) flag.\n///\n/// When enabled, letters in the pattern will match both upper case and\n/// lower case variants.\npub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder{\n                    self.0.case_insensitive = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::dfa_size_limit":["/// Set the approximate size of the cache used by the DFA.\n///\n/// This roughly corresponds to the number of bytes that the DFA will\n/// use while searching.\n///\n/// Note that this is a *per thread* limit. There is no way to set a global\n/// limit. In particular, if a regex is used from multiple threads\n/// simultaneously, then each thread may use up to the number of bytes\n/// specified here.\npub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder{\n                    self.0.dfa_size_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::dot_matches_new_line":["/// Set the value for the any character (`s`) flag, where in `.` matches\n/// anything when `s` is set and matches anything except for new line when\n/// it is not set (the default).\n///\n/// N.B. \"matches anything\" means \"any byte\" when Unicode is disabled and\n/// means \"any valid UTF-8 encoding of any Unicode scalar value\" when\n/// Unicode is enabled.\npub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder{\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::ignore_whitespace":["/// Set the value for the ignore whitespace (`x`) flag.\n///\n/// When enabled, whitespace such as new lines and spaces will be ignored\n/// between expressions of the pattern, and `#` can be used to start a\n/// comment until the next new line.\npub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder{\n                    self.0.ignore_whitespace = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::multi_line":["/// Set the value for the multi-line matching (`m`) flag.\n///\n/// When enabled, `^` matches the beginning of lines and `$` matches the\n/// end of lines.\n///\n/// By default, they match beginning/end of the input.\npub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder{\n                    self.0.multi_line = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::nest_limit":["/// Set the nesting limit for this parser.\n///\n/// The nesting limit controls how deep the abstract syntax tree is allowed\n/// to be. If the AST exceeds the given limit (e.g., with too many nested\n/// groups), then an error is returned by the parser.\n///\n/// The purpose of this limit is to act as a heuristic to prevent stack\n/// overflow for consumers that do structural induction on an `Ast` using\n/// explicit recursion. While this crate never does this (instead using\n/// constant stack space and moving the call stack to the heap), other\n/// crates may.\n///\n/// This limit is not checked until the entire Ast is parsed. Therefore,\n/// if callers want to put a limit on the amount of heap space used, then\n/// they should impose a limit on the length, in bytes, of the concrete\n/// pattern string. In particular, this is viable since this parser\n/// implementation will limit itself to heap space proportional to the\n/// length of the pattern string.\n///\n/// Note that a nest limit of `0` will return a nest limit error for most\n/// patterns but not all. For example, a nest limit of `0` permits `a` but\n/// not `ab`, since `ab` requires a concatenation, which results in a nest\n/// depth of `1`. In general, a nest limit is not something that manifests\n/// in an obvious way in the concrete syntax, therefore, it should not be\n/// used in a granular way.\npub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder{\n                    self.0.nest_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::new":["/// Create a new regular expression builder with the given pattern.\n///\n/// If the pattern is invalid, then an error will be returned when\n/// `build` is called.\npub fn new(pattern: &str) -> RegexBuilder{\n                    let mut builder = RegexBuilder(RegexOptions::default());\n                    builder.0.pats.push(pattern.to_owned());\n                    builder\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::octal":["/// Whether to support octal syntax or not.\n///\n/// Octal syntax is a little-known way of uttering Unicode codepoints in\n/// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n/// `\\141` are all equivalent regular expressions, where the last example\n/// shows octal syntax.\n///\n/// While supporting octal syntax isn't in and of itself a problem, it does\n/// make good error messages harder. That is, in PCRE based regex engines,\n/// syntax like `\\0` invokes a backreference, which is explicitly\n/// unsupported in Rust's regex engine. However, many users expect it to\n/// be supported. Therefore, when octal support is disabled, the error\n/// message will explicitly mention that backreferences aren't supported.\n///\n/// Octal syntax is disabled by default.\npub fn octal(&mut self, yes: bool) -> &mut RegexBuilder{\n                    self.0.octal = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::size_limit":["/// Set the approximate size limit of the compiled regular expression.\n///\n/// This roughly corresponds to the number of bytes occupied by a single\n/// compiled program. If the program exceeds this number, then a\n/// compilation error is returned.\npub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder{\n                    self.0.size_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::swap_greed":["/// Set the value for the greedy swap (`U`) flag.\n///\n/// When enabled, a pattern like `a*` is lazy (tries to find shortest\n/// match) and `a*?` is greedy (tries to find longest match).\n///\n/// By default, `a*` is greedy and `a*?` is lazy.\npub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder{\n                    self.0.swap_greed = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::bytes::RegexBuilder::unicode":["/// Set the value for the Unicode (`u`) flag.\n///\n/// Enabled by default. When disabled, character classes such as `\\w` only\n/// match ASCII word characters instead of all Unicode word characters.\npub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder{\n                    self.0.unicode = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder":["/// A configurable builder for a set of regular expressions.\n///\n/// A builder can be used to configure how the regexes are built, for example,\n/// by setting the default flags (which can be overridden in the expression\n/// itself) or setting various limits.\npub struct RegexSetBuilder(RegexOptions);","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::build":["/// Consume the builder and compile the regular expressions into a set.\npub fn build(&self) -> Result<RegexSet, Error>{\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(RegexSet::from)\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::case_insensitive":["/// Set the value for the case insensitive (`i`) flag.\npub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.case_insensitive = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::dfa_size_limit":["/// Set the approximate size of the cache used by the DFA.\n///\n/// This roughly corresponds to the number of bytes that the DFA will\n/// use while searching.\n///\n/// Note that this is a *per thread* limit. There is no way to set a global\n/// limit. In particular, if a regex is used from multiple threads\n/// simultaneously, then each thread may use up to the number of bytes\n/// specified here.\npub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder{\n                    self.0.dfa_size_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line":["/// Set the value for the any character (`s`) flag, where in `.` matches\n/// anything when `s` is set and matches anything except for new line when\n/// it is not set (the default).\n///\n/// N.B. \"matches anything\" means \"any byte\" for `regex::bytes::RegexSet`\n/// expressions and means \"any Unicode scalar value\" for `regex::RegexSet`\n/// expressions.\npub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::ignore_whitespace":["/// Set the value for the ignore whitespace (`x`) flag.\npub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.ignore_whitespace = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::multi_line":["/// Set the value for the multi-line matching (`m`) flag.\npub fn multi_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.multi_line = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::nest_limit":["/// Set the nesting limit for this parser.\n///\n/// The nesting limit controls how deep the abstract syntax tree is allowed\n/// to be. If the AST exceeds the given limit (e.g., with too many nested\n/// groups), then an error is returned by the parser.\n///\n/// The purpose of this limit is to act as a heuristic to prevent stack\n/// overflow for consumers that do structural induction on an `Ast` using\n/// explicit recursion. While this crate never does this (instead using\n/// constant stack space and moving the call stack to the heap), other\n/// crates may.\n///\n/// This limit is not checked until the entire Ast is parsed. Therefore,\n/// if callers want to put a limit on the amount of heap space used, then\n/// they should impose a limit on the length, in bytes, of the concrete\n/// pattern string. In particular, this is viable since this parser\n/// implementation will limit itself to heap space proportional to the\n/// length of the pattern string.\n///\n/// Note that a nest limit of `0` will return a nest limit error for most\n/// patterns but not all. For example, a nest limit of `0` permits `a` but\n/// not `ab`, since `ab` requires a concatenation, which results in a nest\n/// depth of `1`. In general, a nest limit is not something that manifests\n/// in an obvious way in the concrete syntax, therefore, it should not be\n/// used in a granular way.\npub fn nest_limit(\n                    &mut self,\n                    limit: u32,\n                ) -> &mut RegexSetBuilder{\n                    self.0.nest_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::new":["/// Create a new regular expression builder with the given pattern.\n///\n/// If the pattern is invalid, then an error will be returned when\n/// `build` is called.\npub fn new<I, S>(patterns: I) -> RegexSetBuilder\n                where\n                    S: AsRef<str>,\n                    I: IntoIterator<Item = S>,{\n                    let mut builder = RegexSetBuilder(RegexOptions::default());\n                    for pat in patterns {\n                        builder.0.pats.push(pat.as_ref().to_owned());\n                    }\n                    builder\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::octal":["/// Whether to support octal syntax or not.\n///\n/// Octal syntax is a little-known way of uttering Unicode codepoints in\n/// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n/// `\\141` are all equivalent regular expressions, where the last example\n/// shows octal syntax.\n///\n/// While supporting octal syntax isn't in and of itself a problem, it does\n/// make good error messages harder. That is, in PCRE based regex engines,\n/// syntax like `\\0` invokes a backreference, which is explicitly\n/// unsupported in Rust's regex engine. However, many users expect it to\n/// be supported. Therefore, when octal support is disabled, the error\n/// message will explicitly mention that backreferences aren't supported.\n///\n/// Octal syntax is disabled by default.\npub fn octal(&mut self, yes: bool) -> &mut RegexSetBuilder{\n                    self.0.octal = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::size_limit":["/// Set the approximate size limit of the compiled regular expression.\n///\n/// This roughly corresponds to the number of bytes occupied by a single\n/// compiled program. If the program exceeds this number, then a\n/// compilation error is returned.\npub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder{\n                    self.0.size_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::swap_greed":["/// Set the value for the greedy swap (`U`) flag.\npub fn swap_greed(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.swap_greed = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_bytes::RegexSetBuilder::unicode":["/// Set the value for the Unicode (`u`) flag.\npub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder{\n                    self.0.unicode = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder":["/// A configurable builder for a set of regular expressions.\n///\n/// A builder can be used to configure how the regexes are built, for example,\n/// by setting the default flags (which can be overridden in the expression\n/// itself) or setting various limits.\npub struct RegexSetBuilder(RegexOptions);","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::build":["/// Consume the builder and compile the regular expressions into a set.\npub fn build(&self) -> Result<RegexSet, Error>{\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(RegexSet::from)\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::case_insensitive":["/// Set the value for the case insensitive (`i`) flag.\npub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.case_insensitive = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::dfa_size_limit":["/// Set the approximate size of the cache used by the DFA.\n///\n/// This roughly corresponds to the number of bytes that the DFA will\n/// use while searching.\n///\n/// Note that this is a *per thread* limit. There is no way to set a global\n/// limit. In particular, if a regex is used from multiple threads\n/// simultaneously, then each thread may use up to the number of bytes\n/// specified here.\npub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder{\n                    self.0.dfa_size_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line":["/// Set the value for the any character (`s`) flag, where in `.` matches\n/// anything when `s` is set and matches anything except for new line when\n/// it is not set (the default).\n///\n/// N.B. \"matches anything\" means \"any byte\" for `regex::bytes::RegexSet`\n/// expressions and means \"any Unicode scalar value\" for `regex::RegexSet`\n/// expressions.\npub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::ignore_whitespace":["/// Set the value for the ignore whitespace (`x`) flag.\npub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.ignore_whitespace = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::multi_line":["/// Set the value for the multi-line matching (`m`) flag.\npub fn multi_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.multi_line = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::nest_limit":["/// Set the nesting limit for this parser.\n///\n/// The nesting limit controls how deep the abstract syntax tree is allowed\n/// to be. If the AST exceeds the given limit (e.g., with too many nested\n/// groups), then an error is returned by the parser.\n///\n/// The purpose of this limit is to act as a heuristic to prevent stack\n/// overflow for consumers that do structural induction on an `Ast` using\n/// explicit recursion. While this crate never does this (instead using\n/// constant stack space and moving the call stack to the heap), other\n/// crates may.\n///\n/// This limit is not checked until the entire Ast is parsed. Therefore,\n/// if callers want to put a limit on the amount of heap space used, then\n/// they should impose a limit on the length, in bytes, of the concrete\n/// pattern string. In particular, this is viable since this parser\n/// implementation will limit itself to heap space proportional to the\n/// length of the pattern string.\n///\n/// Note that a nest limit of `0` will return a nest limit error for most\n/// patterns but not all. For example, a nest limit of `0` permits `a` but\n/// not `ab`, since `ab` requires a concatenation, which results in a nest\n/// depth of `1`. In general, a nest limit is not something that manifests\n/// in an obvious way in the concrete syntax, therefore, it should not be\n/// used in a granular way.\npub fn nest_limit(\n                    &mut self,\n                    limit: u32,\n                ) -> &mut RegexSetBuilder{\n                    self.0.nest_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::new":["/// Create a new regular expression builder with the given pattern.\n///\n/// If the pattern is invalid, then an error will be returned when\n/// `build` is called.\npub fn new<I, S>(patterns: I) -> RegexSetBuilder\n                where\n                    S: AsRef<str>,\n                    I: IntoIterator<Item = S>,{\n                    let mut builder = RegexSetBuilder(RegexOptions::default());\n                    for pat in patterns {\n                        builder.0.pats.push(pat.as_ref().to_owned());\n                    }\n                    builder\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::octal":["/// Whether to support octal syntax or not.\n///\n/// Octal syntax is a little-known way of uttering Unicode codepoints in\n/// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n/// `\\141` are all equivalent regular expressions, where the last example\n/// shows octal syntax.\n///\n/// While supporting octal syntax isn't in and of itself a problem, it does\n/// make good error messages harder. That is, in PCRE based regex engines,\n/// syntax like `\\0` invokes a backreference, which is explicitly\n/// unsupported in Rust's regex engine. However, many users expect it to\n/// be supported. Therefore, when octal support is disabled, the error\n/// message will explicitly mention that backreferences aren't supported.\n///\n/// Octal syntax is disabled by default.\npub fn octal(&mut self, yes: bool) -> &mut RegexSetBuilder{\n                    self.0.octal = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::size_limit":["/// Set the approximate size limit of the compiled regular expression.\n///\n/// This roughly corresponds to the number of bytes occupied by a single\n/// compiled program. If the program exceeds this number, then a\n/// compilation error is returned.\npub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexSetBuilder{\n                    self.0.size_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::swap_greed":["/// Set the value for the greedy swap (`U`) flag.\npub fn swap_greed(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexSetBuilder{\n                    self.0.swap_greed = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::set_unicode::RegexSetBuilder::unicode":["/// Set the value for the Unicode (`u`) flag.\npub fn unicode(&mut self, yes: bool) -> &mut RegexSetBuilder{\n                    self.0.unicode = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder":["/// A configurable builder for a regular expression.\n///\n/// A builder can be used to configure how the regex is built, for example, by\n/// setting the default flags (which can be overridden in the expression\n/// itself) or setting various limits.\npub struct RegexBuilder(RegexOptions);","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::build":["/// Consume the builder and compile the regular expression.\n///\n/// Note that calling `as_str` on the resulting `Regex` will produce the\n/// pattern given to `new` verbatim. Notably, it will not incorporate any\n/// of the flags set on this builder.\npub fn build(&self) -> Result<Regex, Error>{\n                    ExecBuilder::new_options(self.0.clone())\n                        .only_utf8($only_utf8)\n                        .build()\n                        .map(Regex::from)\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::case_insensitive":["/// Set the value for the case insensitive (`i`) flag.\n///\n/// When enabled, letters in the pattern will match both upper case and\n/// lower case variants.\npub fn case_insensitive(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder{\n                    self.0.case_insensitive = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::dfa_size_limit":["/// Set the approximate size of the cache used by the DFA.\n///\n/// This roughly corresponds to the number of bytes that the DFA will\n/// use while searching.\n///\n/// Note that this is a *per thread* limit. There is no way to set a global\n/// limit. In particular, if a regex is used from multiple threads\n/// simultaneously, then each thread may use up to the number of bytes\n/// specified here.\npub fn dfa_size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder{\n                    self.0.dfa_size_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::dot_matches_new_line":["/// Set the value for the any character (`s`) flag, where in `.` matches\n/// anything when `s` is set and matches anything except for new line when\n/// it is not set (the default).\n///\n/// N.B. \"matches anything\" means \"any byte\" when Unicode is disabled and\n/// means \"any valid UTF-8 encoding of any Unicode scalar value\" when\n/// Unicode is enabled.\npub fn dot_matches_new_line(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder{\n                    self.0.dot_matches_new_line = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::ignore_whitespace":["/// Set the value for the ignore whitespace (`x`) flag.\n///\n/// When enabled, whitespace such as new lines and spaces will be ignored\n/// between expressions of the pattern, and `#` can be used to start a\n/// comment until the next new line.\npub fn ignore_whitespace(\n                    &mut self,\n                    yes: bool,\n                ) -> &mut RegexBuilder{\n                    self.0.ignore_whitespace = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::multi_line":["/// Set the value for the multi-line matching (`m`) flag.\n///\n/// When enabled, `^` matches the beginning of lines and `$` matches the\n/// end of lines.\n///\n/// By default, they match beginning/end of the input.\npub fn multi_line(&mut self, yes: bool) -> &mut RegexBuilder{\n                    self.0.multi_line = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::nest_limit":["/// Set the nesting limit for this parser.\n///\n/// The nesting limit controls how deep the abstract syntax tree is allowed\n/// to be. If the AST exceeds the given limit (e.g., with too many nested\n/// groups), then an error is returned by the parser.\n///\n/// The purpose of this limit is to act as a heuristic to prevent stack\n/// overflow for consumers that do structural induction on an `Ast` using\n/// explicit recursion. While this crate never does this (instead using\n/// constant stack space and moving the call stack to the heap), other\n/// crates may.\n///\n/// This limit is not checked until the entire Ast is parsed. Therefore,\n/// if callers want to put a limit on the amount of heap space used, then\n/// they should impose a limit on the length, in bytes, of the concrete\n/// pattern string. In particular, this is viable since this parser\n/// implementation will limit itself to heap space proportional to the\n/// length of the pattern string.\n///\n/// Note that a nest limit of `0` will return a nest limit error for most\n/// patterns but not all. For example, a nest limit of `0` permits `a` but\n/// not `ab`, since `ab` requires a concatenation, which results in a nest\n/// depth of `1`. In general, a nest limit is not something that manifests\n/// in an obvious way in the concrete syntax, therefore, it should not be\n/// used in a granular way.\npub fn nest_limit(&mut self, limit: u32) -> &mut RegexBuilder{\n                    self.0.nest_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::new":["/// Create a new regular expression builder with the given pattern.\n///\n/// If the pattern is invalid, then an error will be returned when\n/// `build` is called.\npub fn new(pattern: &str) -> RegexBuilder{\n                    let mut builder = RegexBuilder(RegexOptions::default());\n                    builder.0.pats.push(pattern.to_owned());\n                    builder\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::octal":["/// Whether to support octal syntax or not.\n///\n/// Octal syntax is a little-known way of uttering Unicode codepoints in\n/// a regular expression. For example, `a`, `\\x61`, `\\u0061` and\n/// `\\141` are all equivalent regular expressions, where the last example\n/// shows octal syntax.\n///\n/// While supporting octal syntax isn't in and of itself a problem, it does\n/// make good error messages harder. That is, in PCRE based regex engines,\n/// syntax like `\\0` invokes a backreference, which is explicitly\n/// unsupported in Rust's regex engine. However, many users expect it to\n/// be supported. Therefore, when octal support is disabled, the error\n/// message will explicitly mention that backreferences aren't supported.\n///\n/// Octal syntax is disabled by default.\npub fn octal(&mut self, yes: bool) -> &mut RegexBuilder{\n                    self.0.octal = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::size_limit":["/// Set the approximate size limit of the compiled regular expression.\n///\n/// This roughly corresponds to the number of bytes occupied by a single\n/// compiled program. If the program exceeds this number, then a\n/// compilation error is returned.\npub fn size_limit(\n                    &mut self,\n                    limit: usize,\n                ) -> &mut RegexBuilder{\n                    self.0.size_limit = limit;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::swap_greed":["/// Set the value for the greedy swap (`U`) flag.\n///\n/// When enabled, a pattern like `a*` is lazy (tries to find shortest\n/// match) and `a*?` is greedy (tries to find longest match).\n///\n/// By default, `a*` is greedy and `a*?` is lazy.\npub fn swap_greed(&mut self, yes: bool) -> &mut RegexBuilder{\n                    self.0.swap_greed = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_builder::unicode::RegexBuilder::unicode":["/// Set the value for the Unicode (`u`) flag.\n///\n/// Enabled by default. When disabled, character classes such as `\\w` only\n/// match ASCII word characters instead of all Unicode word characters.\npub fn unicode(&mut self, yes: bool) -> &mut RegexBuilder{\n                    self.0.unicode = yes;\n                    self\n                }","Real(LocalPath(\"src/re_builder.rs\"))"],"re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from":["fn from(m: Match<'t>) -> Range<usize>{\n        m.range()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::CaptureLocations":["/// CaptureLocations is a low level representation of the raw offsets of each\n/// submatch.\n///\n/// You can think of this as a lower level\n/// [`Captures`](struct.Captures.html), where this type does not support\n/// named capturing groups directly and it does not borrow the text that these\n/// offsets were matched on.\n///\n/// Primarily, this type is useful when using the lower level `Regex` APIs\n/// such as `read_captures`, which permits amortizing the allocation in which\n/// capture match locations are stored.\n///\n/// In order to build a value of this type, you'll need to call the\n/// `capture_locations` method on the `Regex` being used to execute the search.\n/// The value returned can then be reused in subsequent searches.\n///\n/// # Example\n///\n/// This example shows how to create and use `CaptureLocations` in a search.\n///\n/// ```\n/// use regex::bytes::Regex;\n///\n/// let re = Regex::new(r\"(?<first>\\w+)\\s+(?<last>\\w+)\").unwrap();\n/// let mut locs = re.capture_locations();\n/// let m = re.captures_read(&mut locs, b\"Bruce Springsteen\").unwrap();\n/// assert_eq!(0..17, m.range());\n/// assert_eq!(Some((0, 17)), locs.get(0));\n/// assert_eq!(Some((0, 5)), locs.get(1));\n/// assert_eq!(Some((6, 17)), locs.get(2));\n///\n/// // Asking for an invalid capture group always returns None.\n/// assert_eq!(None, locs.get(3));\n/// assert_eq!(None, locs.get(34973498648));\n/// assert_eq!(None, locs.get(9944060567225171988));\n/// ```\npub struct CaptureLocations(re_trait::Locations);","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::CaptureLocations::get":["/// Returns the start and end positions of the Nth capture group. Returns\n/// `None` if `i` is not a valid capture group or if the capture group did\n/// not match anything. The positions returned are *always* byte indices\n/// with respect to the original string matched.\n#[inline]\npub fn get(&self, i: usize) -> Option<(usize, usize)>{\n        self.0.pos(i)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::CaptureLocations::len":["/// Returns the total number of capture groups (even if they didn't match).\n///\n/// This is always at least `1` since every regex has at least `1`\n/// capturing group that corresponds to the entire match.\n#[inline]\npub fn len(&self) -> usize{\n        self.0.len()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::CaptureLocations::pos":["/// An alias for the `get` method for backwards compatibility.\n///\n/// Previously, we exported `get` as `pos` in an undocumented API. To\n/// prevent breaking that code (e.g., in `regex-capi`), we continue\n/// re-exporting the same undocumented API.\n#[doc(hidden)]\n#[inline]\npub fn pos(&self, i: usize) -> Option<(usize, usize)>{\n        self.get(i)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::CaptureMatches":["/// An iterator that yields all non-overlapping capture groups matching a\n/// particular regular expression.\n///\n/// The iterator stops when no more matches can be found.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the matched byte string.\npub struct CaptureMatches<'r, 't>(\n    re_trait::CaptureMatches<'t, ExecNoSync<'r>>,\n);","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::CaptureNames":["/// An iterator over the names of all possible captures.\n///\n/// `None` indicates an unnamed capture; the first element (capture 0, the\n/// whole matched region) is always unnamed.\n///\n/// `'r` is the lifetime of the compiled regular expression.\npub struct CaptureNames<'r>(::std::slice::Iter<'r, Option<String>>);","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Captures":["/// Captures represents a group of captured byte strings for a single match.\n///\n/// The 0th capture always corresponds to the entire match. Each subsequent\n/// index corresponds to the next capture group in the regex. If a capture\n/// group is named, then the matched byte string is *also* available via the\n/// `name` method. (Note that the 0th capture is always unnamed and so must be\n/// accessed with the `get` method.)\n///\n/// Positions returned from a capture group are always byte indices.\n///\n/// `'t` is the lifetime of the matched text.\npub struct Captures<'t> {\n    text: &'t [u8],\n    locs: re_trait::Locations,\n    named_groups: Arc<HashMap<String, usize>>,\n}","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Captures::<'t>::expand":["/// Expands all instances of `$name` in `replacement` to the corresponding\n/// capture group `name`, and writes them to the `dst` buffer given.\n///\n/// `name` may be an integer corresponding to the index of the capture\n/// group (counted by order of opening parenthesis where `0` is the\n/// entire match) or it can be a name (consisting of letters, digits or\n/// underscores) corresponding to a named capture group.\n///\n/// If `name` isn't a valid capture group (whether the name doesn't exist\n/// or isn't a valid index), then it is replaced with the empty string.\n///\n/// The longest possible name consisting of the characters `[_0-9A-Za-z]`\n/// is used. e.g., `$1a` looks up the capture group named `1a` and not the\n/// capture group at index `1`. To exert more precise control over the\n/// name, or to refer to a capture group name that uses characters outside\n/// of `[_0-9A-Za-z]`, use braces, e.g., `${1}a` or `${foo[bar].baz}`. When\n/// using braces, any sequence of valid UTF-8 bytes is permitted. If the\n/// sequence does not refer to a capture group name in the corresponding\n/// regex, then it is replaced with an empty string.\n///\n/// To write a literal `$` use `$$`.\npub fn expand(&self, replacement: &[u8], dst: &mut Vec<u8>){\n        expand_bytes(self, replacement, dst)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Captures::<'t>::get":["/// Returns the match associated with the capture group at index `i`. If\n/// `i` does not correspond to a capture group, or if the capture group\n/// did not participate in the match, then `None` is returned.\n///\n/// # Examples\n///\n/// Get the text of the match with a default of an empty string if this\n/// group didn't participate in the match:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// let re = Regex::new(r\"[a-z]+(?:([0-9]+)|([A-Z]+))\").unwrap();\n/// let caps = re.captures(b\"abc123\").unwrap();\n///\n/// let text1 = caps.get(1).map_or(&b\"\"[..], |m| m.as_bytes());\n/// let text2 = caps.get(2).map_or(&b\"\"[..], |m| m.as_bytes());\n/// assert_eq!(text1, &b\"123\"[..]);\n/// assert_eq!(text2, &b\"\"[..]);\n/// ```\npub fn get(&self, i: usize) -> Option<Match<'t>>{\n        self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Captures::<'t>::iter":["/// An iterator that yields all capturing matches in the order in which\n/// they appear in the regex. If a particular capture group didn't\n/// participate in the match, then `None` is yielded for that capture.\n///\n/// The first match always corresponds to the overall match of the regex.\npub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 't>{\n        SubCaptureMatches { caps: self, it: self.locs.iter() }\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Captures::<'t>::len":["/// Returns the total number of capture groups (even if they didn't match).\n///\n/// This is always at least `1`, since every regex has at least one capture\n/// group that corresponds to the full match.\n#[inline]\npub fn len(&self) -> usize{\n        self.locs.len()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Captures::<'t>::name":["/// Returns the match for the capture group named `name`. If `name` isn't a\n/// valid capture group or didn't match anything, then `None` is returned.\npub fn name(&self, name: &str) -> Option<Match<'t>>{\n        self.named_groups.get(name).and_then(|&i| self.get(i))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::CapturesDebug":["struct CapturesDebug<'c, 't>(&'c Captures<'t>);","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Match":["/// Match represents a single match of a regex in a haystack.\n///\n/// The lifetime parameter `'t` refers to the lifetime of the matched text.\npub struct Match<'t> {\n    text: &'t [u8],\n    start: usize,\n    end: usize,\n}","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Match::<'t>::as_bytes":["/// Returns the matched text.\n#[inline]\npub fn as_bytes(&self) -> &'t [u8]{\n        &self.text[self.range()]\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Match::<'t>::end":["/// Returns the ending byte offset of the match in the haystack.\n#[inline]\npub fn end(&self) -> usize{\n        self.end\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Match::<'t>::is_empty":["/// Returns true if and only if this match has a length of zero.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.start == self.end\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Match::<'t>::len":["/// Returns the length, in bytes, of this match.\n#[inline]\npub fn len(&self) -> usize{\n        self.end - self.start\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Match::<'t>::new":["/// Creates a new match from the given haystack and byte offsets.\n#[inline]\nfn new(haystack: &'t [u8], start: usize, end: usize) -> Match<'t>{\n        Match { text: haystack, start, end }\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Match::<'t>::range":["/// Returns the range over the starting and ending byte offsets of the\n/// match in the haystack.\n#[inline]\npub fn range(&self) -> Range<usize>{\n        self.start..self.end\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Match::<'t>::start":["/// Returns the starting byte offset of the match in the haystack.\n#[inline]\npub fn start(&self) -> usize{\n        self.start\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Matches":["/// An iterator over all non-overlapping matches for a particular string.\n///\n/// The iterator yields a tuple of integers corresponding to the start and end\n/// of the match. The indices are byte offsets. The iterator stops when no more\n/// matches can be found.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the matched byte string.\npub struct Matches<'r, 't>(re_trait::Matches<'t, ExecNoSync<'r>>);","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::NoExpand":["/// `NoExpand` indicates literal byte string replacement.\n///\n/// It can be used with `replace` and `replace_all` to do a literal byte string\n/// replacement without expanding `$name` to their corresponding capture\n/// groups. This can be both convenient (to avoid escaping `$`, for example)\n/// and performant (since capture groups don't need to be found).\n///\n/// `'t` is the lifetime of the literal text.\npub struct NoExpand<'t>(pub &'t [u8]);","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex":["/// A compiled regular expression for matching arbitrary bytes.\n///\n/// It can be used to search, split or replace text. All searching is done with\n/// an implicit `.*?` at the beginning and end of an expression. To force an\n/// expression to match the whole string (or a prefix or a suffix), you must\n/// use an anchor like `^` or `$` (or `\\A` and `\\z`).\n///\n/// Like the `Regex` type in the parent module, matches with this regex return\n/// byte offsets into the search text. **Unlike** the parent `Regex` type,\n/// these byte offsets may not correspond to UTF-8 sequence boundaries since\n/// the regexes in this module can match arbitrary bytes.\npub struct Regex(Exec);","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::as_str":["/// Returns the original string of this regex.\npub fn as_str(&self) -> &str{\n        &self.0.regex_strings()[0]\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::capture_locations":["/// Returns an empty set of capture locations that can be reused in\n/// multiple calls to `captures_read` or `captures_read_at`.\npub fn capture_locations(&self) -> CaptureLocations{\n        CaptureLocations(self.0.searcher().locations())\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::capture_names":["/// Returns an iterator over the capture names.\npub fn capture_names(&self) -> CaptureNames<'_>{\n        CaptureNames(self.0.capture_names().iter())\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::captures":["/// Returns the capture groups corresponding to the leftmost-first\n/// match in `text`. Capture group `0` always corresponds to the entire\n/// match. If no match is found, then `None` is returned.\n///\n/// You should only use `captures` if you need access to the location of\n/// capturing group matches. Otherwise, `find` is faster for discovering\n/// the location of the overall match.\n///\n/// # Examples\n///\n/// Say you have some text with movie names and their release years,\n/// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for text\n/// looking like that, while also extracting the movie name and its release\n/// year separately.\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n/// let text = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let caps = re.captures(text).unwrap();\n/// assert_eq!(caps.get(1).unwrap().as_bytes(), &b\"Citizen Kane\"[..]);\n/// assert_eq!(caps.get(2).unwrap().as_bytes(), &b\"1941\"[..]);\n/// assert_eq!(caps.get(0).unwrap().as_bytes(), &b\"'Citizen Kane' (1941)\"[..]);\n/// // You can also access the groups by index using the Index notation.\n/// // Note that this will panic on an invalid index.\n/// assert_eq!(&caps[1], b\"Citizen Kane\");\n/// assert_eq!(&caps[2], b\"1941\");\n/// assert_eq!(&caps[0], b\"'Citizen Kane' (1941)\");\n/// # }\n/// ```\n///\n/// Note that the full match is at capture group `0`. Each subsequent\n/// capture group is indexed by the order of its opening `(`.\n///\n/// We can make this example a bit clearer by using *named* capture groups:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n///                .unwrap();\n/// let text = b\"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let caps = re.captures(text).unwrap();\n/// assert_eq!(caps.name(\"title\").unwrap().as_bytes(), b\"Citizen Kane\");\n/// assert_eq!(caps.name(\"year\").unwrap().as_bytes(), b\"1941\");\n/// assert_eq!(caps.get(0).unwrap().as_bytes(), &b\"'Citizen Kane' (1941)\"[..]);\n/// // You can also access the groups by name using the Index notation.\n/// // Note that this will panic on an invalid group name.\n/// assert_eq!(&caps[\"title\"], b\"Citizen Kane\");\n/// assert_eq!(&caps[\"year\"], b\"1941\");\n/// assert_eq!(&caps[0], b\"'Citizen Kane' (1941)\");\n///\n/// # }\n/// ```\n///\n/// Here we name the capture groups, which we can access with the `name`\n/// method or the `Index` notation with a `&str`. Note that the named\n/// capture groups are still accessible with `get` or the `Index` notation\n/// with a `usize`.\n///\n/// The `0`th capture group is always unnamed, so it must always be\n/// accessed with `get(0)` or `[0]`.\npub fn captures<'t>(&self, text: &'t [u8]) -> Option<Captures<'t>>{\n        self.captures_at(text, 0)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::captures_at":["/// Returns the same as [`Regex::captures`], but starts the search at the\n/// given offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn captures_at<'t>(\n        &self,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Captures<'t>>{\n        let mut locs = self.capture_locations();\n        self.captures_read_at(&mut locs, text, start).map(move |_| Captures {\n            text,\n            locs: locs.0,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::captures_iter":["/// Returns an iterator over all the non-overlapping capture groups matched\n/// in `text`. This is operationally the same as `find_iter`, except it\n/// yields information about capturing group matches.\n///\n/// # Example\n///\n/// We can use this to find all movie titles and their release years in\n/// some text, where the movie is formatted like \"'Title' (xxxx)\":\n///\n/// ```rust\n/// # use std::str; use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n///                .unwrap();\n/// let text = b\"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931).\";\n/// for caps in re.captures_iter(text) {\n///     let title = str::from_utf8(&caps[\"title\"]).unwrap();\n///     let year = str::from_utf8(&caps[\"year\"]).unwrap();\n///     println!(\"Movie: {:?}, Released: {:?}\", title, year);\n/// }\n/// // Output:\n/// // Movie: Citizen Kane, Released: 1941\n/// // Movie: The Wizard of Oz, Released: 1939\n/// // Movie: M, Released: 1931\n/// # }\n/// ```\npub fn captures_iter<'r, 't>(\n        &'r self,\n        text: &'t [u8],\n    ) -> CaptureMatches<'r, 't>{\n        CaptureMatches(self.0.searcher().captures_iter(text))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::captures_len":["/// Returns the number of captures.\npub fn captures_len(&self) -> usize{\n        self.0.capture_names().len()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::captures_read":["/// This is like `captures`, but uses\n/// [`CaptureLocations`](struct.CaptureLocations.html)\n/// instead of\n/// [`Captures`](struct.Captures.html) in order to amortize allocations.\n///\n/// To create a `CaptureLocations` value, use the\n/// `Regex::capture_locations` method.\n///\n/// This returns the overall match if this was successful, which is always\n/// equivalence to the `0`th capture group.\npub fn captures_read<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n    ) -> Option<Match<'t>>{\n        self.captures_read_at(locs, text, 0)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::captures_read_at":["/// Returns the same as `captures_read`, but starts the search at the given\n/// offset and populates the capture locations given.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn captures_read_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>>{\n        self.0\n            .searcher()\n            .captures_read_at(&mut locs.0, text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::find":["/// Returns the start and end byte range of the leftmost-first match in\n/// `text`. If no match exists, then `None` is returned.\n///\n/// Note that this should only be used if you want to discover the position\n/// of the match. Testing the existence of a match is faster if you use\n/// `is_match`.\n///\n/// # Example\n///\n/// Find the start and end location of the first word with exactly 13\n/// ASCII word bytes:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let text = b\"I categorically deny having triskaidekaphobia.\";\n/// let mat = Regex::new(r\"\\b\\w{13}\\b\").unwrap().find(text).unwrap();\n/// assert_eq!((mat.start(), mat.end()), (2, 15));\n/// # }\n/// ```\npub fn find<'t>(&self, text: &'t [u8]) -> Option<Match<'t>>{\n        self.find_at(text, 0)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::find_at":["/// Returns the same as find, but starts the search at the given\n/// offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn find_at<'t>(\n        &self,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>>{\n        self.0\n            .searcher()\n            .find_at(text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::find_iter":["/// Returns an iterator for each successive non-overlapping match in\n/// `text`, returning the start and end byte indices with respect to\n/// `text`.\n///\n/// # Example\n///\n/// Find the start and end location of every word with exactly 13 ASCII\n/// word bytes:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let text = b\"Retroactively relinquishing remunerations is reprehensible.\";\n/// for mat in Regex::new(r\"\\b\\w{13}\\b\").unwrap().find_iter(text) {\n///     println!(\"{:?}\", mat);\n/// }\n/// # }\n/// ```\npub fn find_iter<'r, 't>(&'r self, text: &'t [u8]) -> Matches<'r, 't>{\n        Matches(self.0.searcher().find_iter(text))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::is_match":["/// Returns true if and only if there is a match for the regex in the\n/// string given.\n///\n/// It is recommended to use this method if all you need to do is test\n/// a match, since the underlying matching engine may be able to do less\n/// work.\n///\n/// # Example\n///\n/// Test if some text contains at least one word with exactly 13 ASCII word\n/// bytes:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let text = b\"I categorically deny having triskaidekaphobia.\";\n/// assert!(Regex::new(r\"\\b\\w{13}\\b\").unwrap().is_match(text));\n/// # }\n/// ```\npub fn is_match(&self, text: &[u8]) -> bool{\n        self.is_match_at(text, 0)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::is_match_at":["/// Returns the same as is_match, but starts the search at the given\n/// offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn is_match_at(&self, text: &[u8], start: usize) -> bool{\n        self.0.searcher().is_match_at(text, start)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::locations":["/// An alias for `capture_locations` to preserve backward compatibility.\n///\n/// The `regex-capi` crate uses this method, so to avoid breaking that\n/// crate, we continue to export it as an undocumented API.\n#[doc(hidden)]\npub fn locations(&self) -> CaptureLocations{\n        CaptureLocations(self.0.searcher().locations())\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::new":["/// Compiles a regular expression. Once compiled, it can be used repeatedly\n/// to search, split or replace text in a string.\n///\n/// If an invalid expression is given, then an error is returned.\npub fn new(re: &str) -> Result<Regex, Error>{\n        RegexBuilder::new(re).build()\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::read_captures_at":["/// An undocumented alias for `captures_read_at`.\n///\n/// The `regex-capi` crate previously used this routine, so to avoid\n/// breaking that crate, we continue to provide the name as an undocumented\n/// alias.\n#[doc(hidden)]\npub fn read_captures_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t [u8],\n        start: usize,\n    ) -> Option<Match<'t>>{\n        self.captures_read_at(locs, text, start)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::replace":["/// Replaces the leftmost-first match with the replacement provided. The\n/// replacement can be a regular byte string (where `$N` and `$name` are\n/// expanded to match capture groups) or a function that takes the matches'\n/// `Captures` and returns the replaced byte string.\n///\n/// If no match is found, then a copy of the byte string is returned\n/// unchanged.\n///\n/// # Replacement string syntax\n///\n/// All instances of `$name` in the replacement text is replaced with the\n/// corresponding capture group `name`.\n///\n/// `name` may be an integer corresponding to the index of the\n/// capture group (counted by order of opening parenthesis where `0` is the\n/// entire match) or it can be a name (consisting of letters, digits or\n/// underscores) corresponding to a named capture group.\n///\n/// If `name` isn't a valid capture group (whether the name doesn't exist\n/// or isn't a valid index), then it is replaced with the empty string.\n///\n/// The longest possible name is used. e.g., `$1a` looks up the capture\n/// group named `1a` and not the capture group at index `1`. To exert more\n/// precise control over the name, use braces, e.g., `${1}a`.\n///\n/// To write a literal `$` use `$$`.\n///\n/// # Examples\n///\n/// Note that this function is polymorphic with respect to the replacement.\n/// In typical usage, this can just be a normal byte string:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(\"[^01]+\").unwrap();\n/// assert_eq!(re.replace(b\"1078910\", &b\"\"[..]), &b\"1010\"[..]);\n/// # }\n/// ```\n///\n/// But anything satisfying the `Replacer` trait will work. For example, a\n/// closure of type `|&Captures| -> Vec<u8>` provides direct access to the\n/// captures corresponding to a match. This allows one to access capturing\n/// group matches easily:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # use regex::bytes::Captures; fn main() {\n/// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(b\"Springsteen, Bruce\", |caps: &Captures| {\n///     let mut replacement = caps[2].to_owned();\n///     replacement.push(b' ');\n///     replacement.extend(&caps[1]);\n///     replacement\n/// });\n/// assert_eq!(result, &b\"Bruce Springsteen\"[..]);\n/// # }\n/// ```\n///\n/// But this is a bit cumbersome to use all the time. Instead, a simple\n/// syntax is supported that expands `$name` into the corresponding capture\n/// group. Here's the last example, but using this expansion technique\n/// with named capture groups:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\").unwrap();\n/// let result = re.replace(b\"Springsteen, Bruce\", &b\"$first $last\"[..]);\n/// assert_eq!(result, &b\"Bruce Springsteen\"[..]);\n/// # }\n/// ```\n///\n/// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n/// would produce the same result. To write a literal `$` use `$$`.\n///\n/// Sometimes the replacement string requires use of curly braces to\n/// delineate a capture group replacement and surrounding literal text.\n/// For example, if we wanted to join two words together with an\n/// underscore:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"(?P<first>\\w+)\\s+(?P<second>\\w+)\").unwrap();\n/// let result = re.replace(b\"deep fried\", &b\"${first}_$second\"[..]);\n/// assert_eq!(result, &b\"deep_fried\"[..]);\n/// # }\n/// ```\n///\n/// Without the curly braces, the capture group name `first_` would be\n/// used, and since it doesn't exist, it would be replaced with the empty\n/// string.\n///\n/// Finally, sometimes you just want to replace a literal string with no\n/// regard for capturing group expansion. This can be done by wrapping a\n/// byte string with `NoExpand`:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// use regex::bytes::NoExpand;\n///\n/// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(b\"Springsteen, Bruce\", NoExpand(b\"$2 $last\"));\n/// assert_eq!(result, &b\"$2 $last\"[..]);\n/// # }\n/// ```\npub fn replace<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        rep: R,\n    ) -> Cow<'t, [u8]>{\n        self.replacen(text, 1, rep)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::replace_all":["/// Replaces all non-overlapping matches in `text` with the replacement\n/// provided. This is the same as calling `replacen` with `limit` set to\n/// `0`.\n///\n/// See the documentation for `replace` for details on how to access\n/// capturing group matches in the replacement text.\npub fn replace_all<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        rep: R,\n    ) -> Cow<'t, [u8]>{\n        self.replacen(text, 0, rep)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::replacen":["/// Replaces at most `limit` non-overlapping matches in `text` with the\n/// replacement provided. If `limit` is 0, then all non-overlapping matches\n/// are replaced.\n///\n/// See the documentation for `replace` for details on how to access\n/// capturing group matches in the replacement text.\npub fn replacen<'t, R: Replacer>(\n        &self,\n        text: &'t [u8],\n        limit: usize,\n        mut rep: R,\n    ) -> Cow<'t, [u8]>{\n        if let Some(rep) = rep.no_expansion() {\n            let mut it = self.find_iter(text).enumerate().peekable();\n            if it.peek().is_none() {\n                return Cow::Borrowed(text);\n            }\n            let mut new = Vec::with_capacity(text.len());\n            let mut last_match = 0;\n            for (i, m) in it {\n                new.extend_from_slice(&text[last_match..m.start()]);\n                new.extend_from_slice(&rep);\n                last_match = m.end();\n                if limit > 0 && i >= limit - 1 {\n                    break;\n                }\n            }\n            new.extend_from_slice(&text[last_match..]);\n            return Cow::Owned(new);\n        }\n\n        // The slower path, which we use if the replacement needs access to\n        // capture groups.\n        let mut it = self.captures_iter(text).enumerate().peekable();\n        if it.peek().is_none() {\n            return Cow::Borrowed(text);\n        }\n        let mut new = Vec::with_capacity(text.len());\n        let mut last_match = 0;\n        for (i, cap) in it {\n            // unwrap on 0 is OK because captures only reports matches\n            let m = cap.get(0).unwrap();\n            new.extend_from_slice(&text[last_match..m.start()]);\n            rep.replace_append(&cap, &mut new);\n            last_match = m.end();\n            if limit > 0 && i >= limit - 1 {\n                break;\n            }\n        }\n        new.extend_from_slice(&text[last_match..]);\n        Cow::Owned(new)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::shortest_match":["/// Returns the end location of a match in the text given.\n///\n/// This method may have the same performance characteristics as\n/// `is_match`, except it provides an end location for a match. In\n/// particular, the location returned *may be shorter* than the proper end\n/// of the leftmost-first match that you would find via `Regex::find`.\n///\n/// Note that it is not guaranteed that this routine finds the shortest or\n/// \"earliest\" possible match. Instead, the main idea of this API is that\n/// it returns the offset at the point at which the internal regex engine\n/// has determined that a match has occurred. This may vary depending on\n/// which internal regex engine is used, and thus, the offset itself may\n/// change.\n///\n/// # Example\n///\n/// Typically, `a+` would match the entire first sequence of `a` in some\n/// text, but `shortest_match` can give up as soon as it sees the first\n/// `a`.\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let text = b\"aaaaa\";\n/// let pos = Regex::new(r\"a+\").unwrap().shortest_match(text);\n/// assert_eq!(pos, Some(1));\n/// # }\n/// ```\npub fn shortest_match(&self, text: &[u8]) -> Option<usize>{\n        self.shortest_match_at(text, 0)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::shortest_match_at":["/// Returns the same as shortest_match, but starts the search at the given\n/// offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn shortest_match_at(\n        &self,\n        text: &[u8],\n        start: usize,\n    ) -> Option<usize>{\n        self.0.searcher().shortest_match_at(text, start)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::split":["/// Returns an iterator of substrings of `text` delimited by a match of the\n/// regular expression. Namely, each element of the iterator corresponds to\n/// text that *isn't* matched by the regular expression.\n///\n/// This method will *not* copy the text given.\n///\n/// # Example\n///\n/// To split a string delimited by arbitrary amounts of spaces or tabs:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"[ \\t]+\").unwrap();\n/// let fields: Vec<&[u8]> = re.split(b\"a b \\t  c\\td    e\").collect();\n/// assert_eq!(fields, vec![\n///     &b\"a\"[..], &b\"b\"[..], &b\"c\"[..], &b\"d\"[..], &b\"e\"[..],\n/// ]);\n/// # }\n/// ```\npub fn split<'r, 't>(&'r self, text: &'t [u8]) -> Split<'r, 't>{\n        Split { finder: self.find_iter(text), last: 0 }\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::splitn":["/// Returns an iterator of at most `limit` substrings of `text` delimited\n/// by a match of the regular expression. (A `limit` of `0` will return no\n/// substrings.) Namely, each element of the iterator corresponds to text\n/// that *isn't* matched by the regular expression. The remainder of the\n/// string that is not split will be the last element in the iterator.\n///\n/// This method will *not* copy the text given.\n///\n/// # Example\n///\n/// Get the first two words in some text:\n///\n/// ```rust\n/// # use regex::bytes::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"\\W+\").unwrap();\n/// let fields: Vec<&[u8]> = re.splitn(b\"Hey! How are you?\", 3).collect();\n/// assert_eq!(fields, vec![&b\"Hey\"[..], &b\"How\"[..], &b\"are you?\"[..]]);\n/// # }\n/// ```\npub fn splitn<'r, 't>(\n        &'r self,\n        text: &'t [u8],\n        limit: usize,\n    ) -> SplitN<'r, 't>{\n        SplitN { splits: self.split(text), n: limit }\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Regex::static_captures_len":["/// Returns the total number of capturing groups that appear in every\n/// possible match.\n///\n/// If the number of capture groups can vary depending on the match, then\n/// this returns `None`. That is, a value is only returned when the number\n/// of matching groups is invariant or \"static.\"\n///\n/// Note that like [`Regex::captures_len`], this **does** include the\n/// implicit capturing group corresponding to the entire match. Therefore,\n/// when a non-None value is returned, it is guaranteed to be at least `1`.\n/// Stated differently, a return value of `Some(0)` is impossible.\n///\n/// # Example\n///\n/// This shows a few cases where a static number of capture groups is\n/// available and a few cases where it is not.\n///\n/// ```\n/// use regex::bytes::Regex;\n///\n/// let len = |pattern| {\n///     Regex::new(pattern).map(|re| re.static_captures_len())\n/// };\n///\n/// assert_eq!(Some(1), len(\"a\")?);\n/// assert_eq!(Some(2), len(\"(a)\")?);\n/// assert_eq!(Some(2), len(\"(a)|(b)\")?);\n/// assert_eq!(Some(3), len(\"(a)(b)|(c)(d)\")?);\n/// assert_eq!(None, len(\"(a)|b\")?);\n/// assert_eq!(None, len(\"a|(b)\")?);\n/// assert_eq!(None, len(\"(b)*\")?);\n/// assert_eq!(Some(2), len(\"(b)+\")?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n#[inline]\npub fn static_captures_len(&self) -> Option<usize>{\n        self.0.static_captures_len().map(|len| len.saturating_add(1))\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Replacer":["/// Replacer describes types that can be used to replace matches in a byte\n/// string.\n///\n/// In general, users of this crate shouldn't need to implement this trait,\n/// since implementations are already provided for `&[u8]` along with other\n/// variants of bytes types and `FnMut(&Captures) -> Vec<u8>` (or any\n/// `FnMut(&Captures) -> T` where `T: AsRef<[u8]>`), which covers most use cases.\npub trait Replacer {\n    /// Appends text to `dst` to replace the current match.\n    ///\n    /// The current match is represented by `caps`, which is guaranteed to\n    /// have a match at capture group `0`.\n    ///\n    /// For example, a no-op replacement would be\n    /// `dst.extend(&caps[0])`.\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut Vec<u8>);\n\n    /// Return a fixed unchanging replacement byte string.\n    ///\n    /// When doing replacements, if access to `Captures` is not needed (e.g.,\n    /// the replacement byte string does not need `$` expansion), then it can\n    /// be beneficial to avoid finding sub-captures.\n    ///\n    /// In general, this is called once for every call to `replacen`.\n    fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> {\n        None\n    }\n\n    /// Return a `Replacer` that borrows and wraps this `Replacer`.\n    ///\n    /// This is useful when you want to take a generic `Replacer` (which might\n    /// not be cloneable) and use it without consuming it, so it can be used\n    /// more than once.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use regex::bytes::{Regex, Replacer};\n    ///\n    /// fn replace_all_twice<R: Replacer>(\n    ///     re: Regex,\n    ///     src: &[u8],\n    ///     mut rep: R,\n    /// ) -> Vec<u8> {\n    ///     let dst = re.replace_all(src, rep.by_ref());\n    ///     let dst = re.replace_all(&dst, rep.by_ref());\n    ///     dst.into_owned()\n    /// }\n    /// ```\n    fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> {\n        ReplacerRef(self)\n    }\n}","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Replacer::by_ref":["/// Return a `Replacer` that borrows and wraps this `Replacer`.\n///\n/// This is useful when you want to take a generic `Replacer` (which might\n/// not be cloneable) and use it without consuming it, so it can be used\n/// more than once.\n///\n/// # Example\n///\n/// ```\n/// use regex::bytes::{Regex, Replacer};\n///\n/// fn replace_all_twice<R: Replacer>(\n///     re: Regex,\n///     src: &[u8],\n///     mut rep: R,\n/// ) -> Vec<u8> {\n///     let dst = re.replace_all(src, rep.by_ref());\n///     let dst = re.replace_all(&dst, rep.by_ref());\n///     dst.into_owned()\n/// }\n/// ```\nfn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self>{\n        ReplacerRef(self)\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Replacer::no_expansion":["/// Return a fixed unchanging replacement byte string.\n///\n/// When doing replacements, if access to `Captures` is not needed (e.g.,\n/// the replacement byte string does not need `$` expansion), then it can\n/// be beneficial to avoid finding sub-captures.\n///\n/// In general, this is called once for every call to `replacen`.\nfn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>>{\n        None\n    }","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::ReplacerRef":["/// By-reference adaptor for a `Replacer`\n///\n/// Returned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref).\npub struct ReplacerRef<'a, R: ?Sized>(&'a mut R);","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::Split":["/// Yields all substrings delimited by a regular expression match.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the byte string being split.\npub struct Split<'r, 't> {\n    finder: Matches<'r, 't>,\n    last: usize,\n}","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::SplitN":["/// Yields at most `N` substrings delimited by a regular expression match.\n///\n/// The last substring will be whatever remains after splitting.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the byte string being split.\npub struct SplitN<'r, 't> {\n    splits: Split<'r, 't>,\n    n: usize,\n}","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::SubCaptureMatches":["/// An iterator that yields all capturing matches in the order in which they\n/// appear in the regex.\n///\n/// If a particular capture group didn't participate in the match, then `None`\n/// is yielded for that capture. The first match always corresponds to the\n/// overall match of the regex.\n///\n/// The lifetime `'c` corresponds to the lifetime of the `Captures` value, and\n/// the lifetime `'t` corresponds to the originally matched text.\npub struct SubCaptureMatches<'c, 't> {\n    caps: &'c Captures<'t>,\n    it: SubCapturesPosIter<'c>,\n}","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_bytes::no_expansion":["fn no_expansion<T: AsRef<[u8]>>(t: &T) -> Option<Cow<'_, [u8]>>{\n    let s = t.as_ref();\n    match find_byte(b'$', s) {\n        Some(_) => None,\n        None => Some(Cow::Borrowed(s)),\n    }\n}","Real(LocalPath(\"src/re_bytes.rs\"))"],"re_set::bytes::RegexSet":["/// Match multiple (possibly overlapping) regular expressions in a single scan.\n///\n/// A regex set corresponds to the union of two or more regular expressions.\n/// That is, a regex set will match text where at least one of its\n/// constituent regular expressions matches. A regex set as its formulated here\n/// provides a touch more power: it will also report *which* regular\n/// expressions in the set match. Indeed, this is the key difference between\n/// regex sets and a single `Regex` with many alternates, since only one\n/// alternate can match at a time.\n///\n/// For example, consider regular expressions to match email addresses and\n/// domains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\n/// regex set is constructed from those regexes, then searching the text\n/// `foo@example.com` will report both regexes as matching. Of course, one\n/// could accomplish this by compiling each regex on its own and doing two\n/// searches over the text. The key advantage of using a regex set is that it\n/// will report the matching regexes using a *single pass through the text*.\n/// If one has hundreds or thousands of regexes to match repeatedly (like a URL\n/// router for a complex web application or a user agent matcher), then a regex\n/// set can realize huge performance gains.\n///\n/// # Example\n///\n/// This shows how the above two regexes (for matching email addresses and\n/// domains) might work:\n///\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n///\n/// Note that it would be possible to adapt the above example to using `Regex`\n/// with an expression like:\n///\n/// ```text\n/// (?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n/// ```\n///\n/// After a match, one could then inspect the capture groups to figure out\n/// which alternates matched. The problem is that it is hard to make this\n/// approach scale when there are many regexes since the overlap between each\n/// alternate isn't always obvious to reason about.\n///\n/// # Limitations\n///\n/// Regex sets are limited to answering the following two questions:\n///\n/// 1. Does any regex in the set match?\n/// 2. If so, which regexes in the set match?\n///\n/// As with the main [`Regex`][crate::Regex] type, it is cheaper to ask (1)\n/// instead of (2) since the matching engines can stop after the first match\n/// is found.\n///\n/// You cannot directly extract [`Match`][crate::Match] or\n/// [`Captures`][crate::Captures] objects from a regex set. If you need these\n/// operations, the recommended approach is to compile each pattern in the set\n/// independently and scan the exact same input a second time with those\n/// independently compiled patterns:\n///\n/// ```rust\n/// use regex::{Regex, RegexSet};\n///\n/// let patterns = [\"foo\", \"bar\"];\n/// // Both patterns will match different ranges of this string.\n/// let text = \"barfoo\";\n///\n/// // Compile a set matching any of our patterns.\n/// let set = RegexSet::new(&patterns).unwrap();\n/// // Compile each pattern independently.\n/// let regexes: Vec<_> = set.patterns().iter()\n///     .map(|pat| Regex::new(pat).unwrap())\n///     .collect();\n///\n/// // Match against the whole set first and identify the individual\n/// // matching patterns.\n/// let matches: Vec<&str> = set.matches(text).into_iter()\n///     // Dereference the match index to get the corresponding\n///     // compiled pattern.\n///     .map(|match_idx| &regexes[match_idx])\n///     // To get match locations or any other info, we then have to search\n///     // the exact same text again, using our separately-compiled pattern.\n///     .map(|pat| pat.find(text).unwrap().as_str())\n///     .collect();\n///\n/// // Matches arrive in the order the constituent patterns were declared,\n/// // not the order they appear in the input.\n/// assert_eq!(vec![\"foo\", \"bar\"], matches);\n/// ```\n///\n/// # Performance\n///\n/// A `RegexSet` has the same performance characteristics as `Regex`. Namely,\n/// search takes `O(mn)` time, where `m` is proportional to the size of the\n/// regex set and `n` is proportional to the length of the search text.\npub struct RegexSet(Exec);","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::empty":["/// Create a new empty regex set.\n///\n/// # Example\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::empty();\n/// assert!(set.is_empty());\n/// ```\npub fn empty() -> RegexSet{\n        RegexSetBuilder::new(&[\"\"; 0]).build().unwrap()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::is_empty":["/// Returns `true` if this set contains no regular expressions.\npub fn is_empty(&self) -> bool{\n        self.0.regex_strings().is_empty()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::is_match":["/// Returns true if and only if one of the regexes in this set matches\n/// the text given.\n///\n/// This method should be preferred if you only need to test whether any\n/// of the regexes in the set should match, but don't care about *which*\n/// regexes matched. This is because the underlying matching engine will\n/// quit immediately after seeing the first match instead of continuing to\n/// find all matches.\n///\n/// Note that as with searches using `Regex`, the expression is unanchored\n/// by default. That is, if the regex does not start with `^` or `\\A`, or\n/// end with `$` or `\\z`, then it is permitted to match anywhere in the\n/// text.\n///\n/// # Example\n///\n/// Tests whether a set matches some text:\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n/// assert!(set.is_match(\"foo\"));\n/// assert!(!set.is_match(\"\"));\n/// ```\npub fn is_match(&self, text: $text_ty) -> bool{\n        self.is_match_at(text, 0)\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::is_match_at":["/// Returns the same as is_match, but starts the search at the given\n/// offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\n#[doc(hidden)]\npub fn is_match_at(&self, text: $text_ty, start: usize) -> bool{\n        self.0.searcher().is_match_at($as_bytes(text), start)\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::len":["/// Returns the total number of regular expressions in this set.\npub fn len(&self) -> usize{\n        self.0.regex_strings().len()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::matches":["/// Returns the set of regular expressions that match in the given text.\n///\n/// The set returned contains the index of each regular expression that\n/// matches in the given text. The index is in correspondence with the\n/// order of regular expressions given to `RegexSet`'s constructor.\n///\n/// The set can also be used to iterate over the matched indices.\n///\n/// Note that as with searches using `Regex`, the expression is unanchored\n/// by default. That is, if the regex does not start with `^` or `\\A`, or\n/// end with `$` or `\\z`, then it is permitted to match anywhere in the\n/// text.\n///\n/// # Example\n///\n/// Tests which regular expressions match the given text:\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[\n///     r\"\\w+\",\n///     r\"\\d+\",\n///     r\"\\pL+\",\n///     r\"foo\",\n///     r\"bar\",\n///     r\"barfoo\",\n///     r\"foobar\",\n/// ]).unwrap();\n/// let matches: Vec<_> = set.matches(\"foobar\").into_iter().collect();\n/// assert_eq!(matches, vec![0, 2, 3, 4, 6]);\n///\n/// // You can also test whether a particular regex matched:\n/// let matches = set.matches(\"foobar\");\n/// assert!(!matches.matched(5));\n/// assert!(matches.matched(6));\n/// ```\npub fn matches(&self, text: $text_ty) -> SetMatches{\n        let mut matches = vec![false; self.0.regex_strings().len()];\n        let any = self.read_matches_at(&mut matches, text, 0);\n        SetMatches {\n            matched_any: any,\n            matches: matches,\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::new":["/// Create a new regex set with the given regular expressions.\n///\n/// This takes an iterator of `S`, where `S` is something that can produce\n/// a `&str`. If any of the strings in the iterator are not valid regular\n/// expressions, then an error is returned.\n///\n/// # Example\n///\n/// Create a new regex set from an iterator of strings:\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n/// assert!(set.is_match(\"foo\"));\n/// ```\npub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>\n            where S: AsRef<str>, I: IntoIterator<Item=S>{\n        RegexSetBuilder::new(exprs).build()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::patterns":["/// Returns the patterns that this set will match on.\n///\n/// This function can be used to determine the pattern for a match. The\n/// slice returned has exactly as many patterns givens to this regex set,\n/// and the order of the slice is the same as the order of the patterns\n/// provided to the set.\n///\n/// # Example\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[\n///     r\"\\w+\",\n///     r\"\\d+\",\n///     r\"\\pL+\",\n///     r\"foo\",\n///     r\"bar\",\n///     r\"barfoo\",\n///     r\"foobar\",\n/// ]).unwrap();\n/// let matches: Vec<_> = set\n///     .matches(\"foobar\")\n///     .into_iter()\n///     .map(|match_idx| &set.patterns()[match_idx])\n///     .collect();\n/// assert_eq!(matches, vec![r\"\\w+\", r\"\\pL+\", r\"foo\", r\"bar\", r\"foobar\"]);\n/// ```\npub fn patterns(&self) -> &[String]{\n        self.0.regex_strings()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::RegexSet::read_matches_at":["/// Returns the same as matches, but starts the search at the given\n/// offset and stores the matches into the slice given.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\n///\n/// `matches` must have a length that is at least the number of regexes\n/// in this set.\n///\n/// This method returns true if and only if at least one member of\n/// `matches` is true after executing the set against `text`.\n#[doc(hidden)]\npub fn read_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: $text_ty,\n        start: usize,\n    ) -> bool{\n        self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::SetMatches":["/// A set of matches returned by a regex set.\npub struct SetMatches {\n    matched_any: bool,\n    matches: Vec<bool>,\n}","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::SetMatches::iter":["/// Returns an iterator over indexes in the regex that matched.\n///\n/// This will always produces matches in ascending order of index, where\n/// the index corresponds to the index of the regex that matched with\n/// respect to its position when initially building the set.\npub fn iter(&self) -> SetMatchesIter<'_>{\n        SetMatchesIter((&*self.matches).into_iter().enumerate())\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::SetMatches::len":["/// The total number of regexes in the set that created these matches.\n///\n/// **WARNING:** This always returns the same value as [`RegexSet::len`].\n/// In particular, it does *not* return the number of elements yielded by\n/// [`SetMatches::iter`]. The only way to determine the total number of\n/// matched regexes is to iterate over them.\npub fn len(&self) -> usize{\n        self.matches.len()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::SetMatches::matched":["/// Whether the regex at the given index matched.\n///\n/// The index for a regex is determined by its insertion order upon the\n/// initial construction of a `RegexSet`, starting at `0`.\n///\n/// # Panics\n///\n/// If `regex_index` is greater than or equal to `self.len()`.\npub fn matched(&self, regex_index: usize) -> bool{\n        self.matches[regex_index]\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::SetMatches::matched_any":["/// Whether this set contains any matches.\npub fn matched_any(&self) -> bool{\n        self.matched_any\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::SetMatchesIntoIter":["/// An owned iterator over the set of matches from a regex set.\n///\n/// This will always produces matches in ascending order of index, where the\n/// index corresponds to the index of the regex that matched with respect to\n/// its position when initially building the set.\npub struct SetMatchesIntoIter(iter::Enumerate<vec::IntoIter<bool>>);","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::SetMatchesIter":["/// A borrowed iterator over the set of matches from a regex set.\n///\n/// The lifetime `'a` refers to the lifetime of a `SetMatches` value.\n///\n/// This will always produces matches in ascending order of index, where the\n/// index corresponds to the index of the regex that matched with respect to\n/// its position when initially building the set.\npub struct SetMatchesIter<'a>(iter::Enumerate<slice::Iter<'a, bool>>);","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::as_bytes_bytes":["#[allow(dead_code)]\nfn as_bytes_bytes(text: &[u8]) -> &[u8]{ text }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::bytes::as_bytes_str":["#[allow(dead_code)]\nfn as_bytes_str(text: &str) -> &[u8]{ text.as_bytes() }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet":["/// Match multiple (possibly overlapping) regular expressions in a single scan.\n///\n/// A regex set corresponds to the union of two or more regular expressions.\n/// That is, a regex set will match text where at least one of its\n/// constituent regular expressions matches. A regex set as its formulated here\n/// provides a touch more power: it will also report *which* regular\n/// expressions in the set match. Indeed, this is the key difference between\n/// regex sets and a single `Regex` with many alternates, since only one\n/// alternate can match at a time.\n///\n/// For example, consider regular expressions to match email addresses and\n/// domains: `[a-z]+@[a-z]+\\.(com|org|net)` and `[a-z]+\\.(com|org|net)`. If a\n/// regex set is constructed from those regexes, then searching the text\n/// `foo@example.com` will report both regexes as matching. Of course, one\n/// could accomplish this by compiling each regex on its own and doing two\n/// searches over the text. The key advantage of using a regex set is that it\n/// will report the matching regexes using a *single pass through the text*.\n/// If one has hundreds or thousands of regexes to match repeatedly (like a URL\n/// router for a complex web application or a user agent matcher), then a regex\n/// set can realize huge performance gains.\n///\n/// # Example\n///\n/// This shows how the above two regexes (for matching email addresses and\n/// domains) might work:\n///\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n#[$doc_regexset_example]\n///\n/// Note that it would be possible to adapt the above example to using `Regex`\n/// with an expression like:\n///\n/// ```text\n/// (?P<email>[a-z]+@(?P<email_domain>[a-z]+[.](com|org|net)))|(?P<domain>[a-z]+[.](com|org|net))\n/// ```\n///\n/// After a match, one could then inspect the capture groups to figure out\n/// which alternates matched. The problem is that it is hard to make this\n/// approach scale when there are many regexes since the overlap between each\n/// alternate isn't always obvious to reason about.\n///\n/// # Limitations\n///\n/// Regex sets are limited to answering the following two questions:\n///\n/// 1. Does any regex in the set match?\n/// 2. If so, which regexes in the set match?\n///\n/// As with the main [`Regex`][crate::Regex] type, it is cheaper to ask (1)\n/// instead of (2) since the matching engines can stop after the first match\n/// is found.\n///\n/// You cannot directly extract [`Match`][crate::Match] or\n/// [`Captures`][crate::Captures] objects from a regex set. If you need these\n/// operations, the recommended approach is to compile each pattern in the set\n/// independently and scan the exact same input a second time with those\n/// independently compiled patterns:\n///\n/// ```rust\n/// use regex::{Regex, RegexSet};\n///\n/// let patterns = [\"foo\", \"bar\"];\n/// // Both patterns will match different ranges of this string.\n/// let text = \"barfoo\";\n///\n/// // Compile a set matching any of our patterns.\n/// let set = RegexSet::new(&patterns).unwrap();\n/// // Compile each pattern independently.\n/// let regexes: Vec<_> = set.patterns().iter()\n///     .map(|pat| Regex::new(pat).unwrap())\n///     .collect();\n///\n/// // Match against the whole set first and identify the individual\n/// // matching patterns.\n/// let matches: Vec<&str> = set.matches(text).into_iter()\n///     // Dereference the match index to get the corresponding\n///     // compiled pattern.\n///     .map(|match_idx| &regexes[match_idx])\n///     // To get match locations or any other info, we then have to search\n///     // the exact same text again, using our separately-compiled pattern.\n///     .map(|pat| pat.find(text).unwrap().as_str())\n///     .collect();\n///\n/// // Matches arrive in the order the constituent patterns were declared,\n/// // not the order they appear in the input.\n/// assert_eq!(vec![\"foo\", \"bar\"], matches);\n/// ```\n///\n/// # Performance\n///\n/// A `RegexSet` has the same performance characteristics as `Regex`. Namely,\n/// search takes `O(mn)` time, where `m` is proportional to the size of the\n/// regex set and `n` is proportional to the length of the search text.\npub struct RegexSet(Exec);","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::empty":["/// Create a new empty regex set.\n///\n/// # Example\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::empty();\n/// assert!(set.is_empty());\n/// ```\npub fn empty() -> RegexSet{\n        RegexSetBuilder::new(&[\"\"; 0]).build().unwrap()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::is_empty":["/// Returns `true` if this set contains no regular expressions.\npub fn is_empty(&self) -> bool{\n        self.0.regex_strings().is_empty()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::is_match":["/// Returns true if and only if one of the regexes in this set matches\n/// the text given.\n///\n/// This method should be preferred if you only need to test whether any\n/// of the regexes in the set should match, but don't care about *which*\n/// regexes matched. This is because the underlying matching engine will\n/// quit immediately after seeing the first match instead of continuing to\n/// find all matches.\n///\n/// Note that as with searches using `Regex`, the expression is unanchored\n/// by default. That is, if the regex does not start with `^` or `\\A`, or\n/// end with `$` or `\\z`, then it is permitted to match anywhere in the\n/// text.\n///\n/// # Example\n///\n/// Tests whether a set matches some text:\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n/// assert!(set.is_match(\"foo\"));\n/// assert!(!set.is_match(\"\"));\n/// ```\npub fn is_match(&self, text: $text_ty) -> bool{\n        self.is_match_at(text, 0)\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::is_match_at":["/// Returns the same as is_match, but starts the search at the given\n/// offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\n#[doc(hidden)]\npub fn is_match_at(&self, text: $text_ty, start: usize) -> bool{\n        self.0.searcher().is_match_at($as_bytes(text), start)\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::len":["/// Returns the total number of regular expressions in this set.\npub fn len(&self) -> usize{\n        self.0.regex_strings().len()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::matches":["/// Returns the set of regular expressions that match in the given text.\n///\n/// The set returned contains the index of each regular expression that\n/// matches in the given text. The index is in correspondence with the\n/// order of regular expressions given to `RegexSet`'s constructor.\n///\n/// The set can also be used to iterate over the matched indices.\n///\n/// Note that as with searches using `Regex`, the expression is unanchored\n/// by default. That is, if the regex does not start with `^` or `\\A`, or\n/// end with `$` or `\\z`, then it is permitted to match anywhere in the\n/// text.\n///\n/// # Example\n///\n/// Tests which regular expressions match the given text:\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[\n///     r\"\\w+\",\n///     r\"\\d+\",\n///     r\"\\pL+\",\n///     r\"foo\",\n///     r\"bar\",\n///     r\"barfoo\",\n///     r\"foobar\",\n/// ]).unwrap();\n/// let matches: Vec<_> = set.matches(\"foobar\").into_iter().collect();\n/// assert_eq!(matches, vec![0, 2, 3, 4, 6]);\n///\n/// // You can also test whether a particular regex matched:\n/// let matches = set.matches(\"foobar\");\n/// assert!(!matches.matched(5));\n/// assert!(matches.matched(6));\n/// ```\npub fn matches(&self, text: $text_ty) -> SetMatches{\n        let mut matches = vec![false; self.0.regex_strings().len()];\n        let any = self.read_matches_at(&mut matches, text, 0);\n        SetMatches {\n            matched_any: any,\n            matches: matches,\n        }\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::new":["/// Create a new regex set with the given regular expressions.\n///\n/// This takes an iterator of `S`, where `S` is something that can produce\n/// a `&str`. If any of the strings in the iterator are not valid regular\n/// expressions, then an error is returned.\n///\n/// # Example\n///\n/// Create a new regex set from an iterator of strings:\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[r\"\\w+\", r\"\\d+\"]).unwrap();\n/// assert!(set.is_match(\"foo\"));\n/// ```\npub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>\n            where S: AsRef<str>, I: IntoIterator<Item=S>{\n        RegexSetBuilder::new(exprs).build()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::patterns":["/// Returns the patterns that this set will match on.\n///\n/// This function can be used to determine the pattern for a match. The\n/// slice returned has exactly as many patterns givens to this regex set,\n/// and the order of the slice is the same as the order of the patterns\n/// provided to the set.\n///\n/// # Example\n///\n/// ```rust\n/// # use regex::RegexSet;\n/// let set = RegexSet::new(&[\n///     r\"\\w+\",\n///     r\"\\d+\",\n///     r\"\\pL+\",\n///     r\"foo\",\n///     r\"bar\",\n///     r\"barfoo\",\n///     r\"foobar\",\n/// ]).unwrap();\n/// let matches: Vec<_> = set\n///     .matches(\"foobar\")\n///     .into_iter()\n///     .map(|match_idx| &set.patterns()[match_idx])\n///     .collect();\n/// assert_eq!(matches, vec![r\"\\w+\", r\"\\pL+\", r\"foo\", r\"bar\", r\"foobar\"]);\n/// ```\npub fn patterns(&self) -> &[String]{\n        self.0.regex_strings()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::RegexSet::read_matches_at":["/// Returns the same as matches, but starts the search at the given\n/// offset and stores the matches into the slice given.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\n///\n/// `matches` must have a length that is at least the number of regexes\n/// in this set.\n///\n/// This method returns true if and only if at least one member of\n/// `matches` is true after executing the set against `text`.\n#[doc(hidden)]\npub fn read_matches_at(\n        &self,\n        matches: &mut [bool],\n        text: $text_ty,\n        start: usize,\n    ) -> bool{\n        self.0.searcher().many_matches_at(matches, $as_bytes(text), start)\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::SetMatches":["/// A set of matches returned by a regex set.\npub struct SetMatches {\n    matched_any: bool,\n    matches: Vec<bool>,\n}","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::SetMatches::iter":["/// Returns an iterator over indexes in the regex that matched.\n///\n/// This will always produces matches in ascending order of index, where\n/// the index corresponds to the index of the regex that matched with\n/// respect to its position when initially building the set.\npub fn iter(&self) -> SetMatchesIter<'_>{\n        SetMatchesIter((&*self.matches).into_iter().enumerate())\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::SetMatches::len":["/// The total number of regexes in the set that created these matches.\n///\n/// **WARNING:** This always returns the same value as [`RegexSet::len`].\n/// In particular, it does *not* return the number of elements yielded by\n/// [`SetMatches::iter`]. The only way to determine the total number of\n/// matched regexes is to iterate over them.\npub fn len(&self) -> usize{\n        self.matches.len()\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::SetMatches::matched":["/// Whether the regex at the given index matched.\n///\n/// The index for a regex is determined by its insertion order upon the\n/// initial construction of a `RegexSet`, starting at `0`.\n///\n/// # Panics\n///\n/// If `regex_index` is greater than or equal to `self.len()`.\npub fn matched(&self, regex_index: usize) -> bool{\n        self.matches[regex_index]\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::SetMatches::matched_any":["/// Whether this set contains any matches.\npub fn matched_any(&self) -> bool{\n        self.matched_any\n    }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::SetMatchesIntoIter":["/// An owned iterator over the set of matches from a regex set.\n///\n/// This will always produces matches in ascending order of index, where the\n/// index corresponds to the index of the regex that matched with respect to\n/// its position when initially building the set.\npub struct SetMatchesIntoIter(iter::Enumerate<vec::IntoIter<bool>>);","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::SetMatchesIter":["/// A borrowed iterator over the set of matches from a regex set.\n///\n/// The lifetime `'a` refers to the lifetime of a `SetMatches` value.\n///\n/// This will always produces matches in ascending order of index, where the\n/// index corresponds to the index of the regex that matched with respect to\n/// its position when initially building the set.\npub struct SetMatchesIter<'a>(iter::Enumerate<slice::Iter<'a, bool>>);","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::as_bytes_bytes":["#[allow(dead_code)]\nfn as_bytes_bytes(text: &[u8]) -> &[u8]{ text }","Real(LocalPath(\"src/re_set.rs\"))"],"re_set::unicode::as_bytes_str":["#[allow(dead_code)]\nfn as_bytes_str(text: &str) -> &[u8]{ text.as_bytes() }","Real(LocalPath(\"src/re_set.rs\"))"],"re_trait::CaptureMatches":["/// An iterator over all non-overlapping successive leftmost-first matches with\n/// captures.\npub struct CaptureMatches<'t, R>(Matches<'t, R>)\nwhere\n    R: RegularExpression,\n    R::Text: 't;","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::CaptureMatches::<'t, R>::regex":["/// Return the underlying regex.\npub fn regex(&self) -> &R{\n        self.0.regex()\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::CaptureMatches::<'t, R>::text":["/// Return the text being searched.\npub fn text(&self) -> &'t R::Text{\n        self.0.text()\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::Locations":["/// Locations represents the offsets of each capturing group in a regex for\n/// a single match.\n///\n/// Unlike `Captures`, a `Locations` value only stores offsets.\n#[doc(hidden)]\npub struct Locations(Vec<Slot>);","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::Locations::as_slots":["/// Return the individual slots as a slice.\npub(crate) fn as_slots(&mut self) -> &mut [Slot]{\n        &mut self.0\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::Locations::iter":["/// Creates an iterator of all the capture group positions in order of\n/// appearance in the regular expression. Positions are byte indices\n/// in terms of the original string matched.\npub fn iter(&self) -> SubCapturesPosIter<'_>{\n        SubCapturesPosIter { idx: 0, locs: self }\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::Locations::len":["/// Returns the total number of capturing groups.\n///\n/// This is always at least `1` since every regex has at least `1`\n/// capturing group that corresponds to the entire match.\npub fn len(&self) -> usize{\n        self.0.len() / 2\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::Locations::pos":["/// Returns the start and end positions of the Nth capture group. Returns\n/// `None` if `i` is not a valid capture group or if the capture group did\n/// not match anything. The positions returned are *always* byte indices\n/// with respect to the original string matched.\npub fn pos(&self, i: usize) -> Option<(usize, usize)>{\n        let (s, e) = (i.checked_mul(2)?, i.checked_mul(2)?.checked_add(1)?);\n        match (self.0.get(s), self.0.get(e)) {\n            (Some(&Some(s)), Some(&Some(e))) => Some((s, e)),\n            _ => None,\n        }\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::Matches":["/// An iterator over all non-overlapping successive leftmost-first matches.\npub struct Matches<'t, R>\nwhere\n    R: RegularExpression,\n    R::Text: 't,\n{\n    re: R,\n    text: &'t R::Text,\n    last_end: usize,\n    last_match: Option<usize>,\n}","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::Matches::<'t, R>::regex":["/// Return the underlying regex.\npub fn regex(&self) -> &R{\n        &self.re\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::Matches::<'t, R>::text":["/// Return the text being searched.\npub fn text(&self) -> &'t R::Text{\n        self.text\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::RegularExpression":["/// `RegularExpression` describes types that can implement regex searching.\n///\n/// This trait is my attempt at reducing code duplication and to standardize\n/// the internal API. Specific duplication that is avoided are the `find`\n/// and `capture` iterators, which are slightly tricky.\n///\n/// It's not clear whether this trait is worth it, and it also isn't\n/// clear whether it's useful as a public trait or not. Methods like\n/// `next_after_empty` reak of bad design, but the rest of the methods seem\n/// somewhat reasonable. One particular thing this trait would expose would be\n/// the ability to start the search of a regex anywhere in a haystack, which\n/// isn't possible in the current public API.\npub trait RegularExpression: Sized + fmt::Debug {\n    /// The type of the haystack.\n    type Text: ?Sized + fmt::Debug;\n\n    /// The number of capture slots in the compiled regular expression. This is\n    /// always two times the number of capture groups (two slots per group).\n    fn slots_len(&self) -> usize;\n\n    /// Allocates fresh space for all capturing groups in this regex.\n    fn locations(&self) -> Locations {\n        Locations(vec![None; self.slots_len()])\n    }\n\n    /// Returns the position of the next character after `i`.\n    ///\n    /// For example, a haystack with type `&[u8]` probably returns `i+1`,\n    /// whereas a haystack with type `&str` probably returns `i` plus the\n    /// length of the next UTF-8 sequence.\n    fn next_after_empty(&self, text: &Self::Text, i: usize) -> usize;\n\n    /// Returns the location of the shortest match.\n    fn shortest_match_at(\n        &self,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<usize>;\n\n    /// Returns whether the regex matches the text given.\n    fn is_match_at(&self, text: &Self::Text, start: usize) -> bool;\n\n    /// Returns the leftmost-first match location if one exists.\n    fn find_at(\n        &self,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<(usize, usize)>;\n\n    /// Returns the leftmost-first match location if one exists, and also\n    /// fills in any matching capture slot locations.\n    fn captures_read_at(\n        &self,\n        locs: &mut Locations,\n        text: &Self::Text,\n        start: usize,\n    ) -> Option<(usize, usize)>;\n\n    /// Returns an iterator over all non-overlapping successive leftmost-first\n    /// matches.\n    fn find_iter(self, text: &Self::Text) -> Matches<'_, Self> {\n        Matches { re: self, text, last_end: 0, last_match: None }\n    }\n\n    /// Returns an iterator over all non-overlapping successive leftmost-first\n    /// matches with captures.\n    fn captures_iter(self, text: &Self::Text) -> CaptureMatches<'_, Self> {\n        CaptureMatches(self.find_iter(text))\n    }\n}","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::RegularExpression::captures_iter":["/// Returns an iterator over all non-overlapping successive leftmost-first\n/// matches with captures.\nfn captures_iter(self, text: &Self::Text) -> CaptureMatches<'_, Self>{\n        CaptureMatches(self.find_iter(text))\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::RegularExpression::find_iter":["/// Returns an iterator over all non-overlapping successive leftmost-first\n/// matches.\nfn find_iter(self, text: &Self::Text) -> Matches<'_, Self>{\n        Matches { re: self, text, last_end: 0, last_match: None }\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::RegularExpression::locations":["/// Allocates fresh space for all capturing groups in this regex.\nfn locations(&self) -> Locations{\n        Locations(vec![None; self.slots_len()])\n    }","Real(LocalPath(\"src/re_trait.rs\"))"],"re_trait::SubCapturesPosIter":["/// An iterator over capture group positions for a particular match of a\n/// regular expression.\n///\n/// Positions are byte indices in terms of the original string matched.\n///\n/// `'c` is the lifetime of the captures.\npub struct SubCapturesPosIter<'c> {\n    idx: usize,\n    locs: &'c Locations,\n}","Real(LocalPath(\"src/re_trait.rs\"))"],"re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from":["fn from(m: Match<'t>) -> &'t str{\n        m.as_str()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from":["fn from(m: Match<'t>) -> Range<usize>{\n        m.range()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::CaptureLocations":["/// CaptureLocations is a low level representation of the raw offsets of each\n/// submatch.\n///\n/// You can think of this as a lower level\n/// [`Captures`](struct.Captures.html), where this type does not support\n/// named capturing groups directly and it does not borrow the text that these\n/// offsets were matched on.\n///\n/// Primarily, this type is useful when using the lower level `Regex` APIs\n/// such as `read_captures`, which permits amortizing the allocation in which\n/// capture match locations are stored.\n///\n/// In order to build a value of this type, you'll need to call the\n/// `capture_locations` method on the `Regex` being used to execute the search.\n/// The value returned can then be reused in subsequent searches.\n///\n/// # Example\n///\n/// This example shows how to create and use `CaptureLocations` in a search.\n///\n/// ```\n/// use regex::Regex;\n///\n/// let re = Regex::new(r\"(?<first>\\w+)\\s+(?<last>\\w+)\").unwrap();\n/// let mut locs = re.capture_locations();\n/// let m = re.captures_read(&mut locs, \"Bruce Springsteen\").unwrap();\n/// assert_eq!(0..17, m.range());\n/// assert_eq!(Some((0, 17)), locs.get(0));\n/// assert_eq!(Some((0, 5)), locs.get(1));\n/// assert_eq!(Some((6, 17)), locs.get(2));\n///\n/// // Asking for an invalid capture group always returns None.\n/// assert_eq!(None, locs.get(3));\n/// assert_eq!(None, locs.get(34973498648));\n/// assert_eq!(None, locs.get(9944060567225171988));\n/// ```\npub struct CaptureLocations(re_trait::Locations);","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::CaptureLocations::get":["/// Returns the start and end positions of the Nth capture group. Returns\n/// `None` if `i` is not a valid capture group or if the capture group did\n/// not match anything. The positions returned are *always* byte indices\n/// with respect to the original string matched.\n#[inline]\npub fn get(&self, i: usize) -> Option<(usize, usize)>{\n        self.0.pos(i)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::CaptureLocations::len":["/// Returns the total number of capture groups (even if they didn't match).\n///\n/// This is always at least `1` since every regex has at least `1`\n/// capturing group that corresponds to the entire match.\n#[inline]\npub fn len(&self) -> usize{\n        self.0.len()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::CaptureLocations::pos":["/// An alias for the `get` method for backwards compatibility.\n///\n/// Previously, we exported `get` as `pos` in an undocumented API. To\n/// prevent breaking that code (e.g., in `regex-capi`), we continue\n/// re-exporting the same undocumented API.\n#[doc(hidden)]\n#[inline]\npub fn pos(&self, i: usize) -> Option<(usize, usize)>{\n        self.get(i)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::CaptureMatches":["/// An iterator that yields all non-overlapping capture groups matching a\n/// particular regular expression.\n///\n/// The iterator stops when no more matches can be found.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the matched string.\npub struct CaptureMatches<'r, 't>(\n    re_trait::CaptureMatches<'t, ExecNoSyncStr<'r>>,\n);","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::CaptureNames":["/// An iterator over the names of all possible captures.\n///\n/// `None` indicates an unnamed capture; the first element (capture 0, the\n/// whole matched region) is always unnamed.\n///\n/// `'r` is the lifetime of the compiled regular expression.\npub struct CaptureNames<'r>(::std::slice::Iter<'r, Option<String>>);","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Captures":["/// Captures represents a group of captured strings for a single match.\n///\n/// The 0th capture always corresponds to the entire match. Each subsequent\n/// index corresponds to the next capture group in the regex. If a capture\n/// group is named, then the matched string is *also* available via the `name`\n/// method. (Note that the 0th capture is always unnamed and so must be\n/// accessed with the `get` method.)\n///\n/// Positions returned from a capture group are always byte indices.\n///\n/// `'t` is the lifetime of the matched text.\npub struct Captures<'t> {\n    text: &'t str,\n    locs: re_trait::Locations,\n    named_groups: Arc<HashMap<String, usize>>,\n}","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Captures::<'t>::expand":["/// Expands all instances of `$name` in `replacement` to the corresponding\n/// capture group `name`, and writes them to the `dst` buffer given.\n///\n/// `name` may be an integer corresponding to the index of the capture\n/// group (counted by order of opening parenthesis where `0` is the\n/// entire match) or it can be a name (consisting of letters, digits or\n/// underscores) corresponding to a named capture group.\n///\n/// If `name` isn't a valid capture group (whether the name doesn't exist\n/// or isn't a valid index), then it is replaced with the empty string.\n///\n/// The longest possible name consisting of the characters `[_0-9A-Za-z]`\n/// is used. e.g., `$1a` looks up the capture group named `1a` and not the\n/// capture group at index `1`. To exert more precise control over the\n/// name, or to refer to a capture group name that uses characters outside\n/// of `[_0-9A-Za-z]`, use braces, e.g., `${1}a` or `${foo[bar].baz}`. When\n/// using braces, any sequence of characters is permitted. If the sequence\n/// does not refer to a capture group name in the corresponding regex, then\n/// it is replaced with an empty string.\n///\n/// To write a literal `$` use `$$`.\npub fn expand(&self, replacement: &str, dst: &mut String){\n        expand_str(self, replacement, dst)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Captures::<'t>::get":["/// Returns the match associated with the capture group at index `i`. If\n/// `i` does not correspond to a capture group, or if the capture group\n/// did not participate in the match, then `None` is returned.\n///\n/// # Examples\n///\n/// Get the text of the match with a default of an empty string if this\n/// group didn't participate in the match:\n///\n/// ```rust\n/// # use regex::Regex;\n/// let re = Regex::new(r\"[a-z]+(?:([0-9]+)|([A-Z]+))\").unwrap();\n/// let caps = re.captures(\"abc123\").unwrap();\n///\n/// let text1 = caps.get(1).map_or(\"\", |m| m.as_str());\n/// let text2 = caps.get(2).map_or(\"\", |m| m.as_str());\n/// assert_eq!(text1, \"123\");\n/// assert_eq!(text2, \"\");\n/// ```\npub fn get(&self, i: usize) -> Option<Match<'t>>{\n        self.locs.pos(i).map(|(s, e)| Match::new(self.text, s, e))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Captures::<'t>::iter":["/// An iterator that yields all capturing matches in the order in which\n/// they appear in the regex. If a particular capture group didn't\n/// participate in the match, then `None` is yielded for that capture.\n///\n/// The first match always corresponds to the overall match of the regex.\npub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 't>{\n        SubCaptureMatches { caps: self, it: self.locs.iter() }\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Captures::<'t>::len":["/// Returns the total number of capture groups (even if they didn't match).\n///\n/// This is always at least `1`, since every regex has at least one capture\n/// group that corresponds to the full match.\n#[inline]\npub fn len(&self) -> usize{\n        self.locs.len()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Captures::<'t>::name":["/// Returns the match for the capture group named `name`. If `name` isn't a\n/// valid capture group or didn't match anything, then `None` is returned.\npub fn name(&self, name: &str) -> Option<Match<'t>>{\n        self.named_groups.get(name).and_then(|&i| self.get(i))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::CapturesDebug":["struct CapturesDebug<'c, 't>(&'c Captures<'t>);","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Match":["/// Match represents a single match of a regex in a haystack.\n///\n/// The lifetime parameter `'t` refers to the lifetime of the matched text.\npub struct Match<'t> {\n    text: &'t str,\n    start: usize,\n    end: usize,\n}","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Match::<'t>::as_str":["/// Returns the matched text.\n#[inline]\npub fn as_str(&self) -> &'t str{\n        &self.text[self.range()]\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Match::<'t>::end":["/// Returns the ending byte offset of the match in the haystack.\n#[inline]\npub fn end(&self) -> usize{\n        self.end\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Match::<'t>::is_empty":["/// Returns true if and only if this match has a length of zero.\n#[inline]\npub fn is_empty(&self) -> bool{\n        self.start == self.end\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Match::<'t>::len":["/// Returns the length, in bytes, of this match.\n#[inline]\npub fn len(&self) -> usize{\n        self.end - self.start\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Match::<'t>::new":["/// Creates a new match from the given haystack and byte offsets.\n#[inline]\nfn new(haystack: &'t str, start: usize, end: usize) -> Match<'t>{\n        Match { text: haystack, start, end }\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Match::<'t>::range":["/// Returns the range over the starting and ending byte offsets of the\n/// match in the haystack.\n#[inline]\npub fn range(&self) -> Range<usize>{\n        self.start..self.end\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Match::<'t>::start":["/// Returns the starting byte offset of the match in the haystack.\n#[inline]\npub fn start(&self) -> usize{\n        self.start\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Matches":["/// An iterator over all non-overlapping matches for a particular string.\n///\n/// The iterator yields a `Match` value. The iterator stops when no more\n/// matches can be found.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the matched string.\npub struct Matches<'r, 't>(re_trait::Matches<'t, ExecNoSyncStr<'r>>);","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::NoExpand":["/// `NoExpand` indicates literal string replacement.\n///\n/// It can be used with `replace` and `replace_all` to do a literal string\n/// replacement without expanding `$name` to their corresponding capture\n/// groups. This can be both convenient (to avoid escaping `$`, for example)\n/// and performant (since capture groups don't need to be found).\n///\n/// `'t` is the lifetime of the literal text.\npub struct NoExpand<'t>(pub &'t str);","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex":["/// A compiled regular expression for matching Unicode strings.\n///\n/// It is represented as either a sequence of bytecode instructions (dynamic)\n/// or as a specialized Rust function (native). It can be used to search, split\n/// or replace text. All searching is done with an implicit `.*?` at the\n/// beginning and end of an expression. To force an expression to match the\n/// whole string (or a prefix or a suffix), you must use an anchor like `^` or\n/// `$` (or `\\A` and `\\z`).\n///\n/// While this crate will handle Unicode strings (whether in the regular\n/// expression or in the search text), all positions returned are **byte\n/// indices**. Every byte index is guaranteed to be at a Unicode code point\n/// boundary.\n///\n/// The lifetimes `'r` and `'t` in this crate correspond to the lifetime of a\n/// compiled regular expression and text to search, respectively.\n///\n/// The only methods that allocate new strings are the string replacement\n/// methods. All other methods (searching and splitting) return borrowed\n/// pointers into the string given.\n///\n/// # Examples\n///\n/// Find the location of a US phone number:\n///\n/// ```rust\n/// # use regex::Regex;\n/// let re = Regex::new(\"[0-9]{3}-[0-9]{3}-[0-9]{4}\").unwrap();\n/// let mat = re.find(\"phone: 111-222-3333\").unwrap();\n/// assert_eq!((mat.start(), mat.end()), (7, 19));\n/// ```\n///\n/// # Using the `std::str::pattern` methods with `Regex`\n///\n/// > **Note**: This section requires that this crate is compiled with the\n/// > `pattern` Cargo feature enabled, which **requires nightly Rust**.\n///\n/// Since `Regex` implements `Pattern`, you can use regexes with methods\n/// defined on `&str`. For example, `is_match`, `find`, `find_iter`\n/// and `split` can be replaced with `str::contains`, `str::find`,\n/// `str::match_indices` and `str::split`.\n///\n/// Here are some examples:\n///\n/// ```rust,ignore\n/// # use regex::Regex;\n/// let re = Regex::new(r\"\\d+\").unwrap();\n/// let haystack = \"a111b222c\";\n///\n/// assert!(haystack.contains(&re));\n/// assert_eq!(haystack.find(&re), Some(1));\n/// assert_eq!(haystack.match_indices(&re).collect::<Vec<_>>(),\n///            vec![(1, \"111\"), (5, \"222\")]);\n/// assert_eq!(haystack.split(&re).collect::<Vec<_>>(), vec![\"a\", \"b\", \"c\"]);\n/// ```\npub struct Regex(Exec);","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::as_str":["/// Returns the original string of this regex.\npub fn as_str(&self) -> &str{\n        &self.0.regex_strings()[0]\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::capture_locations":["/// Returns an empty set of capture locations that can be reused in\n/// multiple calls to `captures_read` or `captures_read_at`.\npub fn capture_locations(&self) -> CaptureLocations{\n        CaptureLocations(self.0.searcher_str().locations())\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::capture_names":["/// Returns an iterator over the capture names.\npub fn capture_names(&self) -> CaptureNames<'_>{\n        CaptureNames(self.0.capture_names().iter())\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::captures":["/// Returns the capture groups corresponding to the leftmost-first\n/// match in `text`. Capture group `0` always corresponds to the entire\n/// match. If no match is found, then `None` is returned.\n///\n/// You should only use `captures` if you need access to the location of\n/// capturing group matches. Otherwise, `find` is faster for discovering\n/// the location of the overall match.\n///\n/// # Examples\n///\n/// Say you have some text with movie names and their release years,\n/// like \"'Citizen Kane' (1941)\". It'd be nice if we could search for text\n/// looking like that, while also extracting the movie name and its release\n/// year separately.\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"'([^']+)'\\s+\\((\\d{4})\\)\").unwrap();\n/// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let caps = re.captures(text).unwrap();\n/// assert_eq!(caps.get(1).unwrap().as_str(), \"Citizen Kane\");\n/// assert_eq!(caps.get(2).unwrap().as_str(), \"1941\");\n/// assert_eq!(caps.get(0).unwrap().as_str(), \"'Citizen Kane' (1941)\");\n/// // You can also access the groups by index using the Index notation.\n/// // Note that this will panic on an invalid index.\n/// assert_eq!(&caps[1], \"Citizen Kane\");\n/// assert_eq!(&caps[2], \"1941\");\n/// assert_eq!(&caps[0], \"'Citizen Kane' (1941)\");\n/// # }\n/// ```\n///\n/// Note that the full match is at capture group `0`. Each subsequent\n/// capture group is indexed by the order of its opening `(`.\n///\n/// We can make this example a bit clearer by using *named* capture groups:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n///                .unwrap();\n/// let text = \"Not my favorite movie: 'Citizen Kane' (1941).\";\n/// let caps = re.captures(text).unwrap();\n/// assert_eq!(caps.name(\"title\").unwrap().as_str(), \"Citizen Kane\");\n/// assert_eq!(caps.name(\"year\").unwrap().as_str(), \"1941\");\n/// assert_eq!(caps.get(0).unwrap().as_str(), \"'Citizen Kane' (1941)\");\n/// // You can also access the groups by name using the Index notation.\n/// // Note that this will panic on an invalid group name.\n/// assert_eq!(&caps[\"title\"], \"Citizen Kane\");\n/// assert_eq!(&caps[\"year\"], \"1941\");\n/// assert_eq!(&caps[0], \"'Citizen Kane' (1941)\");\n///\n/// # }\n/// ```\n///\n/// Here we name the capture groups, which we can access with the `name`\n/// method or the `Index` notation with a `&str`. Note that the named\n/// capture groups are still accessible with `get` or the `Index` notation\n/// with a `usize`.\n///\n/// The `0`th capture group is always unnamed, so it must always be\n/// accessed with `get(0)` or `[0]`.\npub fn captures<'t>(&self, text: &'t str) -> Option<Captures<'t>>{\n        self.captures_at(text, 0)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::captures_at":["/// Returns the same as [`Regex::captures`], but starts the search at the\n/// given offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn captures_at<'t>(\n        &self,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Captures<'t>>{\n        let mut locs = self.capture_locations();\n        self.captures_read_at(&mut locs, text, start).map(move |_| Captures {\n            text,\n            locs: locs.0,\n            named_groups: self.0.capture_name_idx().clone(),\n        })\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::captures_iter":["/// Returns an iterator over all the non-overlapping capture groups matched\n/// in `text`. This is operationally the same as `find_iter`, except it\n/// yields information about capturing group matches.\n///\n/// # Example\n///\n/// We can use this to find all movie titles and their release years in\n/// some text, where the movie is formatted like \"'Title' (xxxx)\":\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"'(?P<title>[^']+)'\\s+\\((?P<year>\\d{4})\\)\")\n///                .unwrap();\n/// let text = \"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931).\";\n/// for caps in re.captures_iter(text) {\n///     println!(\"Movie: {:?}, Released: {:?}\",\n///              &caps[\"title\"], &caps[\"year\"]);\n/// }\n/// // Output:\n/// // Movie: Citizen Kane, Released: 1941\n/// // Movie: The Wizard of Oz, Released: 1939\n/// // Movie: M, Released: 1931\n/// # }\n/// ```\npub fn captures_iter<'r, 't>(\n        &'r self,\n        text: &'t str,\n    ) -> CaptureMatches<'r, 't>{\n        CaptureMatches(self.0.searcher_str().captures_iter(text))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::captures_len":["/// Returns the number of captures.\npub fn captures_len(&self) -> usize{\n        self.0.capture_names().len()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::captures_read":["/// This is like `captures`, but uses\n/// [`CaptureLocations`](struct.CaptureLocations.html)\n/// instead of\n/// [`Captures`](struct.Captures.html) in order to amortize allocations.\n///\n/// To create a `CaptureLocations` value, use the\n/// `Regex::capture_locations` method.\n///\n/// This returns the overall match if this was successful, which is always\n/// equivalence to the `0`th capture group.\npub fn captures_read<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n    ) -> Option<Match<'t>>{\n        self.captures_read_at(locs, text, 0)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::captures_read_at":["/// Returns the same as captures, but starts the search at the given\n/// offset and populates the capture locations given.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn captures_read_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>>{\n        self.0\n            .searcher_str()\n            .captures_read_at(&mut locs.0, text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::find":["/// Returns the start and end byte range of the leftmost-first match in\n/// `text`. If no match exists, then `None` is returned.\n///\n/// Note that this should only be used if you want to discover the position\n/// of the match. Testing the existence of a match is faster if you use\n/// `is_match`.\n///\n/// # Example\n///\n/// Find the start and end location of the first word with exactly 13\n/// Unicode word characters:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let text = \"I categorically deny having triskaidekaphobia.\";\n/// let mat = Regex::new(r\"\\b\\w{13}\\b\").unwrap().find(text).unwrap();\n/// assert_eq!(mat.start(), 2);\n/// assert_eq!(mat.end(), 15);\n/// # }\n/// ```\npub fn find<'t>(&self, text: &'t str) -> Option<Match<'t>>{\n        self.find_at(text, 0)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::find_at":["/// Returns the same as find, but starts the search at the given\n/// offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn find_at<'t>(\n        &self,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>>{\n        self.0\n            .searcher_str()\n            .find_at(text, start)\n            .map(|(s, e)| Match::new(text, s, e))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::find_iter":["/// Returns an iterator for each successive non-overlapping match in\n/// `text`, returning the start and end byte indices with respect to\n/// `text`.\n///\n/// # Example\n///\n/// Find the start and end location of every word with exactly 13 Unicode\n/// word characters:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let text = \"Retroactively relinquishing remunerations is reprehensible.\";\n/// for mat in Regex::new(r\"\\b\\w{13}\\b\").unwrap().find_iter(text) {\n///     println!(\"{:?}\", mat);\n/// }\n/// # }\n/// ```\npub fn find_iter<'r, 't>(&'r self, text: &'t str) -> Matches<'r, 't>{\n        Matches(self.0.searcher_str().find_iter(text))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::is_match":["/// Returns true if and only if there is a match for the regex in the\n/// string given.\n///\n/// It is recommended to use this method if all you need to do is test\n/// a match, since the underlying matching engine may be able to do less\n/// work.\n///\n/// # Example\n///\n/// Test if some text contains at least one word with exactly 13\n/// Unicode word characters:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let text = \"I categorically deny having triskaidekaphobia.\";\n/// assert!(Regex::new(r\"\\b\\w{13}\\b\").unwrap().is_match(text));\n/// # }\n/// ```\npub fn is_match(&self, text: &str) -> bool{\n        self.is_match_at(text, 0)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::is_match_at":["/// Returns the same as is_match, but starts the search at the given\n/// offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only\n/// match when `start == 0`.\npub fn is_match_at(&self, text: &str, start: usize) -> bool{\n        self.0.searcher_str().is_match_at(text, start)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::locations":["/// An alias for `capture_locations` to preserve backward compatibility.\n///\n/// The `regex-capi` crate uses this method, so to avoid breaking that\n/// crate, we continue to export it as an undocumented API.\n#[doc(hidden)]\npub fn locations(&self) -> CaptureLocations{\n        CaptureLocations(self.0.searcher_str().locations())\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::new":["/// Compiles a regular expression. Once compiled, it can be used repeatedly\n/// to search, split or replace text in a string.\n///\n/// If an invalid expression is given, then an error is returned.\npub fn new(re: &str) -> Result<Regex, Error>{\n        RegexBuilder::new(re).build()\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::read_captures_at":["/// An undocumented alias for `captures_read_at`.\n///\n/// The `regex-capi` crate previously used this routine, so to avoid\n/// breaking that crate, we continue to provide the name as an undocumented\n/// alias.\n#[doc(hidden)]\npub fn read_captures_at<'t>(\n        &self,\n        locs: &mut CaptureLocations,\n        text: &'t str,\n        start: usize,\n    ) -> Option<Match<'t>>{\n        self.captures_read_at(locs, text, start)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::replace":["/// Replaces the leftmost-first match with the replacement provided.\n/// The replacement can be a regular string (where `$N` and `$name` are\n/// expanded to match capture groups) or a function that takes the matches'\n/// `Captures` and returns the replaced string.\n///\n/// If no match is found, then a copy of the string is returned unchanged.\n///\n/// # Replacement string syntax\n///\n/// All instances of `$name` in the replacement text is replaced with the\n/// corresponding capture group `name`.\n///\n/// `name` may be an integer corresponding to the index of the\n/// capture group (counted by order of opening parenthesis where `0` is the\n/// entire match) or it can be a name (consisting of letters, digits or\n/// underscores) corresponding to a named capture group.\n///\n/// If `name` isn't a valid capture group (whether the name doesn't exist\n/// or isn't a valid index), then it is replaced with the empty string.\n///\n/// The longest possible name is used. e.g., `$1a` looks up the capture\n/// group named `1a` and not the capture group at index `1`. To exert more\n/// precise control over the name, use braces, e.g., `${1}a`.\n///\n/// To write a literal `$` use `$$`.\n///\n/// # Examples\n///\n/// Note that this function is polymorphic with respect to the replacement.\n/// In typical usage, this can just be a normal string:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(\"[^01]+\").unwrap();\n/// assert_eq!(re.replace(\"1078910\", \"\"), \"1010\");\n/// # }\n/// ```\n///\n/// But anything satisfying the `Replacer` trait will work. For example,\n/// a closure of type `|&Captures| -> String` provides direct access to the\n/// captures corresponding to a match. This allows one to access\n/// capturing group matches easily:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # use regex::Captures; fn main() {\n/// let re = Regex::new(r\"([^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", |caps: &Captures| {\n///     format!(\"{} {}\", &caps[2], &caps[1])\n/// });\n/// assert_eq!(result, \"Bruce Springsteen\");\n/// # }\n/// ```\n///\n/// But this is a bit cumbersome to use all the time. Instead, a simple\n/// syntax is supported that expands `$name` into the corresponding capture\n/// group. Here's the last example, but using this expansion technique\n/// with named capture groups:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(?P<first>\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", \"$first $last\");\n/// assert_eq!(result, \"Bruce Springsteen\");\n/// # }\n/// ```\n///\n/// Note that using `$2` instead of `$first` or `$1` instead of `$last`\n/// would produce the same result. To write a literal `$` use `$$`.\n///\n/// Sometimes the replacement string requires use of curly braces to\n/// delineate a capture group replacement and surrounding literal text.\n/// For example, if we wanted to join two words together with an\n/// underscore:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"(?P<first>\\w+)\\s+(?P<second>\\w+)\").unwrap();\n/// let result = re.replace(\"deep fried\", \"${first}_$second\");\n/// assert_eq!(result, \"deep_fried\");\n/// # }\n/// ```\n///\n/// Without the curly braces, the capture group name `first_` would be\n/// used, and since it doesn't exist, it would be replaced with the empty\n/// string.\n///\n/// Finally, sometimes you just want to replace a literal string with no\n/// regard for capturing group expansion. This can be done by wrapping a\n/// byte string with `NoExpand`:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// use regex::NoExpand;\n///\n/// let re = Regex::new(r\"(?P<last>[^,\\s]+),\\s+(\\S+)\").unwrap();\n/// let result = re.replace(\"Springsteen, Bruce\", NoExpand(\"$2 $last\"));\n/// assert_eq!(result, \"$2 $last\");\n/// # }\n/// ```\npub fn replace<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        rep: R,\n    ) -> Cow<'t, str>{\n        self.replacen(text, 1, rep)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::replace_all":["/// Replaces all non-overlapping matches in `text` with the replacement\n/// provided. This is the same as calling `replacen` with `limit` set to\n/// `0`.\n///\n/// See the documentation for `replace` for details on how to access\n/// capturing group matches in the replacement string.\npub fn replace_all<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        rep: R,\n    ) -> Cow<'t, str>{\n        self.replacen(text, 0, rep)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::replacen":["/// Replaces at most `limit` non-overlapping matches in `text` with the\n/// replacement provided. If `limit` is 0, then all non-overlapping matches\n/// are replaced.\n///\n/// See the documentation for `replace` for details on how to access\n/// capturing group matches in the replacement string.\npub fn replacen<'t, R: Replacer>(\n        &self,\n        text: &'t str,\n        limit: usize,\n        mut rep: R,\n    ) -> Cow<'t, str>{\n        // If we know that the replacement doesn't have any capture expansions,\n        // then we can use the fast path. The fast path can make a tremendous\n        // difference:\n        //\n        //   1) We use `find_iter` instead of `captures_iter`. Not asking for\n        //      captures generally makes the regex engines faster.\n        //   2) We don't need to look up all of the capture groups and do\n        //      replacements inside the replacement string. We just push it\n        //      at each match and be done with it.\n        if let Some(rep) = rep.no_expansion() {\n            let mut it = self.find_iter(text).enumerate().peekable();\n            if it.peek().is_none() {\n                return Cow::Borrowed(text);\n            }\n            let mut new = String::with_capacity(text.len());\n            let mut last_match = 0;\n            for (i, m) in it {\n                new.push_str(&text[last_match..m.start()]);\n                new.push_str(&rep);\n                last_match = m.end();\n                if limit > 0 && i >= limit - 1 {\n                    break;\n                }\n            }\n            new.push_str(&text[last_match..]);\n            return Cow::Owned(new);\n        }\n\n        // The slower path, which we use if the replacement needs access to\n        // capture groups.\n        let mut it = self.captures_iter(text).enumerate().peekable();\n        if it.peek().is_none() {\n            return Cow::Borrowed(text);\n        }\n        let mut new = String::with_capacity(text.len());\n        let mut last_match = 0;\n        for (i, cap) in it {\n            // unwrap on 0 is OK because captures only reports matches\n            let m = cap.get(0).unwrap();\n            new.push_str(&text[last_match..m.start()]);\n            rep.replace_append(&cap, &mut new);\n            last_match = m.end();\n            if limit > 0 && i >= limit - 1 {\n                break;\n            }\n        }\n        new.push_str(&text[last_match..]);\n        Cow::Owned(new)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::shortest_match":["/// Returns the end location of a match in the text given.\n///\n/// This method may have the same performance characteristics as\n/// `is_match`, except it provides an end location for a match. In\n/// particular, the location returned *may be shorter* than the proper end\n/// of the leftmost-first match that you would find via `Regex::find`.\n///\n/// Note that it is not guaranteed that this routine finds the shortest or\n/// \"earliest\" possible match. Instead, the main idea of this API is that\n/// it returns the offset at the point at which the internal regex engine\n/// has determined that a match has occurred. This may vary depending on\n/// which internal regex engine is used, and thus, the offset itself may\n/// change.\n///\n/// # Example\n///\n/// Typically, `a+` would match the entire first sequence of `a` in some\n/// text, but `shortest_match` can give up as soon as it sees the first\n/// `a`.\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let text = \"aaaaa\";\n/// let pos = Regex::new(r\"a+\").unwrap().shortest_match(text);\n/// assert_eq!(pos, Some(1));\n/// # }\n/// ```\npub fn shortest_match(&self, text: &str) -> Option<usize>{\n        self.shortest_match_at(text, 0)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::shortest_match_at":["/// Returns the same as `shortest_match`, but starts the search at the\n/// given offset.\n///\n/// The significance of the starting point is that it takes the surrounding\n/// context into consideration. For example, the `\\A` anchor can only match\n/// when `start == 0`.\npub fn shortest_match_at(\n        &self,\n        text: &str,\n        start: usize,\n    ) -> Option<usize>{\n        self.0.searcher_str().shortest_match_at(text, start)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::split":["/// Returns an iterator of substrings of `text` delimited by a match of the\n/// regular expression. Namely, each element of the iterator corresponds to\n/// text that *isn't* matched by the regular expression.\n///\n/// This method will *not* copy the text given.\n///\n/// # Example\n///\n/// To split a string delimited by arbitrary amounts of spaces or tabs:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"[ \\t]+\").unwrap();\n/// let fields: Vec<&str> = re.split(\"a b \\t  c\\td    e\").collect();\n/// assert_eq!(fields, vec![\"a\", \"b\", \"c\", \"d\", \"e\"]);\n/// # }\n/// ```\npub fn split<'r, 't>(&'r self, text: &'t str) -> Split<'r, 't>{\n        Split { finder: self.find_iter(text), last: 0 }\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::splitn":["/// Returns an iterator of at most `limit` substrings of `text` delimited\n/// by a match of the regular expression. (A `limit` of `0` will return no\n/// substrings.) Namely, each element of the iterator corresponds to text\n/// that *isn't* matched by the regular expression. The remainder of the\n/// string that is not split will be the last element in the iterator.\n///\n/// This method will *not* copy the text given.\n///\n/// # Example\n///\n/// Get the first two words in some text:\n///\n/// ```rust\n/// # use regex::Regex;\n/// # fn main() {\n/// let re = Regex::new(r\"\\W+\").unwrap();\n/// let fields: Vec<&str> = re.splitn(\"Hey! How are you?\", 3).collect();\n/// assert_eq!(fields, vec!(\"Hey\", \"How\", \"are you?\"));\n/// # }\n/// ```\npub fn splitn<'r, 't>(\n        &'r self,\n        text: &'t str,\n        limit: usize,\n    ) -> SplitN<'r, 't>{\n        SplitN { splits: self.split(text), n: limit }\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Regex::static_captures_len":["/// Returns the total number of capturing groups that appear in every\n/// possible match.\n///\n/// If the number of capture groups can vary depending on the match, then\n/// this returns `None`. That is, a value is only returned when the number\n/// of matching groups is invariant or \"static.\"\n///\n/// Note that like [`Regex::captures_len`], this **does** include the\n/// implicit capturing group corresponding to the entire match. Therefore,\n/// when a non-None value is returned, it is guaranteed to be at least `1`.\n/// Stated differently, a return value of `Some(0)` is impossible.\n///\n/// # Example\n///\n/// This shows a few cases where a static number of capture groups is\n/// available and a few cases where it is not.\n///\n/// ```\n/// use regex::Regex;\n///\n/// let len = |pattern| {\n///     Regex::new(pattern).map(|re| re.static_captures_len())\n/// };\n///\n/// assert_eq!(Some(1), len(\"a\")?);\n/// assert_eq!(Some(2), len(\"(a)\")?);\n/// assert_eq!(Some(2), len(\"(a)|(b)\")?);\n/// assert_eq!(Some(3), len(\"(a)(b)|(c)(d)\")?);\n/// assert_eq!(None, len(\"(a)|b\")?);\n/// assert_eq!(None, len(\"a|(b)\")?);\n/// assert_eq!(None, len(\"(b)*\")?);\n/// assert_eq!(Some(2), len(\"(b)+\")?);\n///\n/// # Ok::<(), Box<dyn std::error::Error>>(())\n/// ```\n#[inline]\npub fn static_captures_len(&self) -> Option<usize>{\n        self.0.static_captures_len().map(|len| len.saturating_add(1))\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Replacer":["/// Replacer describes types that can be used to replace matches in a string.\n///\n/// In general, users of this crate shouldn't need to implement this trait,\n/// since implementations are already provided for `&str` along with other\n/// variants of string types and `FnMut(&Captures) -> String` (or any\n/// `FnMut(&Captures) -> T` where `T: AsRef<str>`), which covers most use cases.\npub trait Replacer {\n    /// Appends text to `dst` to replace the current match.\n    ///\n    /// The current match is represented by `caps`, which is guaranteed to\n    /// have a match at capture group `0`.\n    ///\n    /// For example, a no-op replacement would be\n    /// `dst.push_str(caps.get(0).unwrap().as_str())`.\n    fn replace_append(&mut self, caps: &Captures<'_>, dst: &mut String);\n\n    /// Return a fixed unchanging replacement string.\n    ///\n    /// When doing replacements, if access to `Captures` is not needed (e.g.,\n    /// the replacement byte string does not need `$` expansion), then it can\n    /// be beneficial to avoid finding sub-captures.\n    ///\n    /// In general, this is called once for every call to `replacen`.\n    fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, str>> {\n        None\n    }\n\n    /// Return a `Replacer` that borrows and wraps this `Replacer`.\n    ///\n    /// This is useful when you want to take a generic `Replacer` (which might\n    /// not be cloneable) and use it without consuming it, so it can be used\n    /// more than once.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use regex::{Regex, Replacer};\n    ///\n    /// fn replace_all_twice<R: Replacer>(\n    ///     re: Regex,\n    ///     src: &str,\n    ///     mut rep: R,\n    /// ) -> String {\n    ///     let dst = re.replace_all(src, rep.by_ref());\n    ///     let dst = re.replace_all(&dst, rep.by_ref());\n    ///     dst.into_owned()\n    /// }\n    /// ```\n    fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> {\n        ReplacerRef(self)\n    }\n}","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Replacer::by_ref":["/// Return a `Replacer` that borrows and wraps this `Replacer`.\n///\n/// This is useful when you want to take a generic `Replacer` (which might\n/// not be cloneable) and use it without consuming it, so it can be used\n/// more than once.\n///\n/// # Example\n///\n/// ```\n/// use regex::{Regex, Replacer};\n///\n/// fn replace_all_twice<R: Replacer>(\n///     re: Regex,\n///     src: &str,\n///     mut rep: R,\n/// ) -> String {\n///     let dst = re.replace_all(src, rep.by_ref());\n///     let dst = re.replace_all(&dst, rep.by_ref());\n///     dst.into_owned()\n/// }\n/// ```\nfn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self>{\n        ReplacerRef(self)\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Replacer::no_expansion":["/// Return a fixed unchanging replacement string.\n///\n/// When doing replacements, if access to `Captures` is not needed (e.g.,\n/// the replacement byte string does not need `$` expansion), then it can\n/// be beneficial to avoid finding sub-captures.\n///\n/// In general, this is called once for every call to `replacen`.\nfn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, str>>{\n        None\n    }","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::ReplacerRef":["/// By-reference adaptor for a `Replacer`\n///\n/// Returned by [`Replacer::by_ref`](trait.Replacer.html#method.by_ref).\npub struct ReplacerRef<'a, R: ?Sized>(&'a mut R);","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::Split":["/// Yields all substrings delimited by a regular expression match.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the string being split.\npub struct Split<'r, 't> {\n    finder: Matches<'r, 't>,\n    last: usize,\n}","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::SplitN":["/// Yields at most `N` substrings delimited by a regular expression match.\n///\n/// The last substring will be whatever remains after splitting.\n///\n/// `'r` is the lifetime of the compiled regular expression and `'t` is the\n/// lifetime of the string being split.\npub struct SplitN<'r, 't> {\n    splits: Split<'r, 't>,\n    n: usize,\n}","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::SubCaptureMatches":["/// An iterator that yields all capturing matches in the order in which they\n/// appear in the regex.\n///\n/// If a particular capture group didn't participate in the match, then `None`\n/// is yielded for that capture. The first match always corresponds to the\n/// overall match of the regex.\n///\n/// The lifetime `'c` corresponds to the lifetime of the `Captures` value, and\n/// the lifetime `'t` corresponds to the originally matched text.\npub struct SubCaptureMatches<'c, 't> {\n    caps: &'c Captures<'t>,\n    it: SubCapturesPosIter<'c>,\n}","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::escape":["/// Escapes all regular expression meta characters in `text`.\n///\n/// The string returned may be safely used as a literal in a regular\n/// expression.\npub fn escape(text: &str) -> String{\n    regex_syntax::escape(text)\n}","Real(LocalPath(\"src/re_unicode.rs\"))"],"re_unicode::no_expansion":["fn no_expansion<T: AsRef<str>>(t: &T) -> Option<Cow<'_, str>>{\n    let s = t.as_ref();\n    match find_byte(b'$', s.as_bytes()) {\n        Some(_) => None,\n        None => Some(Cow::Borrowed(s)),\n    }\n}","Real(LocalPath(\"src/re_unicode.rs\"))"],"sparse::SparseSet":["/// A sparse set used for representing ordered NFA states.\n///\n/// This supports constant time addition and membership testing. Clearing an\n/// entire set can also be done in constant time. Iteration yields elements\n/// in the order in which they were inserted.\n///\n/// The data structure is based on: https://research.swtch.com/sparse\n/// Note though that we don't actually use uninitialized memory. We generally\n/// reuse allocations, so the initial allocation cost is bareable. However,\n/// its other properties listed above are extremely useful.\npub struct SparseSet {\n    /// Dense contains the instruction pointers in the order in which they\n    /// were inserted.\n    dense: Vec<usize>,\n    /// Sparse maps instruction pointers to their location in dense.\n    ///\n    /// An instruction pointer is in the set if and only if\n    /// sparse[ip] < dense.len() && ip == dense[sparse[ip]].\n    sparse: Box<[usize]>,\n}","Real(LocalPath(\"src/sparse.rs\"))"],"sparse::SparseSet::capacity":["pub fn capacity(&self) -> usize{\n        self.dense.capacity()\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"sparse::SparseSet::clear":["pub fn clear(&mut self){\n        self.dense.clear();\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"sparse::SparseSet::contains":["pub fn contains(&self, value: usize) -> bool{\n        let i = self.sparse[value];\n        self.dense.get(i) == Some(&value)\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"sparse::SparseSet::insert":["pub fn insert(&mut self, value: usize){\n        let i = self.len();\n        assert!(i < self.capacity());\n        self.dense.push(value);\n        self.sparse[value] = i;\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"sparse::SparseSet::is_empty":["pub fn is_empty(&self) -> bool{\n        self.dense.is_empty()\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"sparse::SparseSet::len":["pub fn len(&self) -> usize{\n        self.dense.len()\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"sparse::SparseSet::new":["pub fn new(size: usize) -> SparseSet{\n        SparseSet {\n            dense: Vec::with_capacity(size),\n            sparse: vec![0; size].into_boxed_slice(),\n        }\n    }","Real(LocalPath(\"src/sparse.rs\"))"],"utf8::decode_last_utf8":["/// Like `decode_utf8`, but decodes the last UTF-8 sequence in `src` instead\n/// of the first.\npub fn decode_last_utf8(src: &[u8]) -> Option<(char, usize)>{\n    if src.is_empty() {\n        return None;\n    }\n    let mut start = src.len() - 1;\n    if src[start] <= 0x7F {\n        return Some((src[start] as char, 1));\n    }\n    while start > src.len().saturating_sub(4) {\n        start -= 1;\n        if is_start_byte(src[start]) {\n            break;\n        }\n    }\n    match decode_utf8(&src[start..]) {\n        None => None,\n        Some((_, n)) if n < src.len() - start => None,\n        Some((cp, n)) => Some((cp, n)),\n    }\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::decode_utf8":["/// Decode a single UTF-8 sequence into a single Unicode codepoint from `src`.\n///\n/// If no valid UTF-8 sequence could be found, then `None` is returned.\n/// Otherwise, the decoded codepoint and the number of bytes read is returned.\n/// The number of bytes read (for a valid UTF-8 sequence) is guaranteed to be\n/// 1, 2, 3 or 4.\n///\n/// Note that a UTF-8 sequence is invalid if it is incorrect UTF-8, encodes a\n/// codepoint that is out of range (surrogate codepoints are out of range) or\n/// is not the shortest possible UTF-8 sequence for that codepoint.\n#[inline]\npub fn decode_utf8(src: &[u8]) -> Option<(char, usize)>{\n    let b0 = match src.get(0) {\n        None => return None,\n        Some(&b) if b <= 0x7F => return Some((b as char, 1)),\n        Some(&b) => b,\n    };\n    match b0 {\n        0b110_00000..=0b110_11111 => {\n            if src.len() < 2 {\n                return None;\n            }\n            let b1 = src[1];\n            if 0b11_000000 & b1 != TAG_CONT {\n                return None;\n            }\n            let cp = ((b0 & !TAG_TWO) as u32) << 6 | ((b1 & !TAG_CONT) as u32);\n            match cp {\n                0x80..=0x7FF => char::from_u32(cp).map(|cp| (cp, 2)),\n                _ => None,\n            }\n        }\n        0b1110_0000..=0b1110_1111 => {\n            if src.len() < 3 {\n                return None;\n            }\n            let (b1, b2) = (src[1], src[2]);\n            if 0b11_000000 & b1 != TAG_CONT {\n                return None;\n            }\n            if 0b11_000000 & b2 != TAG_CONT {\n                return None;\n            }\n            let cp = ((b0 & !TAG_THREE) as u32) << 12\n                | ((b1 & !TAG_CONT) as u32) << 6\n                | ((b2 & !TAG_CONT) as u32);\n            match cp {\n                // char::from_u32 will disallow surrogate codepoints.\n                0x800..=0xFFFF => char::from_u32(cp).map(|cp| (cp, 3)),\n                _ => None,\n            }\n        }\n        0b11110_000..=0b11110_111 => {\n            if src.len() < 4 {\n                return None;\n            }\n            let (b1, b2, b3) = (src[1], src[2], src[3]);\n            if 0b11_000000 & b1 != TAG_CONT {\n                return None;\n            }\n            if 0b11_000000 & b2 != TAG_CONT {\n                return None;\n            }\n            if 0b11_000000 & b3 != TAG_CONT {\n                return None;\n            }\n            let cp = ((b0 & !TAG_FOUR) as u32) << 18\n                | ((b1 & !TAG_CONT) as u32) << 12\n                | ((b2 & !TAG_CONT) as u32) << 6\n                | ((b3 & !TAG_CONT) as u32);\n            match cp {\n                0x10000..=0x0010_FFFF => char::from_u32(cp).map(|cp| (cp, 4)),\n                _ => None,\n            }\n        }\n        _ => None,\n    }\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::is_start_byte":["fn is_start_byte(b: u8) -> bool{\n    b & 0b11_000000 != 0b1_0000000\n}","Real(LocalPath(\"src/utf8.rs\"))"],"utf8::next_utf8":["/// Returns the smallest possible index of the next valid UTF-8 sequence\n/// starting after `i`.\npub fn next_utf8(text: &[u8], i: usize) -> usize{\n    let b = match text.get(i) {\n        None => return i + 1,\n        Some(&b) => b,\n    };\n    let inc = if b <= 0x7F {\n        1\n    } else if b <= 0b110_11111 {\n        2\n    } else if b <= 0b1110_1111 {\n        3\n    } else {\n        4\n    };\n    i + inc\n}","Real(LocalPath(\"src/utf8.rs\"))"]},"struct_constructor":{"&'^0.Named(DefId(0:1275 ~ regex[3610]::re_unicode::{impl#23}::index::'a), \"'a\") str":["index"],"&'^0.Named(DefId(0:2741 ~ regex[3610]::dfa::{impl#5}::state::'_), \"'_\") dfa::State":["state"],"&'^0.Named(DefId(0:2756 ~ regex[3610]::dfa::{impl#6}::get_state::'_), \"'_\") dfa::State":["get_state"],"&'^0.Named(DefId(0:2791 ~ regex[3610]::error::{impl#0}::description::'_), \"'_\") str":["description"],"&'^0.Named(DefId(0:2879 ~ regex[3610]::exec::{impl#5}::regex_strings::'_), \"'_\") [std::string::String]":["regex_strings"],"&'^0.Named(DefId(0:2880 ~ regex[3610]::exec::{impl#5}::capture_names::'_), \"'_\") [std::option::Option<std::string::String>]":["capture_names"],"&'^0.Named(DefId(0:2923 ~ regex[3610]::input::Input::as_bytes::'_), \"'_\") [u8]":["as_bytes"],"&'^0.Named(DefId(0:2932 ~ regex[3610]::input::{impl#1}::as_bytes::'_), \"'_\") [u8]":["as_bytes"],"&'^0.Named(DefId(0:2933 ~ regex[3610]::input::{impl#3}::deref::'_), \"'_\") [u8]":["deref"],"&'^0.Named(DefId(0:2942 ~ regex[3610]::input::{impl#4}::as_bytes::'_), \"'_\") [u8]":["as_bytes"],"&'^0.Named(DefId(0:2943 ~ regex[3610]::input::{impl#6}::deref::'_), \"'_\") [u8]":["deref"],"&'^0.Named(DefId(0:2952 ~ regex[3610]::input::{impl#7}::as_bytes::'_), \"'_\") [u8]":["as_bytes"],"&'^0.Named(DefId(0:2972 ~ regex[3610]::literal::imp::{impl#0}::lcp::'_), \"'_\") literal::imp::Memmem":["lcp"],"&'^0.Named(DefId(0:2973 ~ regex[3610]::literal::imp::{impl#0}::lcs::'_), \"'_\") literal::imp::Memmem":["lcs"],"&'^0.Named(DefId(0:3018 ~ regex[3610]::pikevm::{impl#2}::caps::'_), \"'_\") mut [std::option::Option<usize>]":["caps"],"&'^0.Named(DefId(0:3035 ~ regex[3610]::prog::{impl#1}::deref::'_), \"'_\") Alias(Projection, AliasTy { args: [prog::Program], def_id: DefId(2:3552 ~ core[a245]::ops::deref::Deref::Target) })":["deref"],"&'^0.Named(DefId(0:3081 ~ regex[3610]::re_bytes::{impl#9}::as_str::'_), \"'_\") str":["as_str"],"&'^0.Named(DefId(0:3111 ~ regex[3610]::re_bytes::{impl#25}::index::'_), \"'_\") [u8]":["index"],"&'^0.Named(DefId(0:3161 ~ regex[3610]::re_trait::{impl#0}::as_slots::'_), \"'_\") mut [std::option::Option<usize>]":["as_slots"],"&'^0.Named(DefId(0:3224 ~ regex[3610]::re_unicode::{impl#10}::as_str::'_), \"'_\") str":["as_str"],"&'^0.Named(DefId(0:3251 ~ regex[3610]::re_unicode::{impl#22}::index::'_), \"'_\") str":["index"],"&'^0.Named(DefId(0:3311 ~ regex[3610]::sparse::{impl#2}::deref::'_), \"'_\") Alias(Projection, AliasTy { args: [sparse::SparseSet], def_id: DefId(2:3552 ~ core[a245]::ops::deref::Deref::Target) })":["deref"],"&'^0.Named(DefId(0:3654 ~ regex[3610]::re_set::unicode::{impl#0}::patterns::'_), \"'_\") [std::string::String]":["patterns"],"&'^0.Named(DefId(0:3668 ~ regex[3610]::re_set::unicode::as_bytes_str::'_), \"'_\") [u8]":["as_bytes_str"],"&'^0.Named(DefId(0:3693 ~ regex[3610]::re_set::bytes::{impl#0}::patterns::'_), \"'_\") [std::string::String]":["patterns"],"&'^0.Named(DefId(0:3707 ~ regex[3610]::re_set::bytes::as_bytes_str::'_), \"'_\") [u8]":["as_bytes_str"],"&'^0.Named(DefId(0:987 ~ regex[3610]::re_bytes::{impl#26}::index::'a), \"'a\") [u8]":["index"],"&'r/#0 str":["next"],"&'t/#0 Alias(Projection, AliasTy { args: [R/#1], def_id: DefId(0:1063 ~ regex[3610]::re_trait::RegularExpression::Text) })":["text"],"&'t/#0 [u8]":["as_bytes"],"&'t/#0 str":["as_str","from"],"&'t/#1 [u8]":["next"],"&'t/#1 str":["next"],"(char, usize)":["decode_last_utf8","decode_utf8"],"(compile::Hole, compile::Hole)":["dup_one"],"(dfa::EmptyFlags, dfa::StateFlags)":["start_flags","start_flags_reverse"],"(i32, usize)":["read_vari32"],"(regex_syntax::hir::literal::Seq, regex_syntax::hir::literal::Seq)":["literal_analysis"],"(u32, usize)":["read_varu32"],"(usize, std::option::Option<usize>)":["size_hint"],"(usize, usize)":["captures_nfa","captures_nfa_type","captures_read_at","find","find_at","find_end","find_literals","find_nfa","find_start","get","next","pos"],"Alias(Projection, AliasTy { args: [&'a/#0 prog::Program], def_id: DefId(2:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })":["into_iter"],"Alias(Projection, AliasTy { args: [&'a/#0 re_set::bytes::SetMatches], def_id: DefId(2:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })":["into_iter"],"Alias(Projection, AliasTy { args: [&'a/#0 re_set::unicode::SetMatches], def_id: DefId(2:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })":["into_iter"],"Alias(Projection, AliasTy { args: [&'a/#0 sparse::SparseSet], def_id: DefId(2:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })":["into_iter"],"Alias(Projection, AliasTy { args: [literal::imp::LiteralIter<'a/#0>], def_id: DefId(2:8502 ~ core[a245]::iter::traits::iterator::Iterator::Item) })":["next"],"Alias(Projection, AliasTy { args: [re_set::bytes::SetMatches], def_id: DefId(2:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })":["into_iter"],"Alias(Projection, AliasTy { args: [re_set::unicode::SetMatches], def_id: DefId(2:8327 ~ core[a245]::iter::traits::collect::IntoIterator::IntoIter) })":["into_iter"],"aho_corasick::AhoCorasick":["build_aho_corasick"],"backtrack::Cache":["clone","new"],"backtrack::Job":["clone"],"bool":["backtrack","can_exec","clear_cache","clear_cache_and_save","complete","contains","continue_past_first_match","eq","exec","exec_","exec_backtrack","has_empty","has_prefix","has_visited","imp","is_anchor_end_match","is_ascii_word","is_empty","is_empty_match","is_end","is_eof","is_match","is_match_at","is_none","is_start","is_start_byte","is_suffix","is_valid_cap_letter","is_word","is_word_byte","is_word_char","leads_to_match","many_matches_at","match_nfa","match_nfa_type","matched","matched_any","matches","needs_dotstar","only_utf8","read_matches_at","should_exec","should_suffix_scan","step","uses_bytes"],"compile::ByteClassSet":["new"],"compile::Compiler":["new"],"compile::Hole":["push_hole","push_split_hole"],"compile::InstHole":["clone"],"compile::MaybeInst":["clone"],"compile::Patch":["c","c_alternate","c_byte","c_capture","c_char","c_class","c_class_bytes","c_concat","c_dotstar","c_empty","c_empty_look","c_literal","c_repeat","c_repeat_one_or_more","c_repeat_range","c_repeat_range_min_or_more","c_repeat_zero_or_more","c_repeat_zero_or_one","c_utf8_seq","c_utf8_seq_","compile","next_inst","pop_split_hole"],"compile::SuffixCache":["new"],"compile::SuffixCacheEntry":["clone","default"],"compile::SuffixCacheKey":["clone","default"],"dfa::Byte":["byte","clone","eof"],"dfa::Cache":["new"],"dfa::EmptyFlags":["clone","default"],"dfa::InstPtrs":["inst_ptrs"],"dfa::Result":["clone","exec_at","exec_at_reverse","exec_dfa_reverse_suffix","find_dfa_anchored_reverse","find_dfa_forward","find_dfa_reverse_suffix","forward","forward_many","reverse","shortest_dfa","shortest_dfa_reverse_suffix"],"dfa::State":["cached_state_key","clone"],"dfa::StateFlags":["clone","default","flags"],"dfa::StateMap":["new"],"dfa::Transitions":["clone","new"],"error::Error":["clone"],"exec::Exec":["build","clone"],"exec::ExecBuilder":["new","new_many","new_options"],"exec::ExecNoSync":["searcher"],"exec::ExecNoSyncStr":["searcher_str"],"exec::MatchLiteralType":["clone"],"exec::MatchNfaType":["clone"],"exec::MatchType":["choose_dfa_match_type","choose_literal_match_type","clone","imp"],"exec::Parsed":["parse"],"exec::ProgramCacheInner":["new"],"expand::CaptureRef":["clone","find_cap_ref","find_cap_ref_braced"],"expand::Ref":["clone","from"],"input::ByteInput":["clone","new"],"input::Char":["char","clone","from","next_char","previous_char"],"input::CharInput":["clone","new"],"input::InputAt":["at","clone"],"literal::imp::LiteralIter":["iter"],"literal::imp::LiteralSearcher":["clone","empty","new","prefixes","suffixes"],"literal::imp::Matcher":["clone","new","prefixes","suffixes"],"literal::imp::Memmem":["clone","new"],"literal::imp::SingleByteSet":["clone","new","prefixes","suffixes"],"pikevm::Cache":["clone","new"],"pikevm::FollowEpsilon":["clone"],"pikevm::Threads":["clone","new"],"pool::Pool":["new"],"pool::PoolGuard":["get","get_slow","guard_owned","guard_stack"],"prog::EmptyLook":["clone"],"prog::Inst":["clone","fill","unwrap"],"prog::InstBytes":["clone"],"prog::InstChar":["clone"],"prog::InstEmptyLook":["clone"],"prog::InstRanges":["clone"],"prog::InstSave":["clone"],"prog::InstSplit":["clone"],"prog::Program":["clone","compile","compile_finish","compile_many","compile_one","new"],"re_builder::RegexOptions":["clone","default"],"re_builder::bytes::RegexBuilder":["new"],"re_builder::set_bytes::RegexSetBuilder":["new"],"re_builder::set_unicode::RegexSetBuilder":["new"],"re_builder::unicode::RegexBuilder":["new"],"re_bytes::CaptureLocations":["capture_locations","clone","locations"],"re_bytes::CaptureMatches":["captures_iter"],"re_bytes::CaptureNames":["capture_names","clone"],"re_bytes::Captures":["captures","captures_at","next"],"re_bytes::Match":["captures_read","captures_read_at","clone","find","find_at","get","name","new","next","read_captures_at"],"re_bytes::Matches":["find_iter"],"re_bytes::NoExpand":["clone"],"re_bytes::Regex":["build","clone","from","from_str","into_byte_regex","new"],"re_bytes::ReplacerRef":["by_ref"],"re_bytes::Split":["split"],"re_bytes::SplitN":["splitn"],"re_bytes::SubCaptureMatches":["clone","iter"],"re_set::bytes::RegexSet":["build","clone","default","empty","from","into_byte_regex_set","new"],"re_set::bytes::SetMatches":["clone","matches"],"re_set::bytes::SetMatchesIter":["clone","iter"],"re_set::unicode::RegexSet":["build","clone","default","empty","from","into_regex_set","new"],"re_set::unicode::SetMatches":["clone","matches"],"re_set::unicode::SetMatchesIter":["clone","iter"],"re_trait::CaptureMatches":["captures_iter"],"re_trait::Locations":["clone","locations","next"],"re_trait::Matches":["find_iter"],"re_trait::SubCapturesPosIter":["clone","iter"],"re_unicode::CaptureLocations":["capture_locations","clone","locations"],"re_unicode::CaptureMatches":["captures_iter"],"re_unicode::CaptureNames":["capture_names","clone"],"re_unicode::Captures":["captures","captures_at","next"],"re_unicode::Match":["captures_read","captures_read_at","clone","find","find_at","get","name","new","next","read_captures_at"],"re_unicode::Matches":["find_iter"],"re_unicode::NoExpand":["clone"],"re_unicode::Regex":["build","clone","from","from_str","into_regex","new"],"re_unicode::ReplacerRef":["by_ref"],"re_unicode::Split":["split"],"re_unicode::SplitN":["splitn"],"re_unicode::SubCaptureMatches":["clone","iter"],"sparse::SparseSet":["clone","new"],"std::borrow::Cow":["no_expansion","replace","replace_all","replacen"],"std::boxed::Box":["new_pool"],"std::cmp::Ordering":["cmp","partial_cmp"],"std::ops::Range":["from","range"],"std::string::String":["escape","escape_byte","escape_bytes","show_state_ptr","vb","visible_byte"],"std::vec::Vec":["alternation_literals","byte_classes"],"u32":["add","add_state","cached_state","get_ptr","restore_state","start_state","usize_to_u32"],"u8":["as_byte","byte"],"usize":["__init","_find","approximate_size","byte_class","capacity","captures_len","char_len","char_len_lossy","count","end","find","find_byte","hash","imp","len","len_utf8","next","next_back","next_pos","num_byte_classes","num_chars","num_states","pos","shortest_match","slots_len","start","state_heap_size","static_captures_len","u32_to_usize","u8_class"]},"struct_to_trait":{"<F as re_bytes::Replacer>::F":["re_bytes::Replacer"],"<F as re_unicode::Replacer>::F":["re_unicode::Replacer"],"backtrack::Bounded":["std::fmt::Debug"],"backtrack::Cache":["std::clone::Clone","std::fmt::Debug"],"backtrack::Job":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"compile::ByteClassSet":["std::fmt::Debug"],"compile::Hole":["std::fmt::Debug"],"compile::InstHole":["std::clone::Clone","std::fmt::Debug"],"compile::MaybeInst":["std::clone::Clone","std::fmt::Debug"],"compile::Patch":["std::fmt::Debug"],"compile::SuffixCache":["std::fmt::Debug"],"compile::SuffixCacheEntry":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralPartialEq"],"compile::SuffixCacheKey":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralPartialEq"],"dfa::Byte":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"dfa::Cache":["std::fmt::Debug"],"dfa::CacheInner":["std::fmt::Debug"],"dfa::EmptyFlags":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralPartialEq"],"dfa::Fsm":["std::fmt::Debug"],"dfa::InstPtrs":["std::iter::Iterator"],"dfa::Result":["std::clone::Clone","std::fmt::Debug"],"dfa::State":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::hash::Hash","std::marker::StructuralPartialEq"],"dfa::StateFlags":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::default::Default","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralPartialEq"],"dfa::StateMap":["std::fmt::Debug"],"dfa::Transitions":["std::clone::Clone","std::fmt::Debug"],"dfa::TransitionsRow":["std::fmt::Debug"],"error::Error":["std::clone::Clone","std::cmp::PartialEq","std::error::Error","std::fmt::Debug","std::fmt::Display","std::marker::StructuralPartialEq"],"exec::Exec":["std::clone::Clone","std::fmt::Debug"],"exec::ExecNoSync":["re_trait::RegularExpression","std::fmt::Debug"],"exec::ExecNoSyncStr":["re_trait::RegularExpression","std::fmt::Debug"],"exec::ExecReadOnly":["std::fmt::Debug"],"exec::MatchLiteralType":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"exec::MatchNfaType":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"exec::MatchType":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"exec::ProgramCacheInner":["std::fmt::Debug"],"expand::CaptureRef":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"expand::Ref":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::convert::From","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"input::ByteInput":["input::Input","std::clone::Clone","std::fmt::Debug","std::marker::Copy","std::ops::Deref"],"input::Char":["std::clone::Clone","std::cmp::Eq","std::cmp::Ord","std::cmp::PartialEq","std::cmp::PartialOrd","std::convert::From","std::fmt::Debug","std::hash::Hash","std::marker::Copy","std::marker::StructuralPartialEq"],"input::CharInput":["input::Input","std::clone::Clone","std::fmt::Debug","std::marker::Copy","std::ops::Deref"],"input::InputAt":["std::clone::Clone","std::fmt::Debug","std::marker::Copy"],"literal::imp::LiteralIter":["std::fmt::Debug","std::iter::Iterator"],"literal::imp::LiteralSearcher":["std::clone::Clone","std::fmt::Debug"],"literal::imp::Matcher":["std::clone::Clone","std::fmt::Debug"],"literal::imp::Memmem":["std::clone::Clone","std::fmt::Debug"],"literal::imp::SingleByteSet":["std::clone::Clone","std::fmt::Debug"],"pikevm::Cache":["std::clone::Clone","std::fmt::Debug"],"pikevm::FollowEpsilon":["std::clone::Clone","std::fmt::Debug"],"pikevm::Fsm":["std::fmt::Debug"],"pikevm::Threads":["std::clone::Clone","std::fmt::Debug"],"pool::Pool":["std::fmt::Debug","std::marker::Sync"],"pool::PoolGuard":["std::fmt::Debug","std::ops::Drop"],"prog::EmptyLook":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"prog::Inst":["std::clone::Clone","std::fmt::Debug"],"prog::InstBytes":["std::clone::Clone","std::fmt::Debug"],"prog::InstChar":["std::clone::Clone","std::fmt::Debug"],"prog::InstEmptyLook":["std::clone::Clone","std::fmt::Debug"],"prog::InstRanges":["std::clone::Clone","std::fmt::Debug"],"prog::InstSave":["std::clone::Clone","std::fmt::Debug"],"prog::InstSplit":["std::clone::Clone","std::fmt::Debug"],"prog::Program":["std::clone::Clone","std::fmt::Debug","std::ops::Deref"],"re_builder::RegexOptions":["std::clone::Clone","std::default::Default","std::fmt::Debug"],"re_builder::bytes::RegexBuilder":["std::fmt::Debug"],"re_builder::set_bytes::RegexSetBuilder":["std::fmt::Debug"],"re_builder::set_unicode::RegexSetBuilder":["std::fmt::Debug"],"re_builder::unicode::RegexBuilder":["std::fmt::Debug"],"re_bytes::CaptureLocations":["std::clone::Clone","std::fmt::Debug"],"re_bytes::CaptureMatches":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_bytes::CaptureNames":["std::clone::Clone","std::fmt::Debug","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"re_bytes::Captures":["std::fmt::Debug","std::ops::Index"],"re_bytes::CapturesDebug":["std::fmt::Debug"],"re_bytes::Match":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"re_bytes::Matches":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_bytes::NoExpand":["re_bytes::Replacer","std::clone::Clone","std::fmt::Debug"],"re_bytes::Regex":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::fmt::Display","std::str::FromStr"],"re_bytes::ReplacerRef":["re_bytes::Replacer","std::fmt::Debug"],"re_bytes::Split":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_bytes::SplitN":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_bytes::SubCaptureMatches":["std::clone::Clone","std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_set::bytes::RegexSet":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug"],"re_set::bytes::SetMatches":["std::clone::Clone","std::fmt::Debug","std::iter::IntoIterator"],"re_set::bytes::SetMatchesIntoIter":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::FusedIterator","std::iter::Iterator"],"re_set::bytes::SetMatchesIter":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::FusedIterator","std::iter::Iterator"],"re_set::unicode::RegexSet":["std::clone::Clone","std::convert::From","std::default::Default","std::fmt::Debug"],"re_set::unicode::SetMatches":["std::clone::Clone","std::fmt::Debug","std::iter::IntoIterator"],"re_set::unicode::SetMatchesIntoIter":["std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::FusedIterator","std::iter::Iterator"],"re_set::unicode::SetMatchesIter":["std::clone::Clone","std::fmt::Debug","std::iter::DoubleEndedIterator","std::iter::FusedIterator","std::iter::Iterator"],"re_trait::CaptureMatches":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_trait::Locations":["std::clone::Clone","std::fmt::Debug"],"re_trait::Matches":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_trait::SubCapturesPosIter":["std::clone::Clone","std::fmt::Debug","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"re_unicode::CaptureLocations":["std::clone::Clone","std::fmt::Debug"],"re_unicode::CaptureMatches":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_unicode::CaptureNames":["std::clone::Clone","std::fmt::Debug","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"re_unicode::Captures":["std::fmt::Debug","std::ops::Index"],"re_unicode::CapturesDebug":["std::fmt::Debug"],"re_unicode::Match":["std::clone::Clone","std::cmp::Eq","std::cmp::PartialEq","std::fmt::Debug","std::marker::Copy","std::marker::StructuralPartialEq"],"re_unicode::Matches":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_unicode::NoExpand":["re_unicode::Replacer","std::clone::Clone","std::fmt::Debug"],"re_unicode::Regex":["std::clone::Clone","std::convert::From","std::fmt::Debug","std::fmt::Display","std::str::FromStr"],"re_unicode::ReplacerRef":["re_unicode::Replacer","std::fmt::Debug"],"re_unicode::Split":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_unicode::SplitN":["std::fmt::Debug","std::iter::FusedIterator","std::iter::Iterator"],"re_unicode::SubCaptureMatches":["std::clone::Clone","std::fmt::Debug","std::iter::ExactSizeIterator","std::iter::FusedIterator","std::iter::Iterator"],"sparse::SparseSet":["std::clone::Clone","std::fmt::Debug","std::ops::Deref"],"std::borrow::Cow":["re_bytes::Replacer","re_unicode::Replacer"],"std::ops::Range":["std::convert::From"],"std::string::String":["re_unicode::Replacer"],"std::vec::Vec":["re_bytes::Replacer"]},"targets":{"<&'a T as input::Input>::as_bytes":["as_bytes","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<&'a T as input::Input>::at":["at","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<&'a T as input::Input>::is_empty_match":["is_empty_match","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<&'a T as input::Input>::len":["len","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<&'a T as input::Input>::next_char":["next_char","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<&'a T as input::Input>::prefix_at":["prefix_at","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<&'a T as input::Input>::previous_char":["previous_char","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<&'a [u8] as re_bytes::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<&'a [u8] as re_bytes::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<&'a prog::Program as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/prog.rs\"))","std::iter::IntoIterator"],"<&'a re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/re_set.rs\"))","std::iter::IntoIterator"],"<&'a re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/re_set.rs\"))","std::iter::IntoIterator"],"<&'a sparse::SparseSet as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/sparse.rs\"))","std::iter::IntoIterator"],"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<&'a std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<&'a std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<&'a std::string::String as re_unicode::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<&'a std::string::String as re_unicode::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<&'a std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<&'a std::vec::Vec<u8> as re_bytes::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<&'a str as re_unicode::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<&'a str as re_unicode::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<F as re_bytes::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<F as re_unicode::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<compile::ByteClassSet as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/compile.rs\"))","std::fmt::Debug"],"<dfa::InstPtrs<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/dfa.rs\"))","std::iter::Iterator"],"<dfa::State as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/dfa.rs\"))","std::fmt::Debug"],"<dfa::StateFlags as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/dfa.rs\"))","std::fmt::Debug"],"<dfa::Transitions as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/dfa.rs\"))","std::fmt::Debug"],"<dfa::TransitionsRow<'a> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/dfa.rs\"))","std::fmt::Debug"],"<error::Error as std::error::Error>::description":["description","Real(LocalPath(\"src/error.rs\"))","std::error::Error"],"<error::Error as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Debug"],"<error::Error as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/error.rs\"))","std::fmt::Display"],"<exec::Exec as std::clone::Clone>::clone":["clone","Real(LocalPath(\"src/exec.rs\"))","std::clone::Clone"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::captures_read_at":["captures_read_at","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::find_at":["find_at","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::is_match_at":["is_match_at","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::next_after_empty":["next_after_empty","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::shortest_match_at":["shortest_match_at","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSync<'c> as re_trait::RegularExpression>::slots_len":["slots_len","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::captures_read_at":["captures_read_at","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::find_at":["find_at","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::is_match_at":["is_match_at","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::next_after_empty":["next_after_empty","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::shortest_match_at":["shortest_match_at","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<exec::ExecNoSyncStr<'c> as re_trait::RegularExpression>::slots_len":["slots_len","Real(LocalPath(\"src/exec.rs\"))","re_trait::RegularExpression"],"<expand::Ref<'a> as std::convert::From<&'a str>>::from":["from","Real(LocalPath(\"src/expand.rs\"))","std::convert::From"],"<expand::Ref<'static> as std::convert::From<usize>>::from":["from","Real(LocalPath(\"src/expand.rs\"))","std::convert::From"],"<input::ByteInput<'t> as input::Input>::as_bytes":["as_bytes","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::ByteInput<'t> as input::Input>::at":["at","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::ByteInput<'t> as input::Input>::is_empty_match":["is_empty_match","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::ByteInput<'t> as input::Input>::len":["len","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::ByteInput<'t> as input::Input>::next_char":["next_char","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::ByteInput<'t> as input::Input>::prefix_at":["prefix_at","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::ByteInput<'t> as input::Input>::previous_char":["previous_char","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::ByteInput<'t> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/input.rs\"))","std::ops::Deref"],"<input::Char as std::cmp::PartialEq<char>>::eq":["eq","Real(LocalPath(\"src/input.rs\"))","std::cmp::PartialEq"],"<input::Char as std::cmp::PartialOrd<char>>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/input.rs\"))","std::cmp::PartialOrd"],"<input::Char as std::convert::From<char>>::from":["from","Real(LocalPath(\"src/input.rs\"))","std::convert::From"],"<input::Char as std::convert::From<std::option::Option<char>>>::from":["from","Real(LocalPath(\"src/input.rs\"))","std::convert::From"],"<input::Char as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/input.rs\"))","std::fmt::Debug"],"<input::CharInput<'t> as input::Input>::as_bytes":["as_bytes","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::CharInput<'t> as input::Input>::at":["at","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::CharInput<'t> as input::Input>::is_empty_match":["is_empty_match","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::CharInput<'t> as input::Input>::len":["len","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::CharInput<'t> as input::Input>::next_char":["next_char","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::CharInput<'t> as input::Input>::prefix_at":["prefix_at","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::CharInput<'t> as input::Input>::previous_char":["previous_char","Real(LocalPath(\"src/input.rs\"))","input::Input"],"<input::CharInput<'t> as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/input.rs\"))","std::ops::Deref"],"<literal::imp::LiteralIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/literal/imp.rs\"))","std::iter::Iterator"],"<pool::Pool<T> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/pool.rs\"))","std::fmt::Debug"],"<pool::PoolGuard<'a, T> as std::ops::Drop>::drop":["drop","Real(LocalPath(\"src/pool.rs\"))","std::ops::Drop"],"<prog::Program as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/prog.rs\"))","std::fmt::Debug"],"<prog::Program as std::fmt::Debug>::fmt::visible_byte":["visible_byte","Real(LocalPath(\"src/prog.rs\"))",""],"<prog::Program as std::fmt::Debug>::fmt::with_goto":["with_goto","Real(LocalPath(\"src/prog.rs\"))",""],"<prog::Program as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/prog.rs\"))","std::ops::Deref"],"<re_builder::RegexOptions as std::default::Default>::default":["default","Real(LocalPath(\"src/re_builder.rs\"))","std::default::Default"],"<re_bytes::CaptureMatches<'r, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_bytes::CaptureNames<'r> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_bytes::Captures<'t> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_bytes.rs\"))","std::fmt::Debug"],"<re_bytes::Captures<'t> as std::ops::Index<&'i str>>::index":["index","Real(LocalPath(\"src/re_bytes.rs\"))","std::ops::Index"],"<re_bytes::Captures<'t> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/re_bytes.rs\"))","std::ops::Index"],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_bytes.rs\"))","std::fmt::Debug"],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_byte":["escape_byte","Real(LocalPath(\"src/re_bytes.rs\"))",""],"<re_bytes::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt::escape_bytes":["escape_bytes","Real(LocalPath(\"src/re_bytes.rs\"))",""],"<re_bytes::Match<'t> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_bytes.rs\"))","std::fmt::Debug"],"<re_bytes::Matches<'r, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_bytes::NoExpand<'t> as re_bytes::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<re_bytes::NoExpand<'t> as re_bytes::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<re_bytes::Regex as std::convert::From<exec::Exec>>::from":["from","Real(LocalPath(\"src/re_bytes.rs\"))","std::convert::From"],"<re_bytes::Regex as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_bytes.rs\"))","std::fmt::Debug"],"<re_bytes::Regex as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/re_bytes.rs\"))","std::fmt::Display"],"<re_bytes::Regex as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/re_bytes.rs\"))","std::str::FromStr"],"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<re_bytes::ReplacerRef<'a, R> as re_bytes::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<re_bytes::Split<'r, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_bytes::SplitN<'r, 't> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_bytes::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_bytes.rs\"))","std::iter::Iterator"],"<re_set::bytes::RegexSet as std::convert::From<exec::Exec>>::from":["from","Real(LocalPath(\"src/re_set.rs\"))","std::convert::From"],"<re_set::bytes::RegexSet as std::default::Default>::default":["default","Real(LocalPath(\"src/re_set.rs\"))","std::default::Default"],"<re_set::bytes::RegexSet as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_set.rs\"))","std::fmt::Debug"],"<re_set::bytes::SetMatches as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/re_set.rs\"))","std::iter::IntoIterator"],"<re_set::bytes::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/re_set.rs\"))","std::iter::DoubleEndedIterator"],"<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_set.rs\"))","std::iter::Iterator"],"<re_set::bytes::SetMatchesIntoIter as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_set.rs\"))","std::iter::Iterator"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/re_set.rs\"))","std::iter::DoubleEndedIterator"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_set.rs\"))","std::iter::Iterator"],"<re_set::bytes::SetMatchesIter<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_set.rs\"))","std::iter::Iterator"],"<re_set::unicode::RegexSet as std::convert::From<exec::Exec>>::from":["from","Real(LocalPath(\"src/re_set.rs\"))","std::convert::From"],"<re_set::unicode::RegexSet as std::default::Default>::default":["default","Real(LocalPath(\"src/re_set.rs\"))","std::default::Default"],"<re_set::unicode::RegexSet as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_set.rs\"))","std::fmt::Debug"],"<re_set::unicode::SetMatches as std::iter::IntoIterator>::into_iter":["into_iter","Real(LocalPath(\"src/re_set.rs\"))","std::iter::IntoIterator"],"<re_set::unicode::SetMatchesIntoIter as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/re_set.rs\"))","std::iter::DoubleEndedIterator"],"<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_set.rs\"))","std::iter::Iterator"],"<re_set::unicode::SetMatchesIntoIter as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_set.rs\"))","std::iter::Iterator"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::DoubleEndedIterator>::next_back":["next_back","Real(LocalPath(\"src/re_set.rs\"))","std::iter::DoubleEndedIterator"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_set.rs\"))","std::iter::Iterator"],"<re_set::unicode::SetMatchesIter<'a> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_set.rs\"))","std::iter::Iterator"],"<re_trait::CaptureMatches<'t, R> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_trait.rs\"))","std::iter::Iterator"],"<re_trait::Matches<'t, R> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_trait.rs\"))","std::iter::Iterator"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/re_trait.rs\"))","std::iter::Iterator"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_trait.rs\"))","std::iter::Iterator"],"<re_trait::SubCapturesPosIter<'c> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_trait.rs\"))","std::iter::Iterator"],"<re_unicode::CaptureMatches<'r, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::CaptureNames<'r> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::Captures<'t> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_unicode.rs\"))","std::fmt::Debug"],"<re_unicode::Captures<'t> as std::ops::Index<&'i str>>::index":["index","Real(LocalPath(\"src/re_unicode.rs\"))","std::ops::Index"],"<re_unicode::Captures<'t> as std::ops::Index<usize>>::index":["index","Real(LocalPath(\"src/re_unicode.rs\"))","std::ops::Index"],"<re_unicode::CapturesDebug<'c, 't> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_unicode.rs\"))","std::fmt::Debug"],"<re_unicode::Match<'t> as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_unicode.rs\"))","std::fmt::Debug"],"<re_unicode::Matches<'r, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::NoExpand<'t> as re_unicode::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<re_unicode::NoExpand<'t> as re_unicode::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<re_unicode::Regex as std::convert::From<exec::Exec>>::from":["from","Real(LocalPath(\"src/re_unicode.rs\"))","std::convert::From"],"<re_unicode::Regex as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/re_unicode.rs\"))","std::fmt::Debug"],"<re_unicode::Regex as std::fmt::Display>::fmt":["fmt","Real(LocalPath(\"src/re_unicode.rs\"))","std::fmt::Display"],"<re_unicode::Regex as std::str::FromStr>::from_str":["from_str","Real(LocalPath(\"src/re_unicode.rs\"))","std::str::FromStr"],"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<re_unicode::ReplacerRef<'a, R> as re_unicode::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<re_unicode::Split<'r, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::SplitN<'r, 't> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::count":["count","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::next":["next","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<re_unicode::SubCaptureMatches<'c, 't> as std::iter::Iterator>::size_hint":["size_hint","Real(LocalPath(\"src/re_unicode.rs\"))","std::iter::Iterator"],"<sparse::SparseSet as std::fmt::Debug>::fmt":["fmt","Real(LocalPath(\"src/sparse.rs\"))","std::fmt::Debug"],"<sparse::SparseSet as std::ops::Deref>::deref":["deref","Real(LocalPath(\"src/sparse.rs\"))","std::ops::Deref"],"<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<std::borrow::Cow<'a, [u8]> as re_bytes::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<std::borrow::Cow<'a, str> as re_unicode::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<std::borrow::Cow<'a, str> as re_unicode::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<std::string::String as re_unicode::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<std::string::String as re_unicode::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_unicode.rs\"))","re_unicode::Replacer"],"<std::vec::Vec<u8> as re_bytes::Replacer>::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"<std::vec::Vec<u8> as re_bytes::Replacer>::replace_append":["replace_append","Real(LocalPath(\"src/re_bytes.rs\"))","re_bytes::Replacer"],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::backtrack":["backtrack","Real(LocalPath(\"src/backtrack.rs\"))",""],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::clear":["clear","Real(LocalPath(\"src/backtrack.rs\"))",""],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec":["exec","Real(LocalPath(\"src/backtrack.rs\"))",""],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::exec_":["exec_","Real(LocalPath(\"src/backtrack.rs\"))",""],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::has_visited":["has_visited","Real(LocalPath(\"src/backtrack.rs\"))",""],"backtrack::Bounded::<'a, 'm, 'r, 's, I>::step":["step","Real(LocalPath(\"src/backtrack.rs\"))",""],"backtrack::Cache::new":["new","Real(LocalPath(\"src/backtrack.rs\"))",""],"backtrack::should_exec":["should_exec","Real(LocalPath(\"src/backtrack.rs\"))",""],"backtrack::usize_to_u32":["usize_to_u32","Real(LocalPath(\"src/backtrack.rs\"))",""],"compile::ByteClassSet::byte_classes":["byte_classes","Real(LocalPath(\"src/compile.rs\"))",""],"compile::ByteClassSet::new":["new","Real(LocalPath(\"src/compile.rs\"))",""],"compile::ByteClassSet::set_range":["set_range","Real(LocalPath(\"src/compile.rs\"))",""],"compile::ByteClassSet::set_word_boundary":["set_word_boundary","Real(LocalPath(\"src/compile.rs\"))",""],"compile::CompileClass::<'a, 'b>::c_utf8_seq":["c_utf8_seq","Real(LocalPath(\"src/compile.rs\"))",""],"compile::CompileClass::<'a, 'b>::c_utf8_seq_":["c_utf8_seq_","Real(LocalPath(\"src/compile.rs\"))",""],"compile::CompileClass::<'a, 'b>::compile":["compile","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::bytes":["bytes","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c":["c","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_alternate":["c_alternate","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_byte":["c_byte","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_capture":["c_capture","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_char":["c_char","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_class":["c_class","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_class_bytes":["c_class_bytes","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_concat":["c_concat","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_dotstar":["c_dotstar","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_empty":["c_empty","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_empty_look":["c_empty_look","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_literal":["c_literal","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_repeat":["c_repeat","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_repeat_one_or_more":["c_repeat_one_or_more","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_repeat_range":["c_repeat_range","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_repeat_range_min_or_more":["c_repeat_range_min_or_more","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_repeat_zero_or_more":["c_repeat_zero_or_more","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::c_repeat_zero_or_one":["c_repeat_zero_or_one","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::check_size":["check_size","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::compile":["compile","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::compile_finish":["compile_finish","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::compile_many":["compile_many","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::compile_one":["compile_one","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::dfa":["dfa","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::fill":["fill","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::fill_split":["fill_split","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::fill_to_next":["fill_to_next","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::new":["new","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::next_inst":["next_inst","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::only_utf8":["only_utf8","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::pop_split_hole":["pop_split_hole","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::push_compiled":["push_compiled","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::push_hole":["push_hole","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::push_split_hole":["push_split_hole","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::reverse":["reverse","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Compiler::size_limit":["size_limit","Real(LocalPath(\"src/compile.rs\"))",""],"compile::Hole::dup_one":["dup_one","Real(LocalPath(\"src/compile.rs\"))",""],"compile::InstHole::fill":["fill","Real(LocalPath(\"src/compile.rs\"))",""],"compile::MaybeInst::fill":["fill","Real(LocalPath(\"src/compile.rs\"))",""],"compile::MaybeInst::fill_split":["fill_split","Real(LocalPath(\"src/compile.rs\"))",""],"compile::MaybeInst::half_fill_split_goto1":["half_fill_split_goto1","Real(LocalPath(\"src/compile.rs\"))",""],"compile::MaybeInst::half_fill_split_goto2":["half_fill_split_goto2","Real(LocalPath(\"src/compile.rs\"))",""],"compile::MaybeInst::unwrap":["unwrap","Real(LocalPath(\"src/compile.rs\"))",""],"compile::SuffixCache::clear":["clear","Real(LocalPath(\"src/compile.rs\"))",""],"compile::SuffixCache::get":["get","Real(LocalPath(\"src/compile.rs\"))",""],"compile::SuffixCache::hash":["hash","Real(LocalPath(\"src/compile.rs\"))",""],"compile::SuffixCache::new":["new","Real(LocalPath(\"src/compile.rs\"))",""],"compile::u32_to_usize":["u32_to_usize","Real(LocalPath(\"src/compile.rs\"))",""],"dfa::Byte::as_byte":["as_byte","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Byte::byte":["byte","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Byte::eof":["eof","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Byte::is_ascii_word":["is_ascii_word","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Byte::is_eof":["is_eof","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Cache::new":["new","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::CacheInner::reset_size":["reset_size","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::add_state":["add_state","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::approximate_size":["approximate_size","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::byte_class":["byte_class","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::cached_state":["cached_state","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::cached_state_key":["cached_state_key","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::clear_cache":["clear_cache","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::clear_cache_and_save":["clear_cache_and_save","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::continue_past_first_match":["continue_past_first_match","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::exec_at":["exec_at","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::exec_at_reverse":["exec_at_reverse","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::exec_byte":["exec_byte","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::follow_epsilons":["follow_epsilons","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::forward":["forward","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::forward_many":["forward_many","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::has_prefix":["has_prefix","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::next_si":["next_si","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::next_state":["next_state","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::num_byte_classes":["num_byte_classes","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::prefix_at":["prefix_at","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::restore_state":["restore_state","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::reverse":["reverse","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::start_flags":["start_flags","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::start_flags_reverse":["start_flags_reverse","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::start_ptr":["start_ptr","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::start_state":["start_state","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::state":["state","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Fsm::<'a>::u8_class":["u8_class","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Result::<T>::is_match":["is_match","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Result::<T>::map":["map","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Result::<T>::set_non_match":["set_non_match","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::State::flags":["flags","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::State::inst_ptrs":["inst_ptrs","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateFlags::has_empty":["has_empty","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateFlags::is_match":["is_match","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateFlags::is_word":["is_word","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateFlags::set_empty":["set_empty","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateFlags::set_match":["set_match","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateFlags::set_word":["set_word","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateMap::clear":["clear","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateMap::get_ptr":["get_ptr","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateMap::get_state":["get_state","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateMap::insert":["insert","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateMap::is_empty":["is_empty","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateMap::len":["len","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::StateMap::new":["new","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Transitions::add":["add","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Transitions::clear":["clear","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Transitions::new":["new","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Transitions::next":["next","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Transitions::next_unchecked":["next_unchecked","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Transitions::num_states":["num_states","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Transitions::set_next":["set_next","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::Transitions::state_heap_size":["state_heap_size","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::can_exec":["can_exec","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::push_inst_ptr":["push_inst_ptr","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::read_vari32":["read_vari32","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::read_varu32":["read_varu32","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::show_state_ptr":["show_state_ptr","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::usize_to_u32":["usize_to_u32","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::vb":["vb","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::write_vari32":["write_vari32","Real(LocalPath(\"src/dfa.rs\"))",""],"dfa::write_varu32":["write_varu32","Real(LocalPath(\"src/dfa.rs\"))",""],"exec::Exec::capture_name_idx":["capture_name_idx","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::capture_names":["capture_names","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::into_byte_regex":["into_byte_regex","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::into_byte_regex_set":["into_byte_regex_set","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::into_regex":["into_regex","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::into_regex_set":["into_regex_set","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::regex_strings":["regex_strings","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::searcher":["searcher","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::searcher_str":["searcher_str","Real(LocalPath(\"src/exec.rs\"))",""],"exec::Exec::static_captures_len":["static_captures_len","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::automatic":["automatic","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::bounded_backtracking":["bounded_backtracking","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::build":["build","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::build_aho_corasick":["build_aho_corasick","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::bytes":["bytes","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::new":["new","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::new_many":["new_many","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::new_options":["new_options","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::nfa":["nfa","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::only_utf8":["only_utf8","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::parse":["parse","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecBuilder::unicode":["unicode","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::capture_name_idx":["capture_name_idx","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::captures_nfa":["captures_nfa","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::captures_nfa_type":["captures_nfa_type","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::exec_backtrack":["exec_backtrack","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::exec_dfa_reverse_suffix":["exec_dfa_reverse_suffix","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::exec_nfa":["exec_nfa","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::exec_pikevm":["exec_pikevm","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::find_dfa_anchored_reverse":["find_dfa_anchored_reverse","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::find_dfa_forward":["find_dfa_forward","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::find_dfa_reverse_suffix":["find_dfa_reverse_suffix","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::find_literals":["find_literals","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::find_nfa":["find_nfa","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::is_anchor_end_match":["is_anchor_end_match","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::is_anchor_end_match::imp":["imp","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::many_matches_at":["many_matches_at","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::match_nfa":["match_nfa","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::match_nfa_type":["match_nfa_type","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::shortest_dfa":["shortest_dfa","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::shortest_dfa_reverse_suffix":["shortest_dfa_reverse_suffix","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::shortest_nfa":["shortest_nfa","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSync::<'c>::shortest_nfa_type":["shortest_nfa_type","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecNoSyncStr::<'c>::capture_name_idx":["capture_name_idx","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecReadOnly::choose_dfa_match_type":["choose_dfa_match_type","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecReadOnly::choose_dfa_match_type::imp":["imp","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecReadOnly::choose_literal_match_type":["choose_literal_match_type","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecReadOnly::choose_literal_match_type::imp":["imp","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecReadOnly::choose_match_type":["choose_match_type","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecReadOnly::new_pool":["new_pool","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ExecReadOnly::should_suffix_scan":["should_suffix_scan","Real(LocalPath(\"src/exec.rs\"))",""],"exec::ProgramCacheInner::new":["new","Real(LocalPath(\"src/exec.rs\"))",""],"exec::alternation_literals":["alternation_literals","Real(LocalPath(\"src/exec.rs\"))",""],"exec::literal_analysis":["literal_analysis","Real(LocalPath(\"src/exec.rs\"))",""],"expand::expand_bytes":["expand_bytes","Real(LocalPath(\"src/expand.rs\"))",""],"expand::expand_str":["expand_str","Real(LocalPath(\"src/expand.rs\"))",""],"expand::find_cap_ref":["find_cap_ref","Real(LocalPath(\"src/expand.rs\"))",""],"expand::find_cap_ref_braced":["find_cap_ref_braced","Real(LocalPath(\"src/expand.rs\"))",""],"expand::is_valid_cap_letter":["is_valid_cap_letter","Real(LocalPath(\"src/expand.rs\"))",""],"find_byte::find_byte":["find_byte","Real(LocalPath(\"src/find_byte.rs\"))",""],"find_byte::find_byte::imp":["imp","Real(LocalPath(\"src/find_byte.rs\"))",""],"input::<impl std::cmp::PartialEq<input::Char> for char>::eq":["eq","Real(LocalPath(\"src/input.rs\"))","std::cmp::PartialEq"],"input::<impl std::cmp::PartialOrd<input::Char> for char>::partial_cmp":["partial_cmp","Real(LocalPath(\"src/input.rs\"))","std::cmp::PartialOrd"],"input::ByteInput::<'t>::new":["new","Real(LocalPath(\"src/input.rs\"))",""],"input::Char::is_none":["is_none","Real(LocalPath(\"src/input.rs\"))",""],"input::Char::is_word_byte":["is_word_byte","Real(LocalPath(\"src/input.rs\"))",""],"input::Char::is_word_char":["is_word_char","Real(LocalPath(\"src/input.rs\"))",""],"input::Char::len_utf8":["len_utf8","Real(LocalPath(\"src/input.rs\"))",""],"input::CharInput::<'t>::new":["new","Real(LocalPath(\"src/input.rs\"))",""],"input::Input::is_empty":["is_empty","Real(LocalPath(\"src/input.rs\"))",""],"input::InputAt::byte":["byte","Real(LocalPath(\"src/input.rs\"))",""],"input::InputAt::char":["char","Real(LocalPath(\"src/input.rs\"))",""],"input::InputAt::is_empty":["is_empty","Real(LocalPath(\"src/input.rs\"))",""],"input::InputAt::is_end":["is_end","Real(LocalPath(\"src/input.rs\"))",""],"input::InputAt::is_start":["is_start","Real(LocalPath(\"src/input.rs\"))",""],"input::InputAt::len":["len","Real(LocalPath(\"src/input.rs\"))",""],"input::InputAt::next_pos":["next_pos","Real(LocalPath(\"src/input.rs\"))",""],"input::InputAt::pos":["pos","Real(LocalPath(\"src/input.rs\"))",""],"literal::imp::LiteralSearcher::approximate_size":["approximate_size","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::complete":["complete","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::empty":["empty","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::find":["find","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::find_end":["find_end","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::find_start":["find_start","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::is_empty":["is_empty","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::iter":["iter","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::lcp":["lcp","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::lcs":["lcs","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::len":["len","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::new":["new","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::prefixes":["prefixes","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::LiteralSearcher::suffixes":["suffixes","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Matcher::new":["new","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Matcher::prefixes":["prefixes","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Matcher::suffixes":["suffixes","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Memmem::approximate_size":["approximate_size","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Memmem::char_len":["char_len","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Memmem::find":["find","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Memmem::is_suffix":["is_suffix","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Memmem::len":["len","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::Memmem::new":["new","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::SingleByteSet::_find":["_find","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::SingleByteSet::approximate_size":["approximate_size","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::SingleByteSet::find":["find","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::SingleByteSet::new":["new","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::SingleByteSet::prefixes":["prefixes","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::SingleByteSet::suffixes":["suffixes","Real(LocalPath(\"src/literal/imp.rs\"))",""],"literal::imp::char_len_lossy":["char_len_lossy","Real(LocalPath(\"src/literal/imp.rs\"))",""],"pikevm::Cache::new":["new","Real(LocalPath(\"src/pikevm.rs\"))",""],"pikevm::Fsm::<'r, I>::add":["add","Real(LocalPath(\"src/pikevm.rs\"))",""],"pikevm::Fsm::<'r, I>::add_step":["add_step","Real(LocalPath(\"src/pikevm.rs\"))",""],"pikevm::Fsm::<'r, I>::exec":["exec","Real(LocalPath(\"src/pikevm.rs\"))",""],"pikevm::Fsm::<'r, I>::exec_":["exec_","Real(LocalPath(\"src/pikevm.rs\"))",""],"pikevm::Fsm::<'r, I>::step":["step","Real(LocalPath(\"src/pikevm.rs\"))",""],"pikevm::Threads::caps":["caps","Real(LocalPath(\"src/pikevm.rs\"))",""],"pikevm::Threads::new":["new","Real(LocalPath(\"src/pikevm.rs\"))",""],"pikevm::Threads::resize":["resize","Real(LocalPath(\"src/pikevm.rs\"))",""],"pool::Pool::<T>::get":["get","Real(LocalPath(\"src/pool.rs\"))",""],"pool::Pool::<T>::get_slow":["get_slow","Real(LocalPath(\"src/pool.rs\"))",""],"pool::Pool::<T>::guard_owned":["guard_owned","Real(LocalPath(\"src/pool.rs\"))",""],"pool::Pool::<T>::guard_stack":["guard_stack","Real(LocalPath(\"src/pool.rs\"))",""],"pool::Pool::<T>::new":["new","Real(LocalPath(\"src/pool.rs\"))",""],"pool::Pool::<T>::put":["put","Real(LocalPath(\"src/pool.rs\"))",""],"pool::PoolGuard::<'a, T>::value":["value","Real(LocalPath(\"src/pool.rs\"))",""],"pool::THREAD_ID::__init":["__init","Real(Remapped { local_path: Some(\"/home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/sys/thread_local/native/mod.rs\"), virtual_name: \"/rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/std/src/sys/thread_local/native/mod.rs\" })",""],"prog::Inst::is_match":["is_match","Real(LocalPath(\"src/prog.rs\"))",""],"prog::InstBytes::matches":["matches","Real(LocalPath(\"src/prog.rs\"))",""],"prog::InstRanges::matches":["matches","Real(LocalPath(\"src/prog.rs\"))",""],"prog::InstRanges::num_chars":["num_chars","Real(LocalPath(\"src/prog.rs\"))",""],"prog::Program::approximate_size":["approximate_size","Real(LocalPath(\"src/prog.rs\"))",""],"prog::Program::leads_to_match":["leads_to_match","Real(LocalPath(\"src/prog.rs\"))",""],"prog::Program::needs_dotstar":["needs_dotstar","Real(LocalPath(\"src/prog.rs\"))",""],"prog::Program::new":["new","Real(LocalPath(\"src/prog.rs\"))",""],"prog::Program::only_utf8":["only_utf8","Real(LocalPath(\"src/prog.rs\"))",""],"prog::Program::skip":["skip","Real(LocalPath(\"src/prog.rs\"))",""],"prog::Program::uses_bytes":["uses_bytes","Real(LocalPath(\"src/prog.rs\"))",""],"re_builder::bytes::RegexBuilder::build":["build","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::case_insensitive":["case_insensitive","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::dfa_size_limit":["dfa_size_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::multi_line":["multi_line","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::nest_limit":["nest_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::new":["new","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::octal":["octal","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::size_limit":["size_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::swap_greed":["swap_greed","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::bytes::RegexBuilder::unicode":["unicode","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::build":["build","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::case_insensitive":["case_insensitive","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::dfa_size_limit":["dfa_size_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::multi_line":["multi_line","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::nest_limit":["nest_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::new":["new","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::octal":["octal","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::size_limit":["size_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::swap_greed":["swap_greed","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_bytes::RegexSetBuilder::unicode":["unicode","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::build":["build","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::case_insensitive":["case_insensitive","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::dfa_size_limit":["dfa_size_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::multi_line":["multi_line","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::nest_limit":["nest_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::new":["new","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::octal":["octal","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::size_limit":["size_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::swap_greed":["swap_greed","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::set_unicode::RegexSetBuilder::unicode":["unicode","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::build":["build","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::case_insensitive":["case_insensitive","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::dfa_size_limit":["dfa_size_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::dot_matches_new_line":["dot_matches_new_line","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::ignore_whitespace":["ignore_whitespace","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::multi_line":["multi_line","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::nest_limit":["nest_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::new":["new","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::octal":["octal","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::size_limit":["size_limit","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::swap_greed":["swap_greed","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_builder::unicode::RegexBuilder::unicode":["unicode","Real(LocalPath(\"src/re_builder.rs\"))",""],"re_bytes::<impl std::convert::From<re_bytes::Match<'t>> for std::ops::Range<usize>>::from":["from","Real(LocalPath(\"src/re_bytes.rs\"))","std::convert::From"],"re_bytes::CaptureLocations::get":["get","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::CaptureLocations::len":["len","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::CaptureLocations::pos":["pos","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Captures::<'t>::expand":["expand","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Captures::<'t>::get":["get","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Captures::<'t>::iter":["iter","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Captures::<'t>::len":["len","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Captures::<'t>::name":["name","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Match::<'t>::as_bytes":["as_bytes","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Match::<'t>::end":["end","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Match::<'t>::is_empty":["is_empty","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Match::<'t>::len":["len","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Match::<'t>::new":["new","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Match::<'t>::range":["range","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Match::<'t>::start":["start","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::as_str":["as_str","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::capture_locations":["capture_locations","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::capture_names":["capture_names","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::captures":["captures","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::captures_at":["captures_at","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::captures_iter":["captures_iter","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::captures_len":["captures_len","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::captures_read":["captures_read","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::captures_read_at":["captures_read_at","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::find":["find","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::find_at":["find_at","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::find_iter":["find_iter","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::is_match":["is_match","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::is_match_at":["is_match_at","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::locations":["locations","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::new":["new","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::read_captures_at":["read_captures_at","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::replace":["replace","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::replace_all":["replace_all","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::replacen":["replacen","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::shortest_match":["shortest_match","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::shortest_match_at":["shortest_match_at","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::split":["split","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::splitn":["splitn","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Regex::static_captures_len":["static_captures_len","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Replacer::by_ref":["by_ref","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::Replacer::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_bytes::no_expansion":["no_expansion","Real(LocalPath(\"src/re_bytes.rs\"))",""],"re_set::bytes::RegexSet::empty":["empty","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::RegexSet::is_empty":["is_empty","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::RegexSet::is_match":["is_match","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::RegexSet::is_match_at":["is_match_at","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::RegexSet::len":["len","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::RegexSet::matches":["matches","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::RegexSet::new":["new","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::RegexSet::patterns":["patterns","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::RegexSet::read_matches_at":["read_matches_at","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::SetMatches::iter":["iter","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::SetMatches::len":["len","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::SetMatches::matched":["matched","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::SetMatches::matched_any":["matched_any","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::as_bytes_bytes":["as_bytes_bytes","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::bytes::as_bytes_str":["as_bytes_str","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::empty":["empty","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::is_empty":["is_empty","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::is_match":["is_match","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::is_match_at":["is_match_at","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::len":["len","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::matches":["matches","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::new":["new","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::patterns":["patterns","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::RegexSet::read_matches_at":["read_matches_at","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::SetMatches::iter":["iter","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::SetMatches::len":["len","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::SetMatches::matched":["matched","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::SetMatches::matched_any":["matched_any","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::as_bytes_bytes":["as_bytes_bytes","Real(LocalPath(\"src/re_set.rs\"))",""],"re_set::unicode::as_bytes_str":["as_bytes_str","Real(LocalPath(\"src/re_set.rs\"))",""],"re_trait::CaptureMatches::<'t, R>::regex":["regex","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::CaptureMatches::<'t, R>::text":["text","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::Locations::as_slots":["as_slots","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::Locations::iter":["iter","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::Locations::len":["len","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::Locations::pos":["pos","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::Matches::<'t, R>::regex":["regex","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::Matches::<'t, R>::text":["text","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::RegularExpression::captures_iter":["captures_iter","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::RegularExpression::find_iter":["find_iter","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_trait::RegularExpression::locations":["locations","Real(LocalPath(\"src/re_trait.rs\"))",""],"re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for &'t str>::from":["from","Real(LocalPath(\"src/re_unicode.rs\"))","std::convert::From"],"re_unicode::<impl std::convert::From<re_unicode::Match<'t>> for std::ops::Range<usize>>::from":["from","Real(LocalPath(\"src/re_unicode.rs\"))","std::convert::From"],"re_unicode::CaptureLocations::get":["get","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::CaptureLocations::len":["len","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::CaptureLocations::pos":["pos","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Captures::<'t>::expand":["expand","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Captures::<'t>::get":["get","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Captures::<'t>::iter":["iter","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Captures::<'t>::len":["len","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Captures::<'t>::name":["name","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Match::<'t>::as_str":["as_str","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Match::<'t>::end":["end","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Match::<'t>::is_empty":["is_empty","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Match::<'t>::len":["len","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Match::<'t>::new":["new","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Match::<'t>::range":["range","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Match::<'t>::start":["start","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::as_str":["as_str","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::capture_locations":["capture_locations","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::capture_names":["capture_names","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::captures":["captures","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::captures_at":["captures_at","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::captures_iter":["captures_iter","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::captures_len":["captures_len","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::captures_read":["captures_read","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::captures_read_at":["captures_read_at","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::find":["find","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::find_at":["find_at","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::find_iter":["find_iter","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::is_match":["is_match","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::is_match_at":["is_match_at","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::locations":["locations","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::new":["new","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::read_captures_at":["read_captures_at","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::replace":["replace","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::replace_all":["replace_all","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::replacen":["replacen","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::shortest_match":["shortest_match","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::shortest_match_at":["shortest_match_at","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::split":["split","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::splitn":["splitn","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Regex::static_captures_len":["static_captures_len","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Replacer::by_ref":["by_ref","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::Replacer::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::escape":["escape","Real(LocalPath(\"src/re_unicode.rs\"))",""],"re_unicode::no_expansion":["no_expansion","Real(LocalPath(\"src/re_unicode.rs\"))",""],"sparse::SparseSet::capacity":["capacity","Real(LocalPath(\"src/sparse.rs\"))",""],"sparse::SparseSet::clear":["clear","Real(LocalPath(\"src/sparse.rs\"))",""],"sparse::SparseSet::contains":["contains","Real(LocalPath(\"src/sparse.rs\"))",""],"sparse::SparseSet::insert":["insert","Real(LocalPath(\"src/sparse.rs\"))",""],"sparse::SparseSet::is_empty":["is_empty","Real(LocalPath(\"src/sparse.rs\"))",""],"sparse::SparseSet::len":["len","Real(LocalPath(\"src/sparse.rs\"))",""],"sparse::SparseSet::new":["new","Real(LocalPath(\"src/sparse.rs\"))",""],"utf8::decode_last_utf8":["decode_last_utf8","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::decode_utf8":["decode_utf8","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::is_start_byte":["is_start_byte","Real(LocalPath(\"src/utf8.rs\"))",""],"utf8::next_utf8":["next_utf8","Real(LocalPath(\"src/utf8.rs\"))",""]},"trait_to_struct":{"input::Input":["input::ByteInput","input::CharInput"],"re_bytes::Replacer":["<F as re_bytes::Replacer>::F","re_bytes::NoExpand","re_bytes::ReplacerRef","std::borrow::Cow","std::vec::Vec"],"re_trait::RegularExpression":["exec::ExecNoSync","exec::ExecNoSyncStr"],"re_unicode::Replacer":["<F as re_unicode::Replacer>::F","re_unicode::NoExpand","re_unicode::ReplacerRef","std::borrow::Cow","std::string::String"],"std::clone::Clone":["backtrack::Cache","backtrack::Job","compile::InstHole","compile::MaybeInst","compile::SuffixCacheEntry","compile::SuffixCacheKey","dfa::Byte","dfa::EmptyFlags","dfa::Result","dfa::State","dfa::StateFlags","dfa::Transitions","error::Error","exec::Exec","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","expand::CaptureRef","expand::Ref","input::ByteInput","input::Char","input::CharInput","input::InputAt","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","pikevm::Cache","pikevm::FollowEpsilon","pikevm::Threads","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","prog::Program","re_builder::RegexOptions","re_bytes::CaptureLocations","re_bytes::CaptureNames","re_bytes::Match","re_bytes::NoExpand","re_bytes::Regex","re_bytes::SubCaptureMatches","re_set::bytes::RegexSet","re_set::bytes::SetMatches","re_set::bytes::SetMatchesIter","re_set::unicode::RegexSet","re_set::unicode::SetMatches","re_set::unicode::SetMatchesIter","re_trait::Locations","re_trait::SubCapturesPosIter","re_unicode::CaptureLocations","re_unicode::CaptureNames","re_unicode::Match","re_unicode::NoExpand","re_unicode::Regex","re_unicode::SubCaptureMatches","sparse::SparseSet"],"std::cmp::Eq":["compile::SuffixCacheEntry","compile::SuffixCacheKey","dfa::EmptyFlags","dfa::State","dfa::StateFlags","exec::MatchNfaType","expand::CaptureRef","expand::Ref","input::Char","prog::EmptyLook","re_bytes::Match","re_unicode::Match"],"std::cmp::Ord":["input::Char"],"std::cmp::PartialEq":["compile::SuffixCacheEntry","compile::SuffixCacheKey","dfa::EmptyFlags","dfa::State","dfa::StateFlags","error::Error","exec::MatchNfaType","expand::CaptureRef","expand::Ref","input::Char","prog::EmptyLook","re_bytes::Match","re_unicode::Match"],"std::cmp::PartialOrd":["input::Char"],"std::convert::From":["expand::Ref","input::Char","re_bytes::Regex","re_set::bytes::RegexSet","re_set::unicode::RegexSet","re_unicode::Regex","std::ops::Range"],"std::default::Default":["compile::SuffixCacheEntry","compile::SuffixCacheKey","dfa::EmptyFlags","dfa::StateFlags","re_builder::RegexOptions","re_set::bytes::RegexSet","re_set::unicode::RegexSet"],"std::error::Error":["error::Error"],"std::fmt::Debug":["backtrack::Bounded","backtrack::Cache","backtrack::Job","compile::ByteClassSet","compile::Hole","compile::InstHole","compile::MaybeInst","compile::Patch","compile::SuffixCache","compile::SuffixCacheEntry","compile::SuffixCacheKey","dfa::Byte","dfa::Cache","dfa::CacheInner","dfa::EmptyFlags","dfa::Fsm","dfa::Result","dfa::State","dfa::StateFlags","dfa::StateMap","dfa::Transitions","dfa::TransitionsRow","error::Error","exec::Exec","exec::ExecNoSync","exec::ExecNoSyncStr","exec::ExecReadOnly","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","exec::ProgramCacheInner","expand::CaptureRef","expand::Ref","input::ByteInput","input::Char","input::CharInput","input::InputAt","literal::imp::LiteralIter","literal::imp::LiteralSearcher","literal::imp::Matcher","literal::imp::Memmem","literal::imp::SingleByteSet","pikevm::Cache","pikevm::FollowEpsilon","pikevm::Fsm","pikevm::Threads","pool::Pool","pool::PoolGuard","prog::EmptyLook","prog::Inst","prog::InstBytes","prog::InstChar","prog::InstEmptyLook","prog::InstRanges","prog::InstSave","prog::InstSplit","prog::Program","re_builder::RegexOptions","re_builder::bytes::RegexBuilder","re_builder::set_bytes::RegexSetBuilder","re_builder::set_unicode::RegexSetBuilder","re_builder::unicode::RegexBuilder","re_bytes::CaptureLocations","re_bytes::CaptureMatches","re_bytes::CaptureNames","re_bytes::Captures","re_bytes::CapturesDebug","re_bytes::Match","re_bytes::Matches","re_bytes::NoExpand","re_bytes::Regex","re_bytes::ReplacerRef","re_bytes::Split","re_bytes::SplitN","re_bytes::SubCaptureMatches","re_set::bytes::RegexSet","re_set::bytes::SetMatches","re_set::bytes::SetMatchesIntoIter","re_set::bytes::SetMatchesIter","re_set::unicode::RegexSet","re_set::unicode::SetMatches","re_set::unicode::SetMatchesIntoIter","re_set::unicode::SetMatchesIter","re_trait::CaptureMatches","re_trait::Locations","re_trait::Matches","re_trait::SubCapturesPosIter","re_unicode::CaptureLocations","re_unicode::CaptureMatches","re_unicode::CaptureNames","re_unicode::Captures","re_unicode::CapturesDebug","re_unicode::Match","re_unicode::Matches","re_unicode::NoExpand","re_unicode::Regex","re_unicode::ReplacerRef","re_unicode::Split","re_unicode::SplitN","re_unicode::SubCaptureMatches","sparse::SparseSet"],"std::fmt::Display":["error::Error","re_bytes::Regex","re_unicode::Regex"],"std::hash::Hash":["compile::SuffixCacheEntry","compile::SuffixCacheKey","dfa::EmptyFlags","dfa::State","dfa::StateFlags","input::Char"],"std::iter::DoubleEndedIterator":["re_set::bytes::SetMatchesIntoIter","re_set::bytes::SetMatchesIter","re_set::unicode::SetMatchesIntoIter","re_set::unicode::SetMatchesIter"],"std::iter::ExactSizeIterator":["re_bytes::CaptureNames","re_trait::SubCapturesPosIter","re_unicode::CaptureNames","re_unicode::SubCaptureMatches"],"std::iter::FusedIterator":["re_bytes::CaptureMatches","re_bytes::CaptureNames","re_bytes::Matches","re_bytes::Split","re_bytes::SplitN","re_bytes::SubCaptureMatches","re_set::bytes::SetMatchesIntoIter","re_set::bytes::SetMatchesIter","re_set::unicode::SetMatchesIntoIter","re_set::unicode::SetMatchesIter","re_trait::CaptureMatches","re_trait::Matches","re_trait::SubCapturesPosIter","re_unicode::CaptureMatches","re_unicode::CaptureNames","re_unicode::Matches","re_unicode::Split","re_unicode::SplitN","re_unicode::SubCaptureMatches"],"std::iter::IntoIterator":["re_set::bytes::SetMatches","re_set::unicode::SetMatches"],"std::iter::Iterator":["dfa::InstPtrs","literal::imp::LiteralIter","re_bytes::CaptureMatches","re_bytes::CaptureNames","re_bytes::Matches","re_bytes::Split","re_bytes::SplitN","re_bytes::SubCaptureMatches","re_set::bytes::SetMatchesIntoIter","re_set::bytes::SetMatchesIter","re_set::unicode::SetMatchesIntoIter","re_set::unicode::SetMatchesIter","re_trait::CaptureMatches","re_trait::Matches","re_trait::SubCapturesPosIter","re_unicode::CaptureMatches","re_unicode::CaptureNames","re_unicode::Matches","re_unicode::Split","re_unicode::SplitN","re_unicode::SubCaptureMatches"],"std::marker::Copy":["backtrack::Job","compile::SuffixCacheEntry","compile::SuffixCacheKey","dfa::Byte","dfa::EmptyFlags","dfa::StateFlags","exec::MatchLiteralType","exec::MatchNfaType","exec::MatchType","expand::CaptureRef","expand::Ref","input::ByteInput","input::Char","input::CharInput","input::InputAt","prog::EmptyLook","re_bytes::Match","re_unicode::Match"],"std::marker::StructuralPartialEq":["compile::SuffixCacheEntry","compile::SuffixCacheKey","dfa::EmptyFlags","dfa::State","dfa::StateFlags","error::Error","exec::MatchNfaType","expand::CaptureRef","expand::Ref","input::Char","prog::EmptyLook","re_bytes::Match","re_unicode::Match"],"std::marker::Sync":["pool::Pool"],"std::ops::Deref":["input::ByteInput","input::CharInput","prog::Program","sparse::SparseSet"],"std::ops::Drop":["pool::PoolGuard"],"std::ops::Index":["re_bytes::Captures","re_unicode::Captures"],"std::str::FromStr":["re_bytes::Regex","re_unicode::Regex"]},"type_to_def_path":{"backtrack::Bounded<'a, 'm, 'r, 's, I>":"backtrack::Bounded","backtrack::Cache":"backtrack::Cache","backtrack::Job":"backtrack::Job","compile::ByteClassSet":"compile::ByteClassSet","compile::CompileClass<'a, 'b>":"compile::CompileClass","compile::Compiler":"compile::Compiler","compile::Hole":"compile::Hole","compile::InstHole":"compile::InstHole","compile::MaybeInst":"compile::MaybeInst","compile::Patch":"compile::Patch","compile::SuffixCache":"compile::SuffixCache","compile::SuffixCacheEntry":"compile::SuffixCacheEntry","compile::SuffixCacheKey":"compile::SuffixCacheKey","dfa::Byte":"dfa::Byte","dfa::Cache":"dfa::Cache","dfa::CacheInner":"dfa::CacheInner","dfa::EmptyFlags":"dfa::EmptyFlags","dfa::Fsm<'a>":"dfa::Fsm","dfa::InstPtrs<'a>":"dfa::InstPtrs","dfa::Result<T>":"dfa::Result","dfa::State":"dfa::State","dfa::StateFlags":"dfa::StateFlags","dfa::StateMap":"dfa::StateMap","dfa::Transitions":"dfa::Transitions","dfa::TransitionsRow<'a>":"dfa::TransitionsRow","error::Error":"error::Error","exec::Exec":"exec::Exec","exec::ExecBuilder":"exec::ExecBuilder","exec::ExecNoSync<'c>":"exec::ExecNoSync","exec::ExecNoSyncStr<'c>":"exec::ExecNoSyncStr","exec::ExecReadOnly":"exec::ExecReadOnly","exec::MatchLiteralType":"exec::MatchLiteralType","exec::MatchNfaType":"exec::MatchNfaType","exec::MatchType":"exec::MatchType","exec::Parsed":"exec::Parsed","exec::ProgramCacheInner":"exec::ProgramCacheInner","expand::CaptureRef<'a>":"expand::CaptureRef","expand::Ref<'a>":"expand::Ref","input::ByteInput<'t>":"input::ByteInput","input::Char":"input::Char","input::CharInput<'t>":"input::CharInput","input::InputAt":"input::InputAt","literal::imp::LiteralIter<'a>":"literal::imp::LiteralIter","literal::imp::LiteralSearcher":"literal::imp::LiteralSearcher","literal::imp::Matcher":"literal::imp::Matcher","literal::imp::Memmem":"literal::imp::Memmem","literal::imp::SingleByteSet":"literal::imp::SingleByteSet","pikevm::Cache":"pikevm::Cache","pikevm::FollowEpsilon":"pikevm::FollowEpsilon","pikevm::Fsm<'r, I>":"pikevm::Fsm","pikevm::Threads":"pikevm::Threads","pool::Pool<T>":"pool::Pool","pool::PoolGuard<'a, T>":"pool::PoolGuard","prog::EmptyLook":"prog::EmptyLook","prog::Inst":"prog::Inst","prog::InstBytes":"prog::InstBytes","prog::InstChar":"prog::InstChar","prog::InstEmptyLook":"prog::InstEmptyLook","prog::InstRanges":"prog::InstRanges","prog::InstSave":"prog::InstSave","prog::InstSplit":"prog::InstSplit","prog::Program":"prog::Program","re_builder::RegexOptions":"re_builder::RegexOptions","re_builder::bytes::RegexBuilder":"re_builder::bytes::RegexBuilder","re_builder::set_bytes::RegexSetBuilder":"re_builder::set_bytes::RegexSetBuilder","re_builder::set_unicode::RegexSetBuilder":"re_builder::set_unicode::RegexSetBuilder","re_builder::unicode::RegexBuilder":"re_builder::unicode::RegexBuilder","re_bytes::CaptureLocations":"re_bytes::CaptureLocations","re_bytes::CaptureMatches<'r, 't>":"re_bytes::CaptureMatches","re_bytes::CaptureNames<'r>":"re_bytes::CaptureNames","re_bytes::Captures<'t>":"re_bytes::Captures","re_bytes::CapturesDebug<'c, 't>":"re_bytes::CapturesDebug","re_bytes::Match<'t>":"re_bytes::Match","re_bytes::Matches<'r, 't>":"re_bytes::Matches","re_bytes::NoExpand<'t>":"re_bytes::NoExpand","re_bytes::Regex":"re_bytes::Regex","re_bytes::ReplacerRef<'a, R>":"re_bytes::ReplacerRef","re_bytes::Split<'r, 't>":"re_bytes::Split","re_bytes::SplitN<'r, 't>":"re_bytes::SplitN","re_bytes::SubCaptureMatches<'c, 't>":"re_bytes::SubCaptureMatches","re_set::bytes::RegexSet":"re_set::bytes::RegexSet","re_set::bytes::SetMatches":"re_set::bytes::SetMatches","re_set::bytes::SetMatchesIntoIter":"re_set::bytes::SetMatchesIntoIter","re_set::bytes::SetMatchesIter<'a>":"re_set::bytes::SetMatchesIter","re_set::unicode::RegexSet":"re_set::unicode::RegexSet","re_set::unicode::SetMatches":"re_set::unicode::SetMatches","re_set::unicode::SetMatchesIntoIter":"re_set::unicode::SetMatchesIntoIter","re_set::unicode::SetMatchesIter<'a>":"re_set::unicode::SetMatchesIter","re_trait::CaptureMatches<'t, R>":"re_trait::CaptureMatches","re_trait::Locations":"re_trait::Locations","re_trait::Matches<'t, R>":"re_trait::Matches","re_trait::SubCapturesPosIter<'c>":"re_trait::SubCapturesPosIter","re_unicode::CaptureLocations":"re_unicode::CaptureLocations","re_unicode::CaptureMatches<'r, 't>":"re_unicode::CaptureMatches","re_unicode::CaptureNames<'r>":"re_unicode::CaptureNames","re_unicode::Captures<'t>":"re_unicode::Captures","re_unicode::CapturesDebug<'c, 't>":"re_unicode::CapturesDebug","re_unicode::Match<'t>":"re_unicode::Match","re_unicode::Matches<'r, 't>":"re_unicode::Matches","re_unicode::NoExpand<'t>":"re_unicode::NoExpand","re_unicode::Regex":"re_unicode::Regex","re_unicode::ReplacerRef<'a, R>":"re_unicode::ReplacerRef","re_unicode::Split<'r, 't>":"re_unicode::Split","re_unicode::SplitN<'r, 't>":"re_unicode::SplitN","re_unicode::SubCaptureMatches<'c, 't>":"re_unicode::SubCaptureMatches","sparse::SparseSet":"sparse::SparseSet"}}